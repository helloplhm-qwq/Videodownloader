
BOOL sub_140001272();
__int64 __fastcall sub_140001299(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64, __int64, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64); // weak
__int64 sub_140001E6C(void); // weak
__int64 sub_1400021FF();
__int64 __fastcall sub_1400026D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
void __noreturn sub_140002868();
void __fastcall __noreturn sub_140002945(__int64 a1);
__int64 __fastcall sub_1400029DD(); // weak
__int64 __fastcall sub_140002A3C(signed __int16 *a1);
__int64 __fastcall HandlerRoutine(__int64 CtrlType);
__int64 __fastcall sub_140002BC3(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_140003017(const wchar_t *a1, const wchar_t *a2);
__int64 __fastcall sub_1400030F1(const wchar_t *a1);
__int64 __fastcall sub_140003172(__int64, __int64, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
void *__fastcall sub_14000348C(HMODULE a1, HRSRC a2);
__int64 __fastcall sub_140003C46(const wchar_t *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_140003D59(_DWORD, _DWORD, _DWORD, _DWORD);
signed __int64 __fastcall sub_140004029(__int64 a1, __int64 a2, void *a3);
LPVOID __fastcall sub_1400040B1(const wchar_t *a1);
__int64 __fastcall sub_14000418E(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
void __noreturn sub_1400042BC();
__int64 __fastcall sub_14000475F(const wchar_t *a1, const wchar_t *a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 sub_140004884();
__int64 __fastcall sub_140004967(__int64 a1, const wchar_t *a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_140004E5F(__int64, __int64, __int64, __int64, __int64); // weak
__int64 __fastcall sub_140005631(const wchar_t *a1);
__int64 __fastcall sub_140005711(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64, __int64, __int64); // weak
__int64 __fastcall sub_140005A1D(__int64); // weak
void __fastcall __noreturn sub_140005BC5(__int64, __int64, __int64, __int64, __int64, __int64, __int64); // weak
__int64 __fastcall sub_14000688A(signed __int16 *a1);
SIZE_T __fastcall sub_140006A23(const void *a1);
_BOOL8 __fastcall sub_140006A40(const wchar_t *a1, _BYTE *a2, __int64 a3);
void __fastcall __spoils<rdx,rcx,r8,r9,r10,r11,xmm4,xmm5> sub_140006B38(__int64 a1);
// void *__cdecl memset(void *Dst, int Val, size_t Size);
// HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName);
// HANDLE __stdcall HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
// BOOL __stdcall SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// UINT __stdcall GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);
// HMODULE __stdcall LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// BOOL __stdcall EnumResourceTypesW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// BOOL __stdcall RemoveDirectoryW(LPCWSTR lpPathName);
// LPWSTR __stdcall GetCommandLineW();
// HGLOBAL __stdcall LoadResource(HMODULE hModule, HRSRC hResInfo);
// DWORD __stdcall SizeofResource(HMODULE hModule, HRSRC hResInfo);
// BOOL __stdcall FreeResource(HGLOBAL hResData);
// HRSRC __stdcall FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType);
// DWORD __stdcall GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer);
// UINT __stdcall GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize);
// LPWSTR __stdcall PathAddBackslashW(LPWSTR pszPath);
// BOOL __stdcall PathRenameExtensionW(LPWSTR pszPath, LPCWSTR pszExt);
// BOOL __stdcall PathQuoteSpacesW(LPWSTR lpsz);
// void __stdcall PathRemoveArgsW(LPWSTR pszPath);
// LPWSTR __stdcall PathRemoveBackslashW(LPWSTR pszPath);
// int __cdecl wcsncmp(const wchar_t *Str1, const wchar_t *Str2, size_t MaxCount);
// void *__cdecl memmove(void *Dst, const void *Src, size_t Size);
// wchar_t *__cdecl wcsncpy(wchar_t *Dest, const wchar_t *Source, size_t Count);
// wchar_t *__cdecl wcsstr(const wchar_t *Str, const wchar_t *SubStr);
// int __cdecl wcsnicmp(const wchar_t *Str1, const wchar_t *Str2, size_t MaxCount);
// wchar_t *__cdecl wcsdup(const wchar_t *Str);
// void __cdecl free(void *Memory);
// int __cdecl wcsicmp(const wchar_t *Str1, const wchar_t *Str2);
// size_t __cdecl wcslen(const wchar_t *Str);
// wchar_t *__cdecl wcscpy(wchar_t *Dest, const wchar_t *Source);
// int __cdecl wcscmp(const wchar_t *Str1, const wchar_t *Str2);
// wchar_t *__cdecl wcscat(wchar_t *Dest, const wchar_t *Source);
// void *__cdecl memcpy(void *Dst, const void *Src, size_t Size);
// int __cdecl tolower(int C);
// void *__cdecl malloc(size_t Size);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// DWORD __stdcall GetLastError();
// void __stdcall SetLastError(DWORD dwErrCode);
void sub_140007108();
void sub_140007158();
void *__fastcall sub_140007168(__int64 a1);
__int64 __fastcall sub_140007194(__int64 a1);
void __fastcall sub_140007204(__int64 a1);
__int64 __fastcall sub_14000727C(LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter); // idb
void __fastcall sub_14000735C(DWORD a1);
CHAR *__fastcall sub_140007390(LPCWSTR lpWideCharStr);
__int64 __fastcall sub_140007430(_WORD *a1, _WORD *a2);
wchar_t *__fastcall sub_1400074D0(wchar_t *Source, signed int a2, const wchar_t *a3, int a4);
signed __int64 __fastcall sub_140007650(_WORD *a1, const wchar_t *a2);
signed __int64 __fastcall sub_1400076D0(_WORD *a1, const wchar_t *a2, signed int a3);
__int64 __fastcall sub_140007750(_WORD *a1, _WORD *a2);
signed __int64 __fastcall sub_1400077E0(unsigned __int16 *a1);
__int64 __fastcall sub_140007910(__int64 a1, int a2, int a3);
__int64 __fastcall sub_1400079C0(wchar_t *a1, _WORD *a2, int a3);
__int64 __fastcall sub_1400079F0(wchar_t *a1, _WORD *a2, int a3, int a4);
__int64 __fastcall sub_140007A20(wchar_t *a1, _WORD *a2, int a3, signed int a4, int a5);
// __int64 __usercall sub_140007A40@<rax>(wchar_t *Source@<rcx>, _WORD *a2@<rdx>, int a3@<r8d>, signed int a4@<r9d>, int a5, int a6);
_WORD *__fastcall sub_140007C80(__int16 a1, int a2);
signed __int64 __fastcall sub_140007CB0(__int64 a1);
__int64 __fastcall sub_140007CD0(__int16 *a1, int a2);
LPWSTR __fastcall sub_140007DB0(__int64 a1, int a2);
__int64 __fastcall sub_140007E40(__int64 a1, int a2, int a3);
__int64 __fastcall sub_140007EE0(__int64 a1, int a2);
__int64 __fastcall sub_140007EF0(__int64 a1, unsigned __int16 *a2, int a3);
__int64 __fastcall sub_140008000(unsigned __int64 a1, signed int a2, int a3);
__int64 __fastcall sub_140008040(unsigned __int64 a1, signed int a2, int a3, int a4);
__int64 __fastcall sub_140008100(signed __int64 a1, int a2);
_WORD *__fastcall sub_140008160(signed int a1, int a2);
void __fastcall sub_1400081C0(wchar_t *a1, void *a2, wchar_t *a3, int a4);
void __fastcall sub_1400081F0(wchar_t *a1, void *a2, wchar_t *a3, char a4, int a5);
void __fastcall sub_140008220(wchar_t *a1, void *a2, wchar_t *a3, char a4, int a5, int a6);
// void __usercall sub_140008250(wchar_t *Str@<rcx>, void *Memory@<rdx>, wchar_t *a3@<r8>, char a4@<r9b>, int a5, int a6, int a7);
unsigned __int16 *__fastcall sub_1400085E0(unsigned __int16 *a1, _WORD *a2);
__int64 __fastcall sub_1400086C0(__int64 a1, unsigned __int16 *a2, __int64 a3);
void __fastcall sub_140008750(__int64 *a1, __int64 a2, signed __int64 a3, signed __int64 a4);
void __fastcall sub_140008A80(_QWORD *a1);
__int64 __fastcall sub_140008D30(__int64 *a1);
__int64 __fastcall sub_140009060(__int64 *a1);
void __fastcall sub_140009080(_QWORD *a1, __int64 **a2, signed __int64 a3, __int64 a4);
void __fastcall sub_140009220(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4);
void __fastcall sub_1400093C0(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4);
void __fastcall sub_140009560(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4);
void __fastcall sub_140009700(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4);
void __fastcall sub_1400098A0(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4);
void __fastcall sub_140009A30(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4);
void __fastcall sub_140009BC0(_QWORD *a1, __int64 **a2, signed __int64 a3, __int64 a4);
void __fastcall sub_140009D90(_QWORD *a1, __int64 **a2, signed __int64 a3, __int64 a4);
void __fastcall sub_140009F60(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4);
void __fastcall sub_14000A100(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4);
void __fastcall sub_14000A2A0(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4);
void __fastcall sub_14000A440(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4);
void __fastcall sub_14000A5E0(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4);
void __fastcall sub_14000A780(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4);
void __fastcall sub_14000A920(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4);
void __fastcall sub_14000AAC0(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4);
void __fastcall sub_14000AC50(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4);
void __fastcall sub_14000ADE0(_QWORD *a1, __int64 **a2, signed __int64 a3, __int64 a4);
void __fastcall sub_14000AFB0(_QWORD *a1, __int64 **a2, signed __int64 a3, __int64 a4);
void __fastcall sub_14000B180(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4);
void __fastcall sub_14000B320(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4);
signed __int64 __fastcall sub_14000B4C0(char *a1, char *a2);
signed __int64 __fastcall sub_14000B500(__int64 a1, _WORD *a2);
HRESULT sub_14000B528();
__int64 __fastcall sub_14000B564(LPCWSTR lpCaption, LPCWSTR lpText, UINT uType); // idb
wchar_t *__fastcall sub_14000B5C8(wchar_t *Source);
BOOL __fastcall sub_14000B61C(LPVOID lpMem);
LRESULT __fastcall sub_14000B63C(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4);
int __fastcall sub_14000B730(wchar_t *a1, wchar_t *a2, wchar_t *a3);
int __fastcall sub_14000B748(wchar_t *a1, wchar_t *a2, wchar_t *a3, char a4);
void sub_14000BBFC();
__int64 __fastcall sub_14000BC28(HWND hWnd, int a2, __int64 a3, LPARAM a4);
__int64 __fastcall sub_14000BC84(__int64 a1, const wchar_t *a2, int a3);
HWND sub_14000BE4C();
signed __int64 __fastcall EnumFunc(HWND a1);
void __fastcall sub_14000BF34(int a1);
void __fastcall sub_14000C030(_QWORD *a1);
void sub_14000C06C();
__int64 __fastcall sub_14000C0B4(int a1);
LPWSTR __fastcall sub_14000C178(_DWORD *a1);
LPWSTR sub_14000C2AC();
__int64 __fastcall sub_14000C2C8(int a1);
__int64 __fastcall sub_14000C340(int a1, int a2);
__int64 __fastcall sub_14000C3CC(__int64 a1);
signed __int64 __fastcall sub_14000C41C(HANDLE *a1);
BOOL __fastcall sub_14000C484(HANDLE *a1);
void __fastcall sub_14000C494(HANDLE *a1);
DWORD __fastcall sub_14000C504(LPCWSTR lpName, int a2);
BOOL __fastcall sub_14000C56C(const WCHAR *a1);
int __fastcall sub_14000C584(const WCHAR *a1, const WCHAR *a2);
int __fastcall sub_14000C5AC(HANDLE *a1);
signed __int64 __fastcall sub_14000C610(wchar_t *a1);
signed __int64 __fastcall sub_14000C634(wchar_t *a1, const wchar_t *a2, const WCHAR *a3);
signed __int64 __fastcall sub_14000C64C(wchar_t *a1, const wchar_t *a2, const WCHAR *a3, int a4);
signed __int64 __fastcall sub_14000C660(wchar_t *a1, const wchar_t *a2, const WCHAR *a3, int a4, __int64 a5);
__int64 __fastcall sub_14000CBBC(void **a1);
__int64 __fastcall Handler(struct _EXCEPTION_POINTERS *ExceptionInfo);
void __fastcall sub_14000CC20(__int64 (*a1)(void));
unsigned __int64 __fastcall sub_14000CC40(__int64 a1);
ULONG sub_14000CE00();
signed __int64 __fastcall sub_14000CE30(__int64 a1);
void __fastcall sub_14000CFE0(PVECTORED_EXCEPTION_HANDLER Handler);
__int64 __fastcall sub_14000D030(int a1);
__int64 __fastcall sub_14000D040(int a1, int a2);
BOOL sub_14000D0C0();
HANDLE sub_14000D0D0();
SIZE_T __fastcall sub_14000D0F0(const void *a1);
BOOL __fastcall sub_14000D110(void *a1);
LPVOID __fastcall sub_14000D130(signed __int64 a1);
_WORD *__fastcall sub_14000D150(void *Src, int a2);
__int64 __fastcall sub_14000D1C0(signed __int16 *a1);
_WORD *__fastcall sub_14000D1D0(char *a1, __int64 a2, int a3);
char *__fastcall sub_14000D260(void *Src, void *Dst, size_t a3);
__int64 __fastcall sub_14000D290(__int64 a1);
void __fastcall sub_14000D2A0(_DWORD *a1, int a2);
int __fastcall sub_14000D2B0(LPCSTR lpMultiByteStr, signed __int64 a2, char a3, int a4);
BOOL (__fastcall *sub_14000D3FC())(LPVOID lpMem);
_QWORD *__fastcall sub_14000D428(__int64 a1, int a2, signed __int64 *a3, LPVOID *a4, signed int a5);
__int64 *__fastcall sub_14000D54C(__int64 a1, unsigned __int16 *a2);
BOOL __fastcall sub_14000D580(LPVOID lpMem);
signed __int64 __fastcall sub_14000D614(__int64 a1, __int64 a2, int a3);
__int64 *__fastcall sub_14000D6C4(__int64 a1, unsigned __int16 *a2);
_QWORD *__fastcall sub_14000D77C(__int64 a1, unsigned __int16 *a2, int a3);
void __fastcall sub_14000D890(__int64 a1);
void __fastcall sub_14000D934(__int64 a1);
void *__fastcall sub_14000D940(__int64 a1, __int64 a2, int a3);
signed __int64 __fastcall sub_14000DA3C(__int64 a1);
__int64 __fastcall sub_14000DADC(_WORD *a1);
__int64 __fastcall sub_14000DAF4(unsigned __int16 *a1);
_QWORD *__fastcall sub_14000DB30(__int64 a1, __int64 a2);
BOOL (__fastcall *sub_14000DB68())(LPVOID lpMem);
_BYTE *__fastcall sub_14000DB94(__int64 a1, _QWORD *a2, signed __int64 *a3, int a4);
BOOL __fastcall sub_14000DC74(LPVOID lpMem);
__int64 __fastcall sub_14000DD04(__int64 a1);
_QWORD *__fastcall sub_14000DD0C(__int64 a1);
__int64 __fastcall sub_14000DD20(__int64 *a1);
_QWORD *__fastcall sub_14000DD5C(_QWORD **a1);
_QWORD *__fastcall sub_14000DDF0(__int64 *a1);
signed __int64 __fastcall sub_14000DEC4(__int64 *a1, signed __int64 a2);
signed __int64 __fastcall sub_14000DFCC(char **a1, __int64 *a2, int a3);
void sub_14000E048();
_BOOL8 __fastcall sub_14000E064(wchar_t *Source);
__int64 __fastcall sub_14000E0FC(const WCHAR *a1, DWORD a2);
__int64 __fastcall sub_14000E114(int a1);
_BOOL8 __fastcall sub_14000E1BC(const WCHAR *a1);
_BOOL8 __fastcall sub_14000E1C4(LPCWSTR lpFileName, char a2);
__int64 __fastcall sub_14000E1F8(int a1);
__int64 __fastcall sub_14000E268(int a1, int a2);
_BOOL8 __fastcall sub_14000E3D8(const WCHAR *a1);
__int64 __fastcall sub_14000E3F4(int csidl, wchar_t *Str); // idb
void __fastcall sub_14000E480(_QWORD *a1);
__int64 __fastcall sub_14000E510(__int64 a1);
void sub_14000E560();
_QWORD *sub_14000E570();
signed __int64 __fastcall sub_14000E5A0(__int64 a1, const WCHAR *a2, int a3, int a4);
signed __int64 __fastcall sub_14000E7F0(__int64 a1, const WCHAR *a2);
signed __int64 __fastcall sub_14000E930(__int64 a1, const WCHAR *a2, int a3);
char *__fastcall sub_14000E940(__int64 a1, const WCHAR *a2);
char *__fastcall sub_14000EA30(__int64 a1, const WCHAR *a2);
signed __int64 __fastcall sub_14000EB30(__int64 a1, const WCHAR *a2, int a3);
__int64 __fastcall sub_14000EB40(__int64 a1, _BYTE *a2, int a3);
__int64 __fastcall sub_14000EBE6(); // weak
__int64 __fastcall sub_14000EC50(_QWORD *a1, _BYTE *a2);
__int64 __fastcall sub_14000EC90(_QWORD *a1, _BYTE *a2, int a3);
__int64 __fastcall sub_14000ECE0(_QWORD *a1, _BYTE *a2, DWORD a3);
size_t __fastcall sub_14000ED70(__int64 a1, _BYTE *a2, int a3);
CHAR *__fastcall sub_14000EEC0(UINT CodePage, LPCWSTR lpWideCharStr, int *a3);
void *__fastcall sub_14000EF74(__int64 a1);
__int64 __fastcall sub_14000EF84(); // weak
_DWORD *__fastcall sub_14000EF98(__int64 a1, int a2);
signed __int64 sub_14000EFDC();
__int64 __fastcall sub_14000F028(); // weak
void *__fastcall sub_14000F034(_BYTE *a1, _DWORD *a2);
void __fastcall sub_14000F168(_DWORD *a1, int a2);
__int64 __fastcall sub_14000F198(_DWORD *a1, const void *a2, _DWORD *a3);
void *__fastcall sub_140010634(_DWORD *a1, char *a2, unsigned int a3);
__int64 __fastcall sub_14001071C(); // weak
__int64 __fastcall sub_14001072C(); // weak
_DWORD *sub_140010740();
signed __int64 sub_140010778();
__int64 __fastcall sub_1400107C4(); // weak
void *__fastcall sub_140010860(__int64 a1, _DWORD *a2);
void __fastcall sub_14001093C(_DWORD *a1);
__int64 __fastcall sub_140010960(_DWORD *a1, __int64 a2);
char __fastcall sub_1400111CC(_DWORD *a1, __int64 a2, unsigned int a3);
void *__fastcall sub_1400112CC(void *a1, int a2, unsigned int a3);
void sub_1400112F0();
void sub_140011300();
void sub_1400113C0();
__int64 __fastcall sub_1400114E0(__int64 a1, unsigned int a2, int a3, int a4);
__int64 __fastcall sub_140011500(__int64 a1, unsigned int a2, int a3, unsigned int a4, int a5);
_DWORD *__fastcall sub_140011590(int a1);
char *__fastcall sub_1400115E0(int a1);
__int64 __fastcall sub_140011650(_DWORD *a1, int a2);
int __fastcall sub_1400116F8(LPVOID lpMem);
BOOL sub_14001174C();
BOOL sub_140011774();
char *__fastcall sub_140011794(__int64 a1);
SIZE_T __fastcall sub_14001182C(int a1, void (__fastcall *a2)(char *), __int64 a3);
void __fastcall sub_14001192C(signed int *a1, __int64 a2);
signed __int64 __fastcall sub_140011998(__int64 a1, _QWORD *a2);
signed __int64 __fastcall sub_1400119F8(signed int *a1, __int64 a2);
_QWORD *__fastcall sub_140011AC0(int a1, int a2, __int64 a3);
_QWORD *__fastcall sub_140011B48(__int64 a1, _QWORD *a2);
signed __int64 __fastcall sub_140011BCC(__int64 *a1);
void *__fastcall sub_140011D7C(__int64 *a1);
void __fastcall sub_140011DB8(__int64 a1);
void __fastcall sub_140011E44(__int64 a1, __int64 a2);
char *__fastcall sub_140011F4C(__int64 a1, unsigned int a2, unsigned int a3, int a4);
void __fastcall sub_1400120B8(__int64 a1);
void sub_140012180();
void __fastcall sub_1400121A0(__int64 a1);
signed __int64 __fastcall sub_1400121D8(__int64 a1, void (*a2)(void), _QWORD *a3);
__int64 __fastcall sub_1400121F8(); // weak
void __fastcall sub_140012208(volatile signed __int32 *a1, void (*a2)(void));
void __fastcall sub_1400122B4(_QWORD *a1, int a2, int a3, __int64 a4);
signed __int64 __fastcall sub_14001232C(__int64 a1, _QWORD *a2);
void __fastcall sub_140012398(__int64 a1);
BOOL __fastcall sub_1400123B8(__int64 **a1, __int64 a2);
signed __int64 __fastcall sub_140012400(__int64 a1, int a2);
signed __int64 __fastcall sub_140012444(_QWORD *a1, __int64 a2);
__int64 (__fastcall *sub_140012460())();
signed __int64 __fastcall sub_14001249C(__int64 a1, signed __int64 a2, int a3, signed __int64 *a4, __int64 *a5);
signed __int64 __fastcall sub_140012578(signed __int64 a1, __int64 a2, int a3, signed __int64 *a4, __int64 *a5);
__int64 __fastcall sub_140012658(); // weak
BOOL __fastcall sub_140012660(__int64 a1);
__int64 __fastcall sub_1400126D0(void *Src, __int64 a2, int a3);
BOOL sub_1400127D0();
BOOL sub_140012810();
signed __int64 __fastcall sub_140012840(LPVOID *a1, const wchar_t *a2);
__int64 sub_140012930();
__int64 __fastcall sub_140012980(LPVOID *a1, int a2);
void __fastcall sub_140012A60(LPVOID *a1, const wchar_t *a2);
BOOL __fastcall sub_140012AD0(void *a1);
BOOL __fastcall sub_140012B00(LPVOID *a1);
void *sub_140012B50();
__int64 __fastcall sub_140012BC0(const wchar_t *a1);
_BOOL8 __fastcall sub_140012C30(wchar_t *a1, wchar_t *a2);
signed __int64 sub_140012C90();
__int64 __fastcall sub_140012CC0(int a1);
__int64 sub_140012D10();
__int64 sub_140012D40();
__int64 sub_140012D70();
signed __int64 __fastcall sub_140012DA0(unsigned __int64 a1);
__int64 __fastcall sub_140012E10(int a1);
__int64 __fastcall sub_140012E40(int a1, int a2);
__int64 __fastcall sub_140012F20(int a1);
signed __int64 __fastcall sub_140012F60(int a1);
__int64 __fastcall sub_140012F90(_DWORD *a1, _DWORD *a2, int a3);
__int64 __fastcall sub_140013010(int a1);
_BYTE *__fastcall sub_140013050(char *a1, __int64 a2);
BOOL sub_140013360();
signed __int64 __fastcall sub_140013430(__int64 a1, int *a2, __int64 a3, int a4);
signed __int64 __fastcall sub_140013530(unsigned __int8 **a1, int a2);
signed __int64 __fastcall sub_140014CE0(__int64 a1, _QWORD *a2);
signed __int64 __fastcall sub_140014F20(_QWORD *a1);
signed __int64 __fastcall sub_140014F80(__int64 a1, char *a2, _DWORD *a3);
signed __int64 __fastcall sub_140015010(_QWORD *a1, signed int a2, _BYTE *a3, int a4);
signed __int64 __fastcall sub_140015100(_QWORD *a1, _BYTE *a2, int a3);
signed __int64 __fastcall sub_140015110(__int64 a1, signed int a2);
signed __int64 __fastcall sub_1400151E0(__int64 a1);
signed __int64 __fastcall sub_140015260(__int64 a1, unsigned __int8 *a2, unsigned int a3);
signed __int64 __fastcall sub_140015310(__int64 a1);
__int64 __fastcall sub_140015480(unsigned int *a1, unsigned __int8 *a2, unsigned int a3);
signed __int64 __fastcall sub_1400154F0(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_1400155F0(int a1, char *a2, unsigned int a3);
__int64 __fastcall sub_140015600(unsigned int a1, unsigned __int8 *a2, unsigned int a3);
__int64 __fastcall sub_140015990(unsigned int a1, int a2, __int64 a3);
__int64 __fastcall sub_140015B30(int a1, char *a2, unsigned int a3);
signed __int64 __fastcall sub_140015E90(unsigned int a1, unsigned __int8 *a2, unsigned int a3);
signed __int64 __fastcall sub_140016170(unsigned int a1, unsigned int a2, __int64 a3);
signed __int64 __fastcall sub_140016240(int a1, unsigned __int16 *a2, __int64 a3, _QWORD *a4, unsigned int *a5, char *a6);
signed __int64 __fastcall sub_1400166A0(__int64 *a1, int a2);
void *__fastcall sub_140016B80(__int64 a1, int a2, int a3);
__int64 __fastcall sub_140016B90(); // weak
_WORD *__fastcall sub_140016B9C(_WORD *a1, signed __int64 a2);
_WORD *__fastcall sub_140016BCC(_WORD *a1, unsigned __int64 a2);
__int64 __fastcall sub_140016C40(signed __int64 *a1);
void __fastcall sub_140016CA8(char *a1, signed __int64 a2, int *a3, char *a4);
signed __int64 __fastcall sub_140017030(__int64 a1, signed __int64 *a2);
__int64 __fastcall sub_14001717C(__int64 a1, _QWORD *a2);
BOOL __fastcall sub_140017338(HANDLE *a1);
void sub_1400173EC();
_QWORD *__fastcall sub_140017434(__int64 a1, __int64 a2);
void __fastcall Callback(PVOID a1, char a2);
_BYTE *__fastcall sub_1400175C0(LPCWSTR lpWideCharStr);
int __fastcall sub_1400176A0(LPCSTR lpMultiByteStr, int a2);
WCHAR *__fastcall sub_140017740(LPCSTR lpMultiByteStr);
int __fastcall sub_1400177E0(LPCSTR lpMultiByteStr, int a2);
_WORD *__fastcall sub_140017890(LPCSTR lpMultiByteStr);
_BYTE *__fastcall sub_140017960(LPCWSTR lpWideCharStr);
// void *__cdecl malloc(size_t Size);
// HANDLE __stdcall HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
// BOOL __stdcall HeapDestroy(HANDLE hHeap);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// LPWSTR __stdcall GetCommandLineW();
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// BOOL __stdcall TerminateThread(HANDLE hThread, DWORD dwExitCode);
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// void __stdcall Sleep(DWORD dwMilliseconds);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetCurrentProcessId();
// DWORD __stdcall GetCurrentThreadId();
// DWORD __stdcall GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// BOOL __stdcall PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// DWORD __stdcall GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
// BOOL __stdcall SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue);
// HANDLE __stdcall GetCurrentProcess();
// BOOL __stdcall DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// BOOL __stdcall CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize);
// BOOL __stdcall CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// BOOL __stdcall GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode);
// PRUNTIME_FUNCTION __stdcall RtlLookupFunctionEntry(DWORD64 ControlPc, PDWORD64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable);
// PEXCEPTION_ROUTINE __stdcall RtlVirtualUnwind(DWORD HandlerType, DWORD64 ImageBase, DWORD64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PDWORD64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers);
// ULONG __stdcall RemoveVectoredExceptionHandler(PVOID Handle);
// PVOID __stdcall AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler);
// SIZE_T __stdcall HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// BOOL __stdcall CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// BOOL __stdcall SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes);
// DWORD __stdcall GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer);
// BOOL __stdcall DeleteFileW(LPCWSTR lpFileName);
// DWORD __stdcall GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer);
// BOOL __stdcall SetCurrentDirectoryW(LPCWSTR lpPathName);
// HANDLE __stdcall CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// BOOL __stdcall TlsFree(DWORD dwTlsIndex);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
// DWORD __stdcall TlsAlloc();
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// DWORD __stdcall GetLastError();
// void __stdcall SetLastError(DWORD dwErrCode);
// BOOL __stdcall UnregisterWait(HANDLE WaitHandle);
// HANDLE __stdcall GetCurrentThread();
// BOOL __stdcall RegisterWaitForSingleObject(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags);
// BOOL __stdcall ShellExecuteExW(SHELLEXECUTEINFOW *pExecInfo);
// HRESULT __stdcall SHGetFolderLocation(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPITEMIDLIST *ppidl);
// BOOL __stdcall SHGetPathFromIDListW(LPCITEMIDLIST pidl, LPWSTR pszPath);
// MMRESULT __stdcall timeBeginPeriod(UINT uPeriod);
// HRESULT __stdcall CoInitialize(LPVOID pvReserved);
// void __stdcall CoTaskMemFree(LPVOID pv);
// LPWSTR __stdcall CharUpperW(LPWSTR lpsz);
// LPWSTR __stdcall CharLowerW(LPWSTR lpsz);
// int __stdcall MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
// LRESULT __stdcall DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// LONG_PTR __stdcall GetWindowLongPtrW(HWND hWnd, int nIndex);
// int __stdcall GetWindowTextLengthW(HWND hWnd);
// int __stdcall GetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount);
// BOOL __stdcall EnableWindow(HWND hWnd, BOOL bEnable);
// BOOL __stdcall DestroyWindow(HWND hWnd);
// BOOL __stdcall UnregisterClassW(LPCWSTR lpClassName, HINSTANCE hInstance);
// HICON __stdcall LoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName);
// HCURSOR __stdcall LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName);
// ATOM __stdcall RegisterClassExW(const WNDCLASSEXW *);
// BOOL __stdcall IsWindowEnabled(HWND hWnd);
// int __stdcall GetSystemMetrics(int nIndex);
// HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// LONG_PTR __stdcall SetWindowLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong);
// LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// HWND __stdcall SetFocus(HWND hWnd);
// HACCEL __stdcall CreateAcceleratorTableW(LPACCEL paccel, int cAccel);
// BOOL __stdcall SetForegroundWindow(HWND hWnd);
// BOOL __stdcall BringWindowToTop(HWND hWnd);
// BOOL __stdcall GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// int __stdcall TranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
// BOOL __stdcall TranslateMessage(const MSG *lpMsg);
// LRESULT __stdcall DispatchMessageW(const MSG *lpMsg);
// BOOL __stdcall DestroyAcceleratorTable(HACCEL hAccel);
// BOOL __stdcall PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// HWND __stdcall GetForegroundWindow();
// DWORD __stdcall GetWindowThreadProcessId(HWND hWnd, LPDWORD lpdwProcessId);
// BOOL __stdcall IsWindowVisible(HWND hWnd);
// BOOL __stdcall EnumWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam);
// BOOL __stdcall SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags);
// HGDIOBJ __stdcall GetStockObject(int i);
// BOOL __stdcall InitCommonControlsEx(const INITCOMMONCONTROLSEX *picce);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_140001250; // weak
_UNKNOWN loc_14000776A; // weak
_UNKNOWN loc_1400087E1; // weak
_UNKNOWN loc_140008AA9; // weak
_UNKNOWN loc_140008D5E; // weak
_UNKNOWN loc_140009280; // weak
_UNKNOWN loc_140009421; // weak
_UNKNOWN loc_1400095C3; // weak
_UNKNOWN loc_140009762; // weak
_UNKNOWN loc_1400098FF; // weak
_UNKNOWN loc_140009A8F; // weak
_UNKNOWN loc_140009FC1; // weak
_UNKNOWN loc_14000A161; // weak
_UNKNOWN loc_14000A300; // weak
_UNKNOWN loc_14000A4A0; // weak
_UNKNOWN loc_14000A641; // weak
_UNKNOWN loc_14000A7E3; // weak
_UNKNOWN loc_14000A982; // weak
_UNKNOWN loc_14000AB1F; // weak
_UNKNOWN loc_14000ACAF; // weak
_UNKNOWN loc_14000B1E1; // weak
_UNKNOWN loc_14000B381; // weak
_UNKNOWN loc_140011307; // weak
_UNKNOWN loc_1400113C7; // weak
_UNKNOWN loc_140014D29; // weak
_UNKNOWN loc_140015677; // weak
_UNKNOWN loc_1400178E0; // weak
wchar_t word_14001968C[2] = { 0u, 0u }; // idb
wchar_t word_140019690 = 32u; // idb
__int128 xmmword_1400196F0 = 16i64; // weak
_QWORD qword_140019760[202] =
{
  3221225477i64,
  5368813728i64,
  3221225612i64,
  5368813776i64,
  2147483651i64,
  5368813824i64,
  2147483650i64,
  5368813880i64,
  3221225613i64,
  5368813936i64,
  3221225614i64,
  5368814000i64,
  3221225615i64,
  5368814072i64,
  3221225616i64,
  5368814144i64,
  3221225617i64,
  5368814224i64,
  3221225618i64,
  5368814320i64,
  3221225619i64,
  5368814416i64,
  3221225501i64,
  5368814512i64,
  3221225478i64,
  5368814552i64,
  3221225620i64,
  5368814592i64,
  3221225621i64,
  5368814632i64,
  3221225510i64,
  5368814672i64,
  3221225509i64,
  5368814768i64,
  3221225622i64,
  5368814904i64,
  2147483652i64,
  5368814952i64,
  3221225725i64,
  5368814992i64,
  27303579554283593i64,
  9007628758351980i64,
  31244190572937325i64,
  27303210187817074i64,
  32370056119910499i64,
  115i64,
  27303562374676545i64,
  31244143323775097i64,
  32370051825664117i64,
  27866538097049632i64,
  28429402151125093i64,
  100i64,
  32932993188560964i64,
  32088581143461991i64,
  28429462280470560i64,
  31244203458232417i64,
  9007697478156393i64,
  27866439312801906i64,
  429503348840i64,
  27303566669054029i64,
  30962689826685036i64,
  28147635116572773i64,
  9007615874170977i64,
  28429397856026721i64,
  7536755i64,
  0i64,
  31244194867904580i64,
  30399714103722098i64,
  31244186278035488i64,
  30962698417340513i64,
  31244203454169191i64,
  9007697478156393i64,
  32088581144051823i64,
  429503938657i64,
  29555379367641156i64,
  30962724186423411i64,
  9007718952206368i64,
  31244212047773818i64,
  30399735574036512i64,
  29555370777182319i64,
  31525390671872110i64,
  32651569751720047i64,
  41i64,
  33777431004184649i64,
  9007697477435489i64,
  27303549489381478i64,
  28992395054481524i64,
  29555349303328813i64,
  32088284791570542i64,
  30399800003461221i64,
  116i64,
  0i64,
  27303579554283593i64,
  9007628758351980i64,
  27303549489381478i64,
  28992395054481524i64,
  29555349303328813i64,
  31243859861438574i64,
  27303562373824624i64,
  30962724186423412i64,
  0i64,
  0i64,
  27303549489381446i64,
  28992395054481524i64,
  29555349303328813i64,
  31243859861438574i64,
  28710937257377910i64,
  9007710363123820i64,
  31525712794288168i64,
  30962681237078127i64,
  31244220633186420i64,
  28429462280798240i64,
  176101261409i64,
  0i64,
  27303549489381446i64,
  28992395054481524i64,
  29555349303328813i64,
  32369759768281198i64,
  30118247716159604i64,
  28429479461191712i64,
  31244186278035570i64,
  32088624088481911i64,
  28147970125135904i64,
  30399735578886245i64,
  7798895i64,
  0i64,
  27303549489381446i64,
  28992395054481524i64,
  29555349303328813i64,
  32932709721702510i64,
  32088581143265390i64,
  33495998977015910i64,
  33777430999597088i64,
  28429445101453424i64,
  32651234744991854i64,
  32369759767953519i64,
  30399761347575917i64,
  41i64,
  28429436511322185i64,
  9007663117566055i64,
  32651591226884201i64,
  32651522507866226i64,
  472453677161i64,
  31244190572937293i64,
  31525334838476914i64,
  9007633053188193i64,
  31244212048625765i64,
  114i64,
  29555379367641156i64,
  30962724186423411i64,
  9007718952206368i64,
  31244212047773818i64,
  32i64,
  28429470871191625i64,
  9007688887631975i64,
  32088581144445039i64,
  33495998977015910i64,
  0i64,
  28429397857402949i64,
  31244173394051184i64,
  27303519419629678i64,
  28429436510797934i64,
  28429462276145266i64,
  30962737072111732i64,
  32932709720653925i64,
  31244194868297838i64,
  33214184698019959i64,
  28429475166027873i64,
  0i64,
  0i64,
  28429397857402949i64,
  31244173394051184i64,
  27303519419629678i64,
  28429436510797934i64,
  32088645563318386i64,
  9007628758089833i64,
  27866160140583028i64,
  29555370778034287i64,
  9007633054105710i64,
  28429470870667361i64,
  31244194863382642i64,
  31244147619594350i64,
  30962698417340526i64,
  30399718397902965i64,
  33777430999072869i64,
  32651578341392483i64,
  472453677161i64,
  33214498230894672i64,
  28992356399972457i64,
  29555010000126053i64,
  32088645568757870i64,
  29555370777313397i64,
  7209071i64,
  28992395054481491i64,
  32369759767298156i64,
  9007680297697396i64,
  31525614010892404i64,
  0i64,
  27866439313784915i64,
  33214523995324523i64,
  30399735578886245i64,
  7798895i64
}; // idb
_UNKNOWN unk_140019E64; // weak
char a0123456789abcd[18] = "0123456789abcdefK"; // weak
_UNKNOWN unk_14001A6C0; // weak
__int16 word_14001A740[20] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15, 0 }; // idb
_DWORD dword_14001A980[2060] =
{
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918000,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117,
  0,
  421212481,
  842424962,
  724390851,
  1684849924,
  2105013317,
  1448781702,
  1329698503,
  3369699848,
  3519200073,
  4210026634,
  3824474571,
  2897563404,
  3048111693,
  2659397006,
  2274893007,
  1254232657,
  1406739216,
  2029285587,
  1643069842,
  783210325,
  934667796,
  479770071,
  92505238,
  2182846553,
  2600511768,
  2955803355,
  2838940570,
  3866582365,
  4285295644,
  3561045983,
  3445231262,
  2508465314,
  2359236067,
  2813478432,
  3198777185,
  4058571174,
  3908292839,
  3286139684,
  3670389349,
  1566420650,
  1145479147,
  1869335592,
  1987116393,
  959540142,
  539646703,
  185010476,
  303839341,
  3745920755,
  3327985586,
  3983561841,
  4100678960,
  3140154359,
  2721170102,
  2300350837,
  2416418868,
  396344571,
  243568058,
  631889529,
  1018359608,
  1945336319,
  1793607870,
  1103436669,
  1490954812,
  4034481925,
  3915546180,
  3259968903,
  3679722694,
  2484439553,
  2366552896,
  2787371139,
  3208174018,
  950060301,
  565965900,
  177645455,
  328046286,
  1556873225,
  1171730760,
  1861902987,
  2011255754,
  3132841300,
  2745199637,
  2290958294,
  2442530455,
  3738671184,
  3352078609,
  3974232786,
  4126854035,
  1919080284,
  1803150877,
  1079293406,
  1498383519,
  370020952,
  253043481,
  607678682,
  1025720731,
  1711106983,
  2095471334,
  1472923941,
  1322268772,
  26324643,
  411738082,
  866634785,
  717028704,
  2904875439,
  3024081134,
  2668790573,
  2248782444,
  3376948395,
  3495106026,
  4219356713,
  3798300520,
  792689142,
  908347575,
  487136116,
  68299317,
  1263779058,
  1380486579,
  2036719216,
  1618931505,
  3890672638,
  4278043327,
  3587215740,
  3435896893,
  2206873338,
  2593195963,
  2981909624,
  2829542713,
  998479947,
  580430090,
  162921161,
  279890824,
  1609522511,
  1190423566,
  1842954189,
  1958874764,
  4082766403,
  3930137346,
  3245109441,
  3631694208,
  2536953671,
  2385372678,
  2768287173,
  3155920004,
  1900120602,
  1750776667,
  1131931800,
  1517083097,
  355290910,
  204897887,
  656092572,
  1040194781,
  3113746450,
  2692952403,
  2343461520,
  2461357009,
  3723805974,
  3304059991,
  4022511508,
  4141455061,
  2919742697,
  3072101800,
  2620513899,
  2234183466,
  3396041197,
  3547351212,
  4166851439,
  3779471918,
  1725839073,
  2143618976,
  1424512099,
  1307796770,
  45282277,
  464110244,
  813994343,
  698327078,
  3838160568,
  4259225593,
  3606301754,
  3488152955,
  2158586812,
  2578602749,
  2996767038,
  2877569151,
  740041904,
  889656817,
  506086962,
  120682355,
  1215357364,
  1366020341,
  2051441462,
  1667084919,
  3422213966,
  3538019855,
  4190942668,
  3772220557,
  2945847882,
  3062702859,
  2644537544,
  2226864521,
  52649286,
  439905287,
  823476164,
  672009861,
  1733269570,
  2119477507,
  1434057408,
  1281543041,
  2167981343,
  2552493150,
  3004082077,
  2853541596,
  3847487515,
  4233048410,
  3613549209,
  3464057816,
  1239502615,
  1358593622,
  2077699477,
  1657543892,
  764250643,
  882293586,
  532408465,
  111204816,
  1585378284,
  1197851309,
  1816695150,
  1968414767,
  974272232,
  587794345,
  136598634,
  289367339,
  2527558116,
  2411481253,
  2760973158,
  3179948583,
  4073438432,
  3956313505,
  3237863010,
  3655790371,
  347922877,
  229101820,
  646611775,
  1066513022,
  1892689081,
  1774917112,
  1122387515,
  1543337850,
  3697634229,
  3313392372,
  3998419255,
  4148705398,
  3087642289,
  2702352368,
  2319436851,
  2468674930,
  0,
  29518391,
  59036782,
  38190681,
  118073564,
  114017003,
  76381362,
  89069189,
  236147128,
  265370511,
  228034006,
  206958561,
  152762724,
  148411219,
  178138378,
  190596925,
  472294256,
  501532999,
  530741022,
  509615401,
  456068012,
  451764635,
  413917122,
  426358261,
  305525448,
  334993663,
  296822438,
  275991697,
  356276756,
  352202787,
  381193850,
  393929805,
  944588512,
  965684439,
  1003065998,
  973863097,
  1061482044,
  1049003019,
  1019230802,
  1023561829,
  912136024,
  933002607,
  903529270,
  874031361,
  827834244,
  815125939,
  852716522,
  856752605,
  611050896,
  631869351,
  669987326,
  640506825,
  593644876,
  580921211,
  551983394,
  556069653,
  712553512,
  733666847,
  704405574,
  675154545,
  762387700,
  749958851,
  787859610,
  792175277,
  1889177024,
  1901651959,
  1931368878,
  1927033753,
  2006131996,
  1985040171,
  1947726194,
  1976933189,
  2122964088,
  2135668303,
  2098006038,
  2093965857,
  2038461604,
  2017599123,
  2047123658,
  2076625661,
  1824272048,
  1836991623,
  1866005214,
  1861914857,
  1807058540,
  1786244187,
  1748062722,
  1777547317,
  1655668488,
  1668093247,
  1630251878,
  1625932113,
  1705433044,
  1684323811,
  1713505210,
  1742760333,
  1222101792,
  1226154263,
  1263738702,
  1251046777,
  1339974652,
  1310460363,
  1281013650,
  1301863845,
  1187289752,
  1191637167,
  1161842422,
  1149379777,
  1103966788,
  1074747507,
  1112139306,
  1133218845,
  1425107024,
  1429406311,
  1467333694,
  1454888457,
  1408811148,
  1379576507,
  1350309090,
  1371438805,
  1524775400,
  1528845279,
  1499917702,
  1487177649,
  1575719220,
  1546255107,
  1584350554,
  1605185389,
  3778354048,
  3774312887,
  3803303918,
  3816007129,
  3862737756,
  3892238699,
  3854067506,
  3833203973,
  4012263992,
  4007927823,
  3970080342,
  3982554209,
  3895452388,
  3924658387,
  3953866378,
  3932773565,
  4245928176,
  4241609415,
  4271336606,
  4283762345,
  4196012076,
  4225268251,
  4187931714,
  4166823541,
  4076923208,
  4072833919,
  4035198246,
  4047918865,
  4094247316,
  4123732899,
  4153251322,
  4132437965,
  3648544096,
  3636082519,
  3673983246,
  3678331705,
  3732010428,
  3753090955,
  3723829714,
  3694611429,
  3614117080,
  3601426159,
  3572488374,
  3576541825,
  3496125444,
  3516976691,
  3555094634,
  3525581405,
  3311336976,
  3298595879,
  3336186494,
  3340255305,
  3260503756,
  3281337595,
  3251864226,
  3222399125,
  3410866088,
  3398419871,
  3368647622,
  3372945905,
  3427010420,
  3448139075,
  3485520666,
  3456284973,
  2444203584,
  2423127159,
  2452308526,
  2481530905,
  2527477404,
  2539934891,
  2502093554,
  2497740997,
  2679949304,
  2659102159,
  2620920726,
  2650438049,
  2562027300,
  2574714131,
  2603727690,
  2599670141,
  2374579504,
  2353749767,
  2383274334,
  2412743529,
  2323684844,
  2336421851,
  2298759554,
  2294686645,
  2207933576,
  2186809023,
  2149495014,
  2178734801,
  2224278612,
  2236720739,
  2266437690,
  2262135309,
  2850214048,
  2820717207,
  2858812622,
  2879680249,
  2934667388,
  2938704459,
  2909776914,
  2897069605,
  2817622296,
  2788420399,
  2759153014,
  2780249921,
  2700618180,
  2704950259,
  2742877610,
  2730399645,
  3049550800,
  3020298727,
  3057690558,
  3078802825,
  2999835404,
  3004150075,
  2974355298,
  2961925461,
  3151438440,
  3121956959,
  3092510214,
  3113327665,
  3168701108,
  3172786307,
  3210370778,
  3197646061,
  0,
  3099354981,
  2852767883,
  313896942,
  2405603159,
  937357362,
  627793884,
  2648127673,
  3316918511,
  2097696650,
  1874714724,
  3607201537,
  1255587768,
  4067088605,
  3772741427,
  1482887254,
  1343838111,
  3903140090,
  4195393300,
  1118632049,
  3749429448,
  1741137837,
  1970407491,
  3452858150,
  2511175536,
  756094997,
  1067759611,
  2266550430,
  449832999,
  2725482306,
  2965774508,
  142231497,
  2687676222,
  412010587,
  171665333,
  2995192016,
  793786473,
  2548850444,
  2237264098,
  1038456711,
  1703315409,
  3711623348,
  3482275674,
  1999841343,
  3940814982,
  1381529571,
  1089329165,
  4166106984,
  4029413537,
  1217896388,
  1512189994,
  3802027855,
  2135519222,
  3354724499,
  3577784189,
  1845280792,
  899665998,
  2367928107,
  2677414085,
  657096608,
  3137160985,
  37822588,
  284462994,
  2823350519,
  2601801789,
  598228824,
  824021174,
  2309093331,
  343330666,
  2898962447,
  3195996129,
  113467524,
  1587572946,
  3860600759,
  4104763481,
  1276501820,
  3519211397,
  1769898208,
  2076913422,
  3279374443,
  3406630818,
  1941006535,
  1627703081,
  3652755532,
  1148164341,
  4241751952,
  3999682686,
  1457141531,
  247015245,
  3053797416,
  2763059142,
  470583459,
  2178658330,
  963106687,
  735213713,
  2473467892,
  992409347,
  2207944806,
  2435792776,
  697522413,
  3024379988,
  217581361,
  508405983,
  2800865210,
  4271038444,
  1177467017,
  1419450215,
  3962007554,
  1911572667,
  3377213406,
  3690561584,
  1665525589,
  1799331996,
  3548628985,
  3241568279,
  2039091058,
  3831314379,
  1558270126,
  1314193216,
  4142438437,
  2928380019,
  372764438,
  75645176,
  3158189981,
  568925988,
  2572515393,
  2346768303,
  861712586,
  3982079547,
  1441124702,
  1196457648,
  4293663189,
  1648042348,
  3666298377,
  3358779879,
  1888390786,
  686661332,
  2421291441,
  2196002399,
  978858298,
  2811169155,
  523464422,
  226935048,
  3040519789,
  3175145892,
  100435649,
  390670639,
  2952089162,
  841119475,
  2325614998,
  2553003640,
  546822429,
  2029308235,
  3225988654,
  3539796416,
  1782671013,
  4153826844,
  1328167289,
  1570739863,
  3844338162,
  1298864389,
  4124540512,
  3882013070,
  1608431339,
  3255406162,
  2058742071,
  1744848601,
  3501990332,
  2296328682,
  811816591,
  584513889,
  2590678532,
  129869501,
  3204563416,
  2914283062,
  352848211,
  494030490,
  2781751807,
  3078325777,
  264757620,
  2450577869,
  715964072,
  941166918,
  2158327331,
  3636881013,
  1618608400,
  1926213374,
  3396585883,
  1470427426,
  4011365959,
  4255988137,
  1158766284,
  1984818694,
  3471935843,
  3695453837,
  1693991400,
  4180638033,
  1100160564,
  1395044826,
  3952793279,
  3019491049,
  189112716,
  435162722,
  2706139399,
  1016811966,
  2217162459,
  2526189877,
  774831696,
  643086745,
  2666061564,
  2354934034,
  887166583,
  2838900430,
  294275499,
  54519365,
  3145957664,
  3823145334,
  1532818963,
  1240029693,
  4048895640,
  1820460577,
  3560857924,
  3331051178,
  2117577167,
  3598663992,
  1858283101,
  2088143283,
  3301633750,
  1495127663,
  3785470218,
  4078182116,
  1269332353,
  332098007,
  2876706482,
  3116540252,
  25085497,
  2628386432,
  605395429,
  916469259,
  2384220526,
  2254837415,
  1054503362,
  745528876,
  2496903497,
  151290352,
  2981684885,
  2735556987,
  464596510,
  1137851976,
  4218313005,
  3923506883,
  1365741990,
  3434129695,
  1946996346,
  1723425172,
  3724871409,
  0,
  2519730039,
  744558318,
  3125873049,
  432303367,
  2415159920,
  900031465,
  2744476830,
  847829774,
  2763578489,
  518641120,
  2295976599,
  726447625,
  3179065726,
  120436967,
  2434645904,
  1678817053,
  4062228586,
  1215412723,
  3728850564,
  2111101466,
  3957644653,
  1370871028,
  3347436419,
  1452829715,
  3232263012,
  2063164157,
  3972621706,
  1331429652,
  3647735395,
  1664946170,
  4111272077,
  3357568571,
  1578133836,
  3829489877,
  1920034722,
  3521381180,
  1205077067,
  4253355474,
  1807026853,
  4205360437,
  1821946434,
  3603545051,
  1090108588,
  3815561266,
  1969020741,
  3473790684,
  1497223595,
  2888882470,
  973135441,
  2152847304,
  375509183,
  3052712993,
  600093526,
  2576726735,
  262520248,
  2662859304,
  143131999,
  3000569030,
  619252657,
  2273079087,
  290220120,
  2870829505,
  1026385590,
  2420235382,
  108124929,
  3156267672,
  705746415,
  2307240305,
  532002310,
  2783231903,
  869578984,
  2731083640,
  888733711,
  2393377174,
  412618465,
  3138218623,
  759000328,
  2540463249,
  22832102,
  4098976619,
  1650551836,
  3627050373,
  1308648178,
  3985966700,
  2074411291,
  3253995650,
  1472466933,
  3336155237,
  1357494034,
  3937975947,
  2089335292,
  3743276386,
  1227741717,
  4085044108,
  1699534075,
  1482797645,
  3461461306,
  1946205347,
  3794844628,
  1101389642,
  3616921661,
  1841615268,
  4227126995,
  1793681731,
  4242107956,
  1183344557,
  3501744346,
  1932330052,
  3843883827,
  1598818986,
  3380350429,
  1014039888,
  2856387111,
  269487038,
  2250247369,
  632645719,
  3011866400,
  164914873,
  2682544590,
  251256414,
  2563365161,
  580440240,
  3030964167,
  389919577,
  2165158958,
  995933623,
  2909584064,
  545503469,
  3065233306,
  216184323,
  2597499252,
  961009130,
  2943865501,
  354867972,
  2199313523,
  302736355,
  2218484884,
  1047162125,
  2824497786,
  198119140,
  2650737043,
  665714698,
  2979923837,
  1150488560,
  3533899911,
  1760690462,
  4274128489,
  1566008055,
  3412551040,
  1899392025,
  3875957614,
  1981535486,
  3760968585,
  1518000656,
  3427458407,
  1876933113,
  4193238670,
  1136572183,
  3582898272,
  3903051478,
  2123616673,
  3301103672,
  1391648591,
  4050107345,
  1733803174,
  3708204351,
  1261875784,
  3660254680,
  1276840623,
  4132045622,
  1618609217,
  3287245023,
  1440704424,
  4019088945,
  2042521926,
  2360566219,
  444819132,
  2698145573,
  920807506,
  2507607244,
  54987707,
  3105227298,
  791020885,
  3191585477,
  671858098,
  2455417899,
  74101596,
  2818561986,
  835702965,
  2342443308,
  497999451,
  2965529755,
  653419500,
  2627955317,
  177433858,
  2835745180,
  1060507371,
  2238121842,
  324468741,
  2185936789,
  343587042,
  2922099067,
  941340172,
  2609828498,
  230610405,
  3085950076,
  568318731,
  3570586502,
  1122161905,
  4172537192,
  1854134815,
  3440819841,
  1529264630,
  3782717551,
  2001188632,
  3864660104,
  1885999103,
  3392865894,
  1544225041,
  4288570767,
  1773036280,
  3556731745,
  1171221526,
  2028079776,
  4006743511,
  1417872462,
  3266511673,
  1629906855,
  4145438928,
  1296525641,
  3682037310,
  1248514478,
  3696940761,
  1712054080,
  4030453815,
  1403960489,
  3315514334,
  2144318023,
  3925849392,
  485670333,
  2328017610,
  814986067,
  2795746340,
  87478458,
  2466699213,
  693624404,
  3211254051,
  779773619,
  3091882436,
  35350621,
  2485874474,
  935201716,
  2710441155,
  467600730,
  2381251117,
  0,
  1093737241,
  2187474482,
  3277008171,
  80047204,
  1173649277,
  2259114582,
  3348513103,
  143317448,
  1237041873,
  2330521594,
  3420058851,
  206550444,
  1300147893,
  2385347486,
  3474757767,
  1360183882,
  270784851,
  3547395192,
  2453794657,
  1440198190,
  350663991,
  3619002396,
  2525266693,
  1503140738,
  413728923,
  3690606000,
  2597009065,
  1566406630,
  476867839,
  3745464788,
  2651740877,
  2720302229,
  3809845132,
  541504167,
  1635232190,
  2799823089,
  3889230824,
  612622019,
  1706214874,
  2863553885,
  3953083972,
  684485487,
  1778217078,
  2926260537,
  4015663648,
  738789131,
  1832393746,
  4080420575,
  2986827206,
  1901359341,
  811953140,
  4159908539,
  3066180002,
  1972444297,
  882902928,
  4223442711,
  3129836558,
  2044635429,
  955232828,
  4286182259,
  3192449130,
  2098971969,
  1009442392,
  89094640,
  1149133545,
  2267893698,
  3323745499,
  25826708,
  1086000781,
  2213028774,
  3269015743,
  231055416,
  1291107105,
  2410124810,
  3465973011,
  151047260,
  1211225925,
  2338519662,
  3394494839,
  1415429050,
  359440547,
  3594489224,
  2534315665,
  1352194014,
  296340679,
  3539657196,
  2479618805,
  1557619314,
  501643627,
  3736425536,
  2676248409,
  1477578262,
  421729551,
  3664787492,
  2604737341,
  2808872293,
  3864716924,
  621398871,
  1681444942,
  2746126593,
  3802106392,
  567060275,
  1627241514,
  2950767789,
  4006625204,
  763564703,
  1823607174,
  2871281865,
  3927266256,
  692485883,
  1752655330,
  4135141167,
  3074958390,
  1947928861,
  891949572,
  4072428363,
  3012380754,
  1893623161,
  837779040,
  4277397223,
  3217227262,
  2089930965,
  1033948108,
  4197878403,
  3137835418,
  2018819249,
  962963368,
  1268286267,
  178886690,
  3388650761,
  2295049744,
  1331556191,
  242021446,
  3443513709,
  2349777524,
  1125276403,
  35865066,
  3245370561,
  2151774168,
  1205286551,
  115748238,
  3316973733,
  2223250364,
  445268337,
  1539005032,
  2565371715,
  3654904922,
  508505365,
  1602106892,
  2620201767,
  3709599806,
  302028985,
  1395753888,
  2422386315,
  3511924114,
  382072029,
  1475669956,
  2494022383,
  3583433206,
  3921414062,
  2827820215,
  1809723804,
  720317061,
  3984157642,
  2890428627,
  1864064504,
  774522593,
  3778469478,
  2684863871,
  1666508884,
  577106765,
  3857953282,
  2764220699,
  1737589808,
  648060713,
  3098461668,
  4188004093,
  986510294,
  2080237775,
  3161172352,
  4250579609,
  1040818098,
  2134410411,
  2955156524,
  4044687157,
  843459102,
  1937191175,
  3034673224,
  4124076881,
  914572922,
  2008178019,
  1322777291,
  266789330,
  3434466553,
  2374293472,
  1242732207,
  186879414,
  3362824349,
  2302786436,
  1180508931,
  124532762,
  3292468529,
  2232290856,
  1117278055,
  61428862,
  3237640533,
  2177589836,
  533018753,
  1593058200,
  2644971187,
  3700823466,
  453006565,
  1513181180,
  2573361879,
  3629349326,
  391110985,
  1451162192,
  2502809467,
  3558657122,
  327847213,
  1388025396,
  2447948575,
  3503923206,
  3975380574,
  2915198279,
  1855015020,
  799036277,
  3895857722,
  2835810595,
  1783899144,
  728055569,
  3833178006,
  2773007503,
  1713082788,
  657099453,
  3770469362,
  2710425835,
  1658781120,
  602924761,
  3185687572,
  4241532685,
  1065585190,
  2125631807,
  3106197616,
  4162177897,
  994502210,
  2054683995,
  3043714524,
  4099571397,
  923358190,
  1983400183,
  2980972984,
  4036956833,
  869023626,
  1929192595,
  0,
  929743361,
  1859421187,
  1505641986,
  3701999879,
  3955411718,
  2994507012,
  2232831749,
  3092321038,
  2403062031,
  3599079181,
  3790558476,
  1694046729,
  1402198024,
  170761738,
  1028086795,
  1889740316,
  1204413469,
  511156767,
  689791006,
  2886414107,
  2606886170,
  3269438232,
  4122306841,
  3371316498,
  4288214803,
  2787553553,
  2437706512,
  341457941,
  590413332,
  2056173590,
  1306819095,
  3762703672,
  3610021689,
  2391984443,
  3120040762,
  1022247999,
  193234494,
  1379582012,
  1699742269,
  1477926454,
  1870502967,
  918805045,
  27858996,
  2227132209,
  3017119024,
  3932934962,
  3707834675,
  2430954276,
  2811210021,
  4264685351,
  3378195750,
  1280139811,
  2066194466,
  580511264,
  368256033,
  682915882,
  534690347,
  1180761129,
  1896496680,
  4095504685,
  3279336236,
  2596861230,
  2913089327,
  3230505584,
  4159133809,
  2925076083,
  2570312818,
  472224631,
  726618486,
  1928402804,
  1167840629,
  2027719038,
  1337346943,
  369626493,
  560123772,
  2759098489,
  2468233848,
  3399484538,
  4257924731,
  2955852908,
  2269412973,
  3740940399,
  3918592622,
  1820767595,
  1542223722,
  38941032,
  892924777,
  142585698,
  1058368867,
  1722493793,
  1371662688,
  3570902629,
  3820840036,
  3120767590,
  2372526183,
  550229832,
  396432713,
  1310675787,
  2037748042,
  4234403407,
  3406371918,
  2461489740,
  2782763085,
  2560279622,
  2951743047,
  4132323397,
  3240395332,
  1144180033,
  1935150912,
  719735106,
  495749955,
  1349054804,
  1728197461,
  1052538199,
  165066582,
  2361456723,
  3148495442,
  3792993360,
  3581853265,
  3896107610,
  3746766939,
  2263705177,
  2978456664,
  881978205,
  66791772,
  1514499934,
  1831841119,
  2149266913,
  3077699552,
  4006588898,
  3651498979,
  1555250406,
  1809448679,
  845658341,
  84769508,
  944383727,
  253813998,
  1453236972,
  1643405549,
  3840028648,
  3548966377,
  2318838763,
  3176950250,
  4038595581,
  3352482300,
  2657916926,
  2835764735,
  739252986,
  461035771,
  1120182009,
  1974361336,
  1223229683,
  2139341554,
  641565936,
  290932465,
  2487290356,
  2737556469,
  4204105207,
  3456061430,
  1616738521,
  1463270104,
  243924186,
  971194075,
  3170202078,
  2342499295,
  3525440989,
  3846911964,
  3624692695,
  4016482774,
  3067670484,
  2175938005,
  77882064,
  869179601,
  1785784019,
  1561994450,
  285105861,
  664050884,
  2116737734,
  1228937415,
  3428210626,
  4215051715,
  2726482881,
  2515014080,
  2830061003,
  2680524746,
  3330001352,
  4044426185,
  1946633420,
  1131251405,
  450085071,
  767099598,
  1083617169,
  2013031824,
  776088466,
  422111635,
  2621351574,
  2874434711,
  4075430549,
  3313557652,
  4173839519,
  3484253854,
  2517842076,
  2709125789,
  611300760,
  319125401,
  1253781915,
  2110911386,
  808814989,
  123685772,
  1591807374,
  1770770319,
  3969745034,
  3690414731,
  2185823369,
  3039020680,
  2288294531,
  3205388418,
  3870301824,
  3520781441,
  1422693252,
  1671844229,
  974657415,
  225629574,
  2698044073,
  2545557672,
  3456394922,
  4184777899,
  2088299438,
  1259481519,
  313290669,
  633777580,
  411169191,
  803943334,
  1985312164,
  1094694821,
  3291084960,
  4081269409,
  2868739235,
  2643967650,
  3497247925,
  3877177012,
  3198632118,
  2311946935,
  215731634,
  1001459635,
  1645169073,
  1432718256,
  1747113915,
  1598559674,
  116806584,
  832344505,
  3028999868,
  2212502717,
  3663616703,
  3979647166,
  0,
  1701297336,
  2345142698,
  4004492562,
  1469538959,
  854646327,
  3697240869,
  3107510173,
  4012422341,
  2320435325,
  1692450159,
  25625047,
  3099579978,
  3721947890,
  863494112,
  1443914584,
  2673285456,
  4197492200,
  345968890,
  1912122434,
  3368057823,
  2913453927,
  1124627061,
  644861645,
  1887415701,
  353898797,
  4223116351,
  2664437895,
  669568794,
  1116697506,
  2887829168,
  3376904712,
  1051669152,
  1539870232,
  3043441418,
  3489695666,
  1765298223,
  207613079,
  3807402373,
  2274878781,
  3515319909,
  3034594013,
  1515163599,
  1059599223,
  2249254122,
  3816249426,
  232320320,
  1757368824,
  2717395952,
  3298793288,
  707797594,
  1331142370,
  4134488447,
  2466837959,
  2108113109,
  415300717,
  1322295093,
  733422477,
  3306722975,
  2692688423,
  424148410,
  2082488578,
  2458907664,
  4159195304,
  1029182619,
  1480566819,
  3062897969,
  3556221321,
  1791981076,
  262720172,
  3775365054,
  2220933894,
  3530596446,
  3071745254,
  1505274356,
  1021252940,
  2246558417,
  3766517353,
  238013307,
  1799911363,
  2718895563,
  3345527155,
  700908641,
  1285601497,
  4120407876,
  2432685052,
  2119198446,
  456645206,
  1294448910,
  675284406,
  3337597092,
  2743602204,
  447798145,
  2144823097,
  2440614443,
  4095700627,
  66528827,
  1720752771,
  2285842321,
  3982005033,
  1415595188,
  822605836,
  3752348958,
  3134189990,
  3974075134,
  2310549062,
  1729600340,
  40904684,
  3142119537,
  3727641801,
  813758939,
  1441219939,
  2627747691,
  4190602195,
  392705729,
  1913621113,
  3409403364,
  2924536156,
  1090475086,
  630778102,
  1938328494,
  384775958,
  4164977156,
  2636594876,
  606071073,
  1098405273,
  2950160523,
  3400555571,
  1001806317,
  1590814037,
  2961068103,
  3575246079,
  1814117218,
  155617242,
  3890819784,
  2190380656,
  3567185192,
  2985906576,
  1599530114,
  976312378,
  2198441895,
  3865981727,
  146900493,
  1839610549,
  2766225597,
  3246849029,
  791234839,
  1246688687,
  4084605490,
  2517737098,
  2025728920,
  500799264,
  1271526520,
  783173824,
  3221355986,
  2774942058,
  475961079,
  2033789519,
  2543230813,
  4075889637,
  85551949,
  1618925557,
  2396087015,
  3954630239,
  1385040322,
  938063226,
  3645243496,
  3156327632,
  3929137032,
  2404803376,
  1643763234,
  77490842,
  3181821191,
  3636527551,
  913224877,
  1393100821,
  2588832285,
  4280929957,
  294026167,
  1960953615,
  3453554834,
  2831068202,
  1175525688,
  594978176,
  1969669848,
  268532320,
  4272869234,
  2613670858,
  586261591,
  1201019119,
  2839129597,
  3428716869,
  116280694,
  1669984718,
  2368095452,
  3896637540,
  1366896633,
  874419009,
  3669042771,
  3218512619,
  3922131379,
  2359379211,
  1645146137,
  124341409,
  3193019196,
  3677759364,
  899256982,
  1358835246,
  2579059750,
  4242466974,
  309419404,
  1997988148,
  3459135145,
  2873723409,
  1172717315,
  545358779,
  1989271779,
  334912603,
  4250528073,
  2554222065,
  554074732,
  1147223764,
  2865662918,
  3483973502,
  943816662,
  1562821486,
  3012130428,
  3605973700,
  1876303193,
  179413473,
  3827176691,
  2172233803,
  3614034707,
  2987292587,
  1554105017,
  969309697,
  2164173212,
  3852014884,
  188129334,
  1850809486,
  2803263110,
  3262241342,
  752774956,
  1236915092,
  4034987017,
  2514925745,
  2068385187,
  506376475,
  1212076611,
  760835835,
  3287735273,
  2794547025,
  531214540,
  2060323956,
  2489432422,
  4043703774,
  1718511904,
  1702125932,
  841888032,
  1126185006,
  1920561263,
  1952999273,
  960049440,
  808594741,
  1293955889,
  543912545,
  1701602369,
  8306
}; // idb
_UNKNOWN unk_14001C9B0; // weak
_UNKNOWN unk_14001C9F0; // weak
_UNKNOWN unk_14001CA30; // weak
_UNKNOWN unk_14001CA70; // weak
_UNKNOWN unk_14001CB1B; // weak
int dword_14001F001 = 4294967295; // weak
int dword_14001F016 = 0; // weak
_UNKNOWN unk_14001F020; // weak
_UNKNOWN unk_14001F026; // weak
_UNKNOWN unk_14001F080; // weak
_UNKNOWN unk_14001F084; // weak
__int64 qword_14001F110 = 1i64; // weak
LPCWSTR lpClassName = L"InputRequester"; // idb
int dword_14001F120 = 4294967295; // weak
_UNKNOWN unk_14001F128; // weak
int dword_14001F138 = 4096; // weak
_UNKNOWN unk_14001F140; // weak
DWORD dwTlsIndex = 4294967295u; // idb
HANDLE hHeap = NULL; // idb
HINSTANCE hModule = NULL; // idb
UINT uExitCode = 0u; // idb
__int64 qword_1400204DC = 0i64; // weak
__int64 qword_1400204E4 = 0i64; // weak
__int64 qword_1400204F4 = 0i64; // weak
__int64 qword_1400204FC = 0i64; // weak
__int64 qword_140020504 = 0i64; // weak
__int64 qword_14002050C = 0i64; // weak
__int64 qword_140020524 = 0i64; // weak
__int64 qword_14002053C = 0i64; // weak
__int64 qword_140020544 = 0i64; // weak
__int64 qword_14002054C = 0i64; // weak
__int64 qword_140020554 = 0i64; // weak
__int64 qword_14002055C = 0i64; // weak
__int64 qword_140020564 = 0i64; // weak
__int64 qword_140020574 = 0i64; // weak
__int64 qword_140020584 = 0i64; // weak
__int64 qword_14002058C = 0i64; // weak
__int64 qword_140020594 = 0i64; // weak
__int64 qword_14002059C = 0i64; // weak
__int64 qword_1400205AC = 0i64; // weak
__int64 qword_1400205BC = 0i64; // weak
LPVOID lpMem = NULL; // idb
__int64 qword_1400205EC = 0i64; // weak
LPVOID qword_1400205F4 = NULL; // idb
__int64 qword_1400205FC = ; // weak
LPVOID qword_140020604; // idb
__int64 qword_14002060C; // weak
__int64 qword_140020614; // weak
__int64 qword_140020630; // weak
int dword_140020638; // weak
WPARAM wParam; // idb
int dword_140020648; // weak
int dword_14002064C; // weak
__int64 qword_140020650; // weak
HWND hWnd; // idb
__int64 qword_140020660; // weak
HWND qword_140020668; // idb
int dword_140020670; // weak
__int64 qword_140020678; // weak
__int64 qword_140020680; // weak
__int64 (*qword_140020690)(void); // weak
int dword_140020698; // weak
PVOID Handle; // idb
__int64 qword_1400206A8; // weak
__int64 qword_1400206B0; // weak
int dword_1400206C0; // weak
_DWORD dword_1400206D0[640]; // idb
__int64 qword_1400210D0; // weak
SIZE_T dwBytes; // idb
DWORD dword_1400210E0; // idb
_UNKNOWN unk_1400210E8; // weak
__int64 qword_1400210F0; // weak
struct _RTL_CRITICAL_SECTION stru_1400210F8; // idb
_UNKNOWN unk_140021120; // weak
struct _RTL_CRITICAL_SECTION stru_140021128; // idb
_UNKNOWN unk_140021150; // weak
_UNKNOWN unk_140021154; // weak
__int64 (__fastcall *qword_140021158)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_140021160)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_140021168)(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_140021170)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_140021178)(_QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_140021180)(_QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_140021188)(_QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_140021190)(_QWORD); // weak
__int64 (__fastcall *qword_140021198)(_QWORD); // weak
__int64 (__fastcall *qword_1400211A0)(_QWORD); // weak
int dword_1400211A8; // weak
__int64 qword_1400211B0; // weak
struct _RTL_CRITICAL_SECTION stru_1400211B8; // idb
DWORD dword_1400211E0; // idb
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
__int64 qword_140021250; // weak
__int64 qword_140021260; // weak
struct _RTL_CRITICAL_SECTION stru_140021270; // idb
int dword_1400212A0; // weak
__int64 qword_1400212B0; // weak
__int64 qword_1400212C0; // weak
__int64 qword_1400212D0; // weak
__int64 qword_1400212D8; // weak
__int64 qword_1400212E0; // weak
__int64 qword_1400212E8; // weak
__int64 qword_1400212F0; // weak
__int64 qword_1400212F8; // weak
__int64 qword_140021300; // weak
__int64 qword_140021308; // weak
__int64 qword_140021310; // weak
__int64 qword_140021318; // weak
__int64 qword_140021320; // weak
__int64 qword_140021328; // weak
__int64 qword_140021330; // weak
__int64 qword_140021338; // weak
__int64 qword_140021340; // weak
__int64 qword_140021348; // weak
__int64 qword_140021350; // weak
__int64 qword_140021360; // weak
__int64 qword_140021390; // weak
HANDLE qword_1400213A0; // idb


//----- (0000000140001000) ----------------------------------------------------
#error "14000124B: call analysis failed (funcsize=110)"

//----- (0000000140001272) ----------------------------------------------------
BOOL sub_140001272()
{
  sub_140007108();
  sub_14000CE00();
  sub_14000E048();
  sub_14000E560();
  sub_14001174C();
  return sub_14000D0C0();
}

//----- (0000000140001299) ----------------------------------------------------
#error "140001744: positive sp value has been found (funcsize=269)"

//----- (000000014000174A) ----------------------------------------------------
#error "140001E68: positive sp value has been found (funcsize=489)"

//----- (0000000140001E6C) ----------------------------------------------------
#error "1400021FC: positive sp value has been found (funcsize=257)"

//----- (00000001400021FF) ----------------------------------------------------
__int64 sub_1400021FF()
{
  __int64 v0; // ST68_8
  int v1; // eax
  __int64 v2; // rax
  __int64 v3; // ST48_8
  HANDLE v4; // ST50_8
  DWORD v5; // ST58_4
  HMODULE v6; // rax
  HMODULE v7; // ST98_8
  const wchar_t *v8; // ST68_8
  int v9; // eax
  const wchar_t *v10; // rcx
  __int16 *v11; // ST68_8
  int v12; // eax
  const wchar_t *v13; // rcx
  wchar_t *v14; // ST68_8
  int v15; // eax
  const wchar_t *v16; // rcx
  int v17; // ST68_4
  int v18; // eax
  __int64 v19; // rax
  __int64 v20; // ST50_8
  int v21; // ST58_4
  wchar_t *v22; // ST68_8
  int v23; // eax
  const wchar_t *v24; // rcx
  __int64 v25; // rax
  __int64 v26; // ST50_8
  int v27; // ST58_4
  int v28; // eax
  __int64 v29; // rax
  int v30; // eax
  int v31; // ST68_4
  int v32; // edx
  wchar_t *v33; // ST68_8
  wchar_t *v34; // rax
  int v35; // ST68_4
  int v36; // eax
  __int64 v37; // ST68_8
  wchar_t *v39; // [rsp+68h] [rbp-38h]
  __int16 *v40; // [rsp+70h] [rbp-30h]
  wchar_t *v41; // [rsp+78h] [rbp-28h]
  wchar_t *v42; // [rsp+80h] [rbp-20h]
  wchar_t *v43; // [rsp+88h] [rbp-18h]

  v43 = 0i64;
  v42 = 0i64;
  v41 = 0i64;
  v40 = 0i64;
  v39 = 0i64;
  sub_140012B50();
  v0 = sub_140012930();
  sub_140012930();
  v1 = sub_140012930();
  sub_14000C0B4(v1);
  v2 = sub_140012D40();
  v6 = LoadLibraryExW((LPCWSTR)(v2 + v3), v4, v5);
  sub_140006B38(v0);
  v7 = v6;
  EnumResourceTypesW(v6, (ENUMRESTYPEPROCW)sub_1400029DD, 0i64);
  FreeLibrary(v7);
  if ( sub_14000DD04((__int64)qword_140020604) <= 0 )
    JUMPOUT(&loc_140001250);
  sub_14000DD0C((__int64)qword_140020604);
  while ( sub_14000DD20((__int64 *)qword_140020604) )
  {
    v8 = *(const wchar_t **)(qword_14002060C + 16);
    v9 = sub_140012930();
    v10 = v8;
    LODWORD(v8) = v9;
    sub_140012BC0(v10);
    sub_140012980((LPVOID *)&v39, (int)v8);
    if ( sub_140007CB0((__int64)v39) <= 10 )
    {
      v14 = v39;
      v15 = sub_140012930();
      v16 = v14;
      LODWORD(v14) = v15;
      sub_140012BC0(v16);
      sub_140012980((LPVOID *)&v41, (int)v14);
    }
    else
    {
      v11 = v40;
      v12 = sub_140012930();
      v13 = (const wchar_t *)v11;
      LODWORD(v11) = v12;
      sub_140012BC0(v13);
      sub_140012BC0(v39);
      sub_140012980((LPVOID *)&v40, (int)v11);
    }
  }
  sub_14000DD5C((_QWORD **)qword_140020604);
  v17 = sub_140012930();
  sub_140012930();
  sub_140012930();
  sub_140012930();
  sub_140012930();
  v18 = sub_140012930();
  sub_140007CD0(v40, v18);
  sub_140012D40();
  sub_1400112F0();
  v19 = sub_140012D40();
  sub_140007DB0(v19 + v20, v21);
  sub_140012980((LPVOID *)&v42, v17);
  v22 = v42;
  v23 = sub_140012930();
  v24 = v22;
  LODWORD(v22) = v23;
  sub_140012BC0(v24);
  sub_140012980((LPVOID *)&v43, (int)v22);
  LODWORD(v22) = sub_140012930();
  sub_140012930();
  sub_140012930();
  sub_140012930();
  sub_1400112F0();
  v25 = sub_140012D40();
  sub_140007DB0(v25 + v26, v27);
  sub_140012980((LPVOID *)&v42, (int)v22);
  LODWORD(v22) = sub_140012930();
  v28 = sub_140012930();
  sub_140007E40((__int64)v42, 10, v28);
  sub_140012980((LPVOID *)&v42, (int)v22);
  if ( !sub_140012C30(v42, v41) )
    JUMPOUT(&loc_140001250);
  v29 = (__int64)sub_14000C2AC();
  if ( v29 )
  {
    sub_140012930();
    v30 = sub_140012930();
    sub_14000C340(0, v30);
    sub_140012C90();
    v32 = v31;
    v33 = v43;
    v34 = (wchar_t *)sub_140012CC0(v32);
    v29 = sub_140012C30(v33, v34);
    if ( v29 )
    {
      qword_140020554 = 1i64;
      v35 = sub_140012930();
      v36 = sub_140012930();
      sub_14000C340(1, v36);
      v29 = sub_140012980((LPVOID *)&qword_1400204F4, v35);
    }
  }
  v37 = v29;
  sub_140012AD0(v39);
  sub_140012AD0(v41);
  sub_140012AD0(v40);
  sub_140012AD0(v43);
  sub_140012AD0(v42);
  return v37;
}
// 1400029DD: using guessed type __int64 __fastcall sub_1400029DD();
// 1400204F4: using guessed type __int64 qword_1400204F4;
// 140020554: using guessed type __int64 qword_140020554;
// 14002060C: using guessed type __int64 qword_14002060C;

//----- (00000001400026D0) ----------------------------------------------------
__int64 __fastcall sub_1400026D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  int v5; // ST38_4
  int v6; // eax
  __int64 v7; // rcx
  __int64 v8; // ST38_8
  int v9; // eax
  __int64 v10; // rcx
  __int64 v11; // ST30_8
  int v12; // eax
  __int64 v13; // rdx
  int v14; // er8
  int v15; // er9
  int v16; // ST38_4
  const wchar_t *v17; // ST38_8
  int v18; // eax
  const wchar_t *v19; // rcx
  const wchar_t *v20; // ST38_8
  int v21; // eax
  const wchar_t *v22; // rcx
  const wchar_t *v23; // ST38_8
  __int64 v24; // ST38_8
  int v26; // [rsp-30h] [rbp-50h]
  int v27; // [rsp-28h] [rbp-48h]
  int v28; // [rsp-20h] [rbp-40h]
  int v29; // [rsp-18h] [rbp-38h]
  int v30; // [rsp-10h] [rbp-30h]
  __int128 v31; // [rsp+0h] [rbp-20h]
  __int64 v32; // [rsp+10h] [rbp-10h]
  __int64 v33; // [rsp+28h] [rbp+8h]

  v33 = a1;
  v32 = 0i64;
  v31 = 0ui64;
  sub_140012B50();
  sub_140006B38(a5);
  v5 = sub_140012930();
  v6 = sub_140012930();
  sub_14000C0B4(v6);
  sub_140012980((LPVOID *)&v31, v5);
  PathQuoteSpacesW((LPWSTR)v31);
  if ( v33 <= 0 )
  {
    v20 = (const wchar_t *)v31;
    v21 = sub_140012930();
    v22 = v20;
    v26 = v21;
    sub_140012BC0(v22);
  }
  else
  {
    v8 = v7;
    v9 = sub_140012930();
    v10 = v8;
    LODWORD(v8) = v9;
    v11 = v10;
    v12 = sub_140012930();
    sub_140003172(v11, v13, v14, v15, v12, v8, v27, v28, v29, v30);
    sub_140012980((LPVOID *)&v31 + 1, v16);
    v17 = (const wchar_t *)v31;
    v18 = sub_140012930();
    v19 = v17;
    v26 = v18;
    sub_140012BC0(v19);
    sub_140012BC0((const wchar_t *)&unk_14001F026);
    sub_140012BC0(*((const wchar_t **)&v31 + 1));
  }
  sub_140012980((LPVOID *)&v31 + 1, v26);
  v23 = (const wchar_t *)*((_QWORD *)&v31 + 1);
  sub_140012930();
  sub_140012BC0(v23);
  v24 = (__int64)v23 + sub_140012D10();
  sub_140012AD0((void *)v31);
  sub_140012AD0(*((void **)&v31 + 1));
  return v24;
}

//----- (0000000140002868) ----------------------------------------------------
void __noreturn sub_140002868()
{
  int v0; // eax
  __int64 v1; // rax
  __int64 v2; // ST40_8
  LPCWSTR v3; // ST38_8
  UINT v4; // ST48_4
  __int64 v5; // ST58_8

  sub_140012B50();
  sub_140012930();
  sub_140012930();
  sub_140012BC0(0i64);
  sub_140012930();
  v0 = sub_140012930();
  sub_14000D030(v0);
  sub_140012C90();
  v1 = sub_140012D40();
  sub_14000B564(v3, (LPCWSTR)(v1 + v2), v4);
  sub_140006B38(v5);
  JUMPOUT(&loc_140001250);
}

//----- (0000000140002945) ----------------------------------------------------
void __fastcall __noreturn sub_140002945(__int64 a1)
{
  __int64 v1; // [rsp+18h] [rbp+8h]

  v1 = a1;
  sub_140012B50();
  sub_14000E1BC((const WCHAR *)qword_140020584);
  sub_14000E1BC((const WCHAR *)qword_140020564);
  sub_140004884();
  sub_14000E1BC((const WCHAR *)qword_140020524);
  RemoveDirectoryW((LPCWSTR)qword_1400204FC);
  RemoveDirectoryW((LPCWSTR)qword_140020594);
  *(_QWORD *)&uExitCode = v1;
  JUMPOUT(&loc_140001250);
}
// 1400204FC: using guessed type __int64 qword_1400204FC;
// 140020524: using guessed type __int64 qword_140020524;
// 140020564: using guessed type __int64 qword_140020564;
// 140020584: using guessed type __int64 qword_140020584;
// 140020594: using guessed type __int64 qword_140020594;

//----- (0000000140002A3C) ----------------------------------------------------
__int64 __fastcall sub_140002A3C(signed __int16 *a1)
{
  signed __int16 *v2; // [rsp+10h] [rbp+8h]

  v2 = a1;
  qword_140020574 = sub_14000D1C0(a1 + 3);
  qword_140020504 = sub_14000D1C0(v2 + 4);
  qword_14002053C = sub_14000D1C0(v2 + 5);
  qword_1400205AC = sub_14000D1C0(v2 + 6);
  qword_14002059C = sub_14000D1C0(v2 + 7);
  return 0i64;
}
// 140020504: using guessed type __int64 qword_140020504;
// 14002053C: using guessed type __int64 qword_14002053C;
// 140020574: using guessed type __int64 qword_140020574;
// 14002059C: using guessed type __int64 qword_14002059C;
// 1400205AC: using guessed type __int64 qword_1400205AC;

//----- (0000000140002AD7) ----------------------------------------------------
__int64 __fastcall HandlerRoutine(__int64 CtrlType)
{
  __int64 v2; // [rsp+48h] [rbp+8h]

  v2 = CtrlType;
  sub_140012B50();
  if ( !(_DWORD)v2
    || (signed int)v2 == 1i64
    || (signed int)v2 == 2i64
    || (signed int)v2 == 5i64
    || (signed int)v2 == 6i64 )
  {
    if ( sub_14000C3CC(qword_14002058C) )
    {
      if ( sub_14000C41C((HANDLE *)qword_14002058C) )
        sub_14000C484((HANDLE *)qword_14002058C);
      sub_14000C494((HANDLE *)qword_14002058C);
    }
    sub_140002945(0i64);
  }
  return 0i64;
}
// 14002058C: using guessed type __int64 qword_14002058C;

//----- (0000000140002BC3) ----------------------------------------------------
__int64 __fastcall sub_140002BC3(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  int v5; // ST58_4
  int v6; // eax
  __int64 v7; // rax
  __int64 v8; // ST40_8
  int v9; // ST48_4
  int v10; // ST58_4
  int v11; // eax
  __int64 v12; // rax
  __int64 v13; // ST40_8
  int v14; // ST48_4
  int v15; // ST58_4
  int v16; // eax
  int v17; // eax
  __int64 v18; // rax
  __int64 v19; // ST38_8
  wchar_t *v20; // ST30_8
  wchar_t *v21; // ST40_8
  char v22; // ST48_1
  int v23; // ST58_4
  int v24; // eax
  int v25; // eax
  __int64 v26; // rax
  __int64 v27; // ST40_8
  LPCWSTR v28; // ST38_8
  UINT v29; // ST48_4
  __int64 v30; // ST58_8
  const wchar_t *v31; // ST58_8
  __int64 v32; // ST58_8
  wchar_t *v34; // [rsp+58h] [rbp-30h]
  wchar_t *v35; // [rsp+60h] [rbp-28h]
  wchar_t *v36; // [rsp+68h] [rbp-20h]
  wchar_t *v37; // [rsp+70h] [rbp-18h]
  __int64 v38; // [rsp+78h] [rbp-10h]
  __int64 v39; // [rsp+90h] [rbp+8h]

  v39 = a1;
  v38 = 0i64;
  v37 = 0i64;
  v36 = 0i64;
  v35 = 0i64;
  v34 = 0i64;
  sub_140012B50();
  sub_140006B38(a5);
  if ( sub_14000D1C0((signed __int16 *)(v39 + 2)) == 1 )
  {
    v5 = sub_140012930();
    sub_140012930();
    sub_140012930();
    v6 = sub_140012930();
    sub_14000D1D0((char *)(v39 + 64), 40i64, v6);
    v7 = sub_140012D40();
    sub_140007EE0(v7 + v8, v9);
    sub_140012980((LPVOID *)&v34, v5);
    v10 = sub_140012930();
    sub_140012930();
    sub_140012930();
    v11 = sub_140012930();
    sub_14000D1D0((char *)(v39 + 300), 100i64, v11);
    v12 = sub_140012D40();
    sub_140007EE0(v12 + v13, v14);
    sub_140012980((LPVOID *)&v35, v10);
    v15 = sub_140012930();
    sub_140012930();
    sub_140012930();
    v16 = sub_140012930();
    sub_1400074D0(v35, 2, (const wchar_t *)qword_1400204DC, v16);
    sub_140012C90();
    sub_140012930();
    v17 = sub_140012930();
    sub_1400074D0(v35, 1, (const wchar_t *)qword_1400204DC, v17);
    sub_140012D40();
    v18 = sub_140012D40();
    sub_14000B748(v20, (wchar_t *)(v18 + v19), v21, v22);
    sub_140012980((LPVOID *)&v36, v15);
    if ( sub_140012C30(v36, 0i64) )
      sub_140002945(0i64);
    v23 = sub_140012930();
    sub_140012930();
    sub_140012930();
    v24 = sub_140012930();
    sub_140007EE0((__int64)v36, v24);
    sub_140012D40();
    sub_1400112F0();
    sub_140012980((LPVOID *)&v37, v23);
    if ( !sub_140012C30(v34, v37) )
    {
      sub_140012930();
      sub_140012930();
      v25 = sub_140012930();
      sub_1400074D0(v35, 3, (const wchar_t *)qword_1400204DC, v25);
      sub_140012C90();
      v26 = sub_140012D40();
      sub_14000B564(v28, (LPCWSTR)(v26 + v27), v29);
      sub_140006B38(v30);
      sub_140002945(0i64);
    }
  }
  v31 = v37;
  sub_140012930();
  sub_140012BC0(v31);
  v32 = (__int64)v31 + sub_140012D10();
  sub_140012AD0(v35);
  sub_140012AD0(v36);
  sub_140012AD0(v34);
  sub_140012AD0(v37);
  return v32;
}
// 1400204DC: using guessed type __int64 qword_1400204DC;

//----- (0000000140003017) ----------------------------------------------------
__int64 __fastcall sub_140003017(const wchar_t *a1, const wchar_t *a2)
{
  __int64 v2; // ST28_8
  __int128 v4; // [rsp+0h] [rbp-30h]
  _QWORD *v5; // [rsp+10h] [rbp-20h]
  __int64 v6; // [rsp+18h] [rbp-18h]
  __int64 v7; // [rsp+20h] [rbp-10h]
  const wchar_t *v8; // [rsp+40h] [rbp+10h]

  v8 = a2;
  v7 = 0i64;
  v6 = 0i64;
  v5 = 0i64;
  v4 = 0ui64;
  sub_140012A60((LPVOID *)&v4, a1);
  sub_140012A60((LPVOID *)&v4 + 1, v8);
  v5 = (_QWORD *)sub_14000E930(-1i64, (const WCHAR *)v4, 24);
  if ( v5 )
  {
    v6 = sub_14000EC50(v5, *((_BYTE **)&v4 + 1));
    sub_14000E480(v5);
  }
  if ( !sub_140007CB0(*((__int64 *)&v4 + 1)) )
    v6 = 1i64;
  v2 = v6;
  sub_140012AD0((void *)v4);
  sub_140012AD0(*((void **)&v4 + 1));
  return v2;
}

//----- (00000001400030F1) ----------------------------------------------------
__int64 __fastcall sub_1400030F1(const wchar_t *a1)
{
  __int64 v1; // ST28_8
  __int128 v3; // [rsp+0h] [rbp-20h]
  __int64 v4; // [rsp+10h] [rbp-10h]
  __int64 v5; // [rsp+18h] [rbp-8h]

  v5 = 0i64;
  v4 = 0i64;
  v3 = 0ui64;
  sub_140012A60((LPVOID *)&v3, a1);
  *((_QWORD *)&v3 + 1) = sub_14000EB30(-1i64, (const WCHAR *)v3, 0x20000);
  if ( *((_QWORD *)&v3 + 1) )
  {
    sub_14000E480(*((_QWORD **)&v3 + 1));
    v4 = 1i64;
  }
  v1 = v4;
  sub_140012AD0((void *)v3);
  return v1;
}

//----- (0000000140003172) ----------------------------------------------------
#error "140003489: positive sp value has been found (funcsize=221)"

//----- (000000014000348C) ----------------------------------------------------
void *__fastcall sub_14000348C(HMODULE a1, HRSRC a2)
{
  HGLOBAL v2; // ST40_8
  signed __int64 v3; // rax
  void *v4; // ST48_8
  HMODULE v6; // [rsp+18h] [rbp+8h]
  HRSRC v7; // [rsp+20h] [rbp+10h]

  v6 = a1;
  v7 = a2;
  sub_140012B50();
  v2 = LoadResource(v6, v7);
  LODWORD(v3) = SizeofResource(v6, v7);
  qword_1400204E4 = v3;
  v4 = sub_14000D130(v3);
  sub_14000D260(v2, v4, qword_1400204E4);
  FreeResource(v2);
  return v4;
}
// 1400204E4: using guessed type __int64 qword_1400204E4;

//----- (000000014000350F) ----------------------------------------------------
#error "140003C42: positive sp value has been found (funcsize=497)"

//----- (0000000140003C46) ----------------------------------------------------
__int64 __fastcall sub_140003C46(const wchar_t *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  int v5; // ST38_4
  int v6; // eax
  const wchar_t *v7; // ST38_8
  __int64 v8; // ST38_8
  __int128 v10; // [rsp+0h] [rbp-20h]
  __int128 v11; // [rsp+10h] [rbp-10h]
  const wchar_t *v12; // [rsp+28h] [rbp+8h]

  v12 = a1;
  v11 = 0ui64;
  v10 = 0ui64;
  sub_140012B50();
  sub_140006B38(a5);
  sub_140012A60((LPVOID *)&v10, v12);
  *((_QWORD *)&v10 + 1) = sub_14000D130(10000i64);
  GetShortPathNameW((LPCWSTR)v10, *((LPWSTR *)&v10 + 1), 0x2710u);
  v5 = sub_140012930();
  v6 = sub_140012930();
  sub_14000D1D0(*((char **)&v10 + 1), -1i64, v6);
  sub_140012980((LPVOID *)&v11, v5);
  sub_14000D110(*((void **)&v10 + 1));
  v7 = (const wchar_t *)v11;
  sub_140012930();
  sub_140012BC0(v7);
  v8 = (__int64)v7 + sub_140012D10();
  sub_140012AD0((void *)v10);
  sub_140012AD0((void *)v11);
  return v8;
}

//----- (0000000140003D59) ----------------------------------------------------
#error "140004026: positive sp value has been found (funcsize=213)"

//----- (0000000140004029) ----------------------------------------------------
signed __int64 __fastcall sub_140004029(__int64 a1, __int64 a2, void *a3)
{
  int v3; // ST38_4
  int v4; // eax
  void *v6; // [rsp+20h] [rbp+18h]

  v6 = a3;
  sub_140012B50();
  sub_14000DDF0((__int64 *)qword_140020604);
  v3 = sub_140012930();
  v4 = sub_140012930();
  sub_14000D150(v6, v4);
  sub_140012980((LPVOID *)(qword_14002060C + 16), v3);
  return 1i64;
}
// 14002060C: using guessed type __int64 qword_14002060C;

//----- (00000001400040B1) ----------------------------------------------------
LPVOID __fastcall sub_1400040B1(const wchar_t *a1)
{
  LPVOID v1; // ST28_8
  __int128 v3; // [rsp+0h] [rbp-30h]
  void *v4; // [rsp+10h] [rbp-20h]
  LPVOID v5; // [rsp+18h] [rbp-18h]
  __int64 v6; // [rsp+20h] [rbp-10h]
  __int64 v7; // [rsp+28h] [rbp-8h]
  const wchar_t *v8; // [rsp+38h] [rbp+8h]

  v8 = a1;
  v7 = 0i64;
  v6 = 0i64;
  v5 = 0i64;
  v4 = 0i64;
  v3 = 0ui64;
  sub_140012B50();
  sub_140012A60((LPVOID *)&v3, v8);
  *((_QWORD *)&v3 + 1) = FindResourceW((HMODULE)qword_14002054C, (LPCWSTR)v3, (LPCWSTR)0xA);
  if ( *((_QWORD *)&v3 + 1) )
  {
    v4 = sub_14000348C((HMODULE)qword_14002054C, *((HRSRC *)&v3 + 1));
    qword_1400204E4 = sub_140006A23(v4);
  }
  v5 = sub_14000D130(512i64);
  v6 = 512i64;
  v7 = sub_140013430((__int64)v5, (int *)&v6, (__int64)v4, qword_1400204E4);
  v1 = v5;
  sub_140012AD0((void *)v3);
  return v1;
}
// 1400204E4: using guessed type __int64 qword_1400204E4;
// 14002054C: using guessed type __int64 qword_14002054C;

//----- (000000014000418E) ----------------------------------------------------
__int64 __fastcall sub_14000418E(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  int v5; // ST80_4
  int v6; // eax
  __int64 v7; // rax
  __int64 v8; // ST30_8
  int v9; // ST38_4
  __int64 v11; // [rsp+18h] [rbp-50h]
  __int64 v12; // [rsp+58h] [rbp-10h]

  v12 = 0i64;
  sub_140012B50();
  sub_140006B38(a5);
  v5 = unk_14001F084;
  qword_14002050C = 5368836232i64;
  sub_14000D2A0(&v12, unk_14001F080);
  sub_14000D2A0((_DWORD *)&v12 + 1, v5);
  sub_140012930();
  sub_140012930();
  sub_140012930();
  v6 = sub_140012930();
  sub_1400114E0((__int64)&v12, 8u, 1, v6);
  v7 = sub_140012D40();
  sub_140007DB0(v7 + v8, v9);
  return v11 + sub_140012D10();
}
// 14002050C: using guessed type __int64 qword_14002050C;

//----- (00000001400042BC) ----------------------------------------------------
void __noreturn sub_1400042BC()
{
  int v0; // ST48_4
  __int64 v1; // rax
  __int64 v2; // ST30_8
  int v3; // ST38_4
  int v4; // ST48_4
  __int64 v5; // rax
  __int64 v6; // ST30_8
  int v7; // ST38_4
  __int64 v8; // ST48_8
  __int64 v9; // rax
  __int64 v10; // rdx
  __int64 v11; // r8
  __int64 v12; // r9
  int v13; // eax
  int v14; // ST48_4
  __int64 v15; // rax
  __int64 v16; // ST30_8
  int v17; // ST38_4
  int v18; // ST48_4
  __int64 v19; // rax
  __int64 v20; // ST30_8
  int v21; // ST38_4
  int v22; // ST48_4
  int v23; // ST48_4
  __int64 v24; // ST48_8
  const wchar_t *v25; // ST30_8
  __int64 v26; // rax
  __int64 v27; // ST30_8
  const wchar_t *v28; // ST38_8
  const wchar_t *v29; // ST48_8
  int v30; // eax
  const wchar_t *v31; // rcx
  int v32; // edx
  int v33; // er8
  int v34; // er9
  __int128 v35; // [rsp+48h] [rbp-30h]
  __int128 v36; // [rsp+58h] [rbp-20h]
  __int64 v37; // [rsp+68h] [rbp-10h]
  __int64 v38; // [rsp+70h] [rbp-8h]

  v38 = 0i64;
  v37 = 0i64;
  v36 = 0ui64;
  v35 = 0ui64;
  sub_140012B50();
  v0 = sub_140012930();
  sub_140012930();
  sub_140012930();
  sub_140012930();
  sub_1400112F0();
  v1 = sub_140012D40();
  sub_140007DB0(v1 + v2, v3);
  sub_140012980((LPVOID *)&v35, v0);
  v4 = sub_140012930();
  sub_140012930();
  sub_140012930();
  sub_140012930();
  sub_1400112F0();
  v5 = sub_140012D40();
  sub_140007DB0(v5 + v6, v7);
  sub_140012980((LPVOID *)&v35, v4);
  *((_QWORD *)&v35 + 1) = sub_1400040B1((const wchar_t *)v35);
  v8 = sub_140012930();
  v9 = sub_140012930();
  sub_140002BC3(*((__int64 *)&v35 + 1), v10, v11, v12, v9);
  sub_140006B38(v8);
  LODWORD(v8) = sub_140012930();
  v13 = sub_140012930();
  sub_14000BC84(qword_1400204F4, (const wchar_t *)&unk_14001F020, v13);
  sub_140012980((LPVOID *)&v36, v8);
  if ( !sub_140012C30((wchar_t *)v36, 0i64) )
  {
    v14 = sub_140012930();
    sub_140012930();
    sub_140012930();
    sub_140012930();
    sub_1400112F0();
    v15 = sub_140012D40();
    sub_140007DB0(v15 + v16, v17);
    sub_140012980((LPVOID *)&v36 + 1, v14);
    v18 = sub_140012930();
    sub_140012930();
    sub_140012930();
    sub_140012930();
    sub_1400112F0();
    v19 = sub_140012D40();
    sub_140007DB0(v19 + v20, v21);
    sub_140012980((LPVOID *)&v37, v18);
    v22 = sub_140012930();
    sub_140012930();
    sub_140005A1D(v37);
    sub_140012980((LPVOID *)&qword_14002055C, v22);
    v23 = sub_140012930();
    sub_140012930();
    sub_140005A1D(*((__int64 *)&v36 + 1));
    sub_140012980((LPVOID *)&v38, v23);
    PathAddBackslashW((LPWSTR)v36);
    v24 = sub_140012930();
    v25 = (const wchar_t *)v36;
    sub_140012930();
    sub_140012BC0(v25);
    sub_140012BC0((const wchar_t *)qword_14002055C);
    v26 = sub_140012D40();
    sub_140003017((const wchar_t *)(v26 + v27), v28);
    sub_140006B38(v24);
    v29 = (const wchar_t *)v36;
    v30 = sub_140012930();
    v31 = v29;
    LODWORD(v29) = v30;
    sub_140012BC0(v31);
    sub_140012980((LPVOID *)&qword_140020544, (int)v29);
    PathRemoveBackslashW((LPWSTR)qword_140020544);
    sub_140003D59(v35, v32, v33, v34);
  }
  JUMPOUT(&loc_140001250);
}
// 140005A1D: using guessed type __int64 __fastcall sub_140005A1D(__int64);
// 1400204F4: using guessed type __int64 qword_1400204F4;
// 140020544: using guessed type __int64 qword_140020544;
// 14002055C: using guessed type __int64 qword_14002055C;

//----- (000000014000475F) ----------------------------------------------------
__int64 __fastcall sub_14000475F(const wchar_t *a1, const wchar_t *a2, __int64 a3, __int64 a4, __int64 a5)
{
  int v5; // ST38_4
  int v6; // eax
  const wchar_t *v7; // ST38_8
  __int64 v8; // ST38_8
  __int128 v10; // [rsp+0h] [rbp-20h]
  __int128 v11; // [rsp+10h] [rbp-10h]
  const wchar_t *v12; // [rsp+28h] [rbp+8h]
  const wchar_t *v13; // [rsp+30h] [rbp+10h]

  v12 = a1;
  v13 = a2;
  v11 = 0ui64;
  v10 = 0ui64;
  sub_140012B50();
  sub_140006B38(a5);
  sub_140012A60((LPVOID *)&v10, v12);
  sub_140012A60((LPVOID *)&v10 + 1, v13);
  v5 = sub_140012930();
  v6 = sub_140012930();
  sub_140008160(2048, v6);
  sub_140012980((LPVOID *)&v11, v5);
  GetSystemDirectoryW((LPWSTR)v11, 0x800u);
  PathAddBackslashW((LPWSTR)v11);
  v7 = (const wchar_t *)v11;
  sub_140012930();
  sub_140012BC0(v7);
  v8 = (__int64)v7 + sub_140012D10();
  sub_140012AD0((void *)v10);
  sub_140012AD0(*((void **)&v10 + 1));
  sub_140012AD0((void *)v11);
  return v8;
}

//----- (0000000140004884) ----------------------------------------------------
signed __int64 sub_140004884()
{
  sub_140012B50();
  if ( qword_140020504 == 1 )
  {
    if ( sub_14000DD04((__int64)qword_1400205F4) > 0 )
    {
      sub_14000DD0C((__int64)qword_1400205F4);
      while ( sub_14000DD20((__int64 *)qword_1400205F4) )
        sub_14000E1BC(*(const WCHAR **)(qword_1400205FC + 16));
    }
    if ( sub_14000DD04((__int64)lpMem) > 0 )
    {
      sub_140009060((__int64 *)lpMem);
      sub_14000DD0C((__int64)lpMem);
      while ( sub_14000DD20((__int64 *)lpMem) )
        RemoveDirectoryW(*(LPCWSTR *)(qword_1400205EC + 20));
    }
  }
  return 1i64;
}
// 140020504: using guessed type __int64 qword_140020504;
// 1400205EC: using guessed type __int64 qword_1400205EC;
// 1400205FC: using guessed type __int64 qword_1400205FC;

//----- (0000000140004967) ----------------------------------------------------
__int64 __fastcall sub_140004967(__int64 a1, const wchar_t *a2, __int64 a3, __int64 a4, __int64 a5)
{
  int v5; // ST30_4
  int v6; // eax
  __int64 v7; // ST30_8
  int v8; // eax
  const wchar_t *v9; // rcx
  int v10; // ST30_4
  int v11; // eax
  int v12; // ST30_4
  int v13; // eax
  int v14; // ST30_4
  int v15; // eax
  int v16; // ST30_4
  int v17; // eax
  int v18; // ST30_4
  int v19; // eax
  int v20; // ST30_4
  int v21; // eax
  int v22; // ST30_4
  int v23; // eax
  int v24; // ST30_4
  int v25; // eax
  int v26; // ST30_4
  int v27; // eax
  int v28; // ST30_4
  int v29; // eax
  const wchar_t *v30; // ST38_8
  __int64 v31; // ST38_8
  void *v33; // [rsp+30h] [rbp-20h]
  wchar_t *v34; // [rsp+38h] [rbp-18h]
  __int64 v35; // [rsp+40h] [rbp-10h]
  __int64 v36; // [rsp+58h] [rbp+8h]
  const wchar_t *v37; // [rsp+60h] [rbp+10h]

  v36 = a1;
  v37 = a2;
  v35 = 0i64;
  v34 = 0i64;
  v33 = 0i64;
  sub_140012B50();
  sub_140006B38(a5);
  sub_140012A60(&v33, v37);
  if ( v36 )
  {
    switch ( v36 )
    {
      case 1i64:
        v7 = qword_140020594;
        v8 = sub_140012930();
        v9 = (const wchar_t *)v7;
        LODWORD(v7) = v8;
        sub_140012BC0(v9);
        sub_140012980((LPVOID *)&v34, v7);
        break;
      case 2i64:
        v10 = sub_140012930();
        v11 = sub_140012930();
        sub_14000E268(4, v11);
        sub_140012980((LPVOID *)&v34, v10);
        break;
      case 3i64:
        v12 = sub_140012930();
        v13 = sub_140012930();
        sub_14000E268(0, v13);
        sub_140012980((LPVOID *)&v34, v12);
        break;
      case 4i64:
        v14 = sub_140012930();
        v15 = sub_140012930();
        sub_14000E268(3, v15);
        sub_140012980((LPVOID *)&v34, v14);
        break;
      case 5i64:
        v16 = sub_140012930();
        v17 = sub_140012930();
        sub_14000E268(8, v17);
        sub_140012980((LPVOID *)&v34, v16);
        break;
      case 6i64:
        v18 = sub_140012930();
        v19 = sub_140012930();
        sub_14000E268(7, v19);
        sub_140012980((LPVOID *)&v34, v18);
        break;
      case 7i64:
        v20 = sub_140012930();
        v21 = sub_140012930();
        sub_14000E268(6, v21);
        sub_140012980((LPVOID *)&v34, v20);
        break;
      case 8i64:
        v22 = sub_140012930();
        v23 = sub_140012930();
        sub_14000E268(2, v23);
        sub_140012980((LPVOID *)&v34, v22);
        break;
      case 9i64:
        v24 = sub_140012930();
        v25 = sub_140012930();
        sub_14000E268(1, v25);
        sub_140012980((LPVOID *)&v34, v24);
        break;
      case 10i64:
        v26 = sub_140012930();
        v27 = sub_140012930();
        sub_14000BC84((__int64)v33, (const wchar_t *)&unk_14001F020, v27);
        sub_140012980((LPVOID *)&v34, v26);
        if ( sub_140012C30(v34, 0i64) )
          sub_140002945(0i64);
        sub_14000735C(1u);
        break;
      default:
        v28 = sub_140012930();
        v29 = sub_140012930();
        sub_14000E1F8(v29);
        sub_140012980((LPVOID *)&v34, v28);
        break;
    }
  }
  else
  {
    v5 = sub_140012930();
    v6 = sub_140012930();
    sub_14000E1F8(v6);
    sub_140012980((LPVOID *)&v34, v5);
  }
  v30 = v34;
  sub_140012930();
  sub_140012BC0(v30);
  v31 = (__int64)v30 + sub_140012D10();
  sub_140012AD0(v34);
  sub_140012AD0(v33);
  return v31;
}
// 140020594: using guessed type __int64 qword_140020594;

//----- (0000000140004E5F) ----------------------------------------------------
#error "14000562E: positive sp value has been found (funcsize=601)"

//----- (0000000140005631) ----------------------------------------------------
__int64 __fastcall sub_140005631(const wchar_t *a1)
{
  const wchar_t *v1; // ST28_8
  int v2; // eax
  const wchar_t *v3; // rcx
  __int64 v4; // rbp
  LPVOID v6[4]; // [rsp+0h] [rbp-20h]
  const wchar_t *v7; // [rsp+28h] [rbp+8h]

  v7 = a1;
  *(_OWORD *)v6 = 0ui64;
  sub_140012B50();
  sub_140012A60(v6, v7);
  if ( *sub_14000D54C(qword_140020614, (unsigned __int16 *)v6[0]) < 1 )
  {
    *sub_14000D54C(qword_140020614, (unsigned __int16 *)v6[0]) = 1i64;
    sub_14000DDF0((__int64 *)lpMem);
    v1 = (const wchar_t *)v6[0];
    v2 = sub_140012930();
    v3 = v1;
    LODWORD(v1) = v2;
    sub_140012BC0(v3);
    v4 = qword_1400205EC;
    sub_140012980((LPVOID *)(qword_1400205EC + 20), (int)v1);
    *(_DWORD *)(v4 + 16) = qword_1400205BC++;
  }
  sub_140012AD0(v6[0]);
  return 0i64;
}
// 1400205BC: using guessed type __int64 qword_1400205BC;
// 1400205EC: using guessed type __int64 qword_1400205EC;
// 140020614: using guessed type __int64 qword_140020614;

//----- (0000000140005711) ----------------------------------------------------
#error "140005A1A: positive sp value has been found (funcsize=203)"

//----- (0000000140005A1D) ----------------------------------------------------
#error "140005ACC: call analysis failed (funcsize=123)"

//----- (0000000140005BC5) ----------------------------------------------------
#error "1400067A2: call analysis failed (funcsize=826)"

//----- (000000014000688A) ----------------------------------------------------
__int64 __fastcall sub_14000688A(signed __int16 *a1)
{
  __int16 v1; // ST70_2
  int v2; // ST38_4
  int v3; // eax
  const wchar_t *v4; // ST38_8
  int v5; // eax
  const wchar_t *v6; // rcx
  int v8; // ST38_4
  __int64 v9; // ST30_8
  const wchar_t *v10; // ST28_8
  __int64 v11; // rax
  __int64 v12; // r8
  __int64 v13; // r9
  signed __int64 v15; // [rsp+0h] [rbp-30h]
  wchar_t *v16; // [rsp+10h] [rbp-20h]
  wchar_t *v17; // [rsp+18h] [rbp-18h]
  WCHAR *v18; // [rsp+20h] [rbp-10h]
  signed __int16 *v19; // [rsp+38h] [rbp+8h]

  v19 = a1;
  v18 = 0i64;
  v17 = 0i64;
  v16 = 0i64;
  sub_140012B50();
  qword_14002050C = 5368836272i64;
  v15 = 0i64;
  do
  {
    if ( v15 > 27 )
      break;
    v1 = *(char *)qword_14002050C++;
    v2 = sub_140012930();
    v3 = sub_140012930();
    sub_140007C80(-v1, v3);
    sub_140012980((LPVOID *)&v16, v2);
    v4 = v17;
    v5 = sub_140012930();
    v6 = v4;
    LODWORD(v4) = v5;
    sub_140012BC0(v6);
    sub_140012BC0(v16);
    sub_140012980((LPVOID *)&v17, (int)v4);
  }
  while ( !__OFADD__(1i64, v15++) );
  v8 = sub_140012930();
  v9 = sub_140012930();
  v10 = v17;
  v11 = sub_14000D1C0(v19);
  sub_140004967(v11, v10, v12, v13, v9);
  sub_140012980((LPVOID *)&v18, v8);
  sub_14000E3D8(v18);
  sub_140012AD0(v17);
  sub_140012AD0(v16);
  sub_140012AD0(v18);
  return 0i64;
}
// 14002050C: using guessed type __int64 qword_14002050C;

//----- (0000000140006A23) ----------------------------------------------------
SIZE_T __fastcall sub_140006A23(const void *a1)
{
  return sub_14000D0F0(a1);
}

//----- (0000000140006A40) ----------------------------------------------------
_BOOL8 __fastcall sub_140006A40(const wchar_t *a1, _BYTE *a2, __int64 a3)
{
  _BOOL8 v3; // rax
  _BOOL8 v4; // ST28_8
  wchar_t *v6; // [rsp+0h] [rbp-30h]
  _QWORD *v7; // [rsp+8h] [rbp-28h]
  __int64 v8; // [rsp+10h] [rbp-20h]
  _BOOL8 v9; // [rsp+18h] [rbp-18h]
  __int64 v10; // [rsp+20h] [rbp-10h]
  const wchar_t *v11; // [rsp+38h] [rbp+8h]
  _BYTE *v12; // [rsp+40h] [rbp+10h]
  __int64 v13; // [rsp+48h] [rbp+18h]

  v11 = a1;
  v12 = a2;
  v13 = a3;
  v10 = 0i64;
  v9 = 0i64;
  v8 = 0i64;
  v7 = 0i64;
  v6 = 0i64;
  sub_140012B50();
  sub_140012A60((LPVOID *)&v6, v11);
  v3 = qword_14002053C != 1 && sub_1400030F1(v6);
  if ( !v3 )
  {
    v7 = (_QWORD *)sub_14000E7F0(-1i64, v6);
    if ( v7 )
    {
      if ( v13 > 0 )
        v8 = sub_14000ECE0(v7, v12, v13);
      sub_14000E480(v7);
      v9 = v8 == v13;
    }
    v3 = v9;
  }
  v4 = v3;
  sub_140012AD0(v6);
  return v4;
}
// 14002053C: using guessed type __int64 qword_14002053C;

//----- (0000000140006B38) ----------------------------------------------------
void __fastcall __spoils<rdx,rcx,r8,r9,r10,r11,xmm4,xmm5> sub_140006B38(__int64 a1)
{
  __int64 v1; // ST30_8
  DWORD dwErrCode; // ST38_4

  v1 = a1;
  dwErrCode = GetLastError();
  *((_QWORD *)TlsGetValue(dwTlsIndex) + 2) = v1;
  SetLastError(dwErrCode);
}

//----- (0000000140007108) ----------------------------------------------------
void sub_140007108()
{
  __int64 v0; // rbx

  EnterCriticalSection(&CriticalSection);
  while ( qword_140020630 )
  {
    v0 = qword_140020630 + 16;
    CloseHandle(*(HANDLE *)(qword_140020630 + 16));
    sub_1400123B8((__int64 **)&qword_140020630, v0);
  }
  LeaveCriticalSection(&CriticalSection);
}
// 140020630: using guessed type __int64 qword_140020630;

//----- (0000000140007158) ----------------------------------------------------
void sub_140007158()
{
  InitializeCriticalSection(&CriticalSection);
}

//----- (0000000140007168) ----------------------------------------------------
void *__fastcall sub_140007168(__int64 a1)
{
  void *result; // rax
  void *v2; // rbx

  result = (void *)sub_140007194(a1);
  v2 = 0i64;
  if ( result )
  {
    LOBYTE(v2) = WaitForSingleObject(result, 0) != 0;
    result = v2;
  }
  return result;
}

//----- (0000000140007194) ----------------------------------------------------
__int64 __fastcall sub_140007194(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rbx
  __int64 i; // rdi

  v1 = a1;
  v2 = 0i64;
  EnterCriticalSection(&CriticalSection);
  for ( i = qword_140020630; i; i = *(_QWORD *)i )
  {
    if ( *(_QWORD *)(i + 24) == v1 )
    {
      if ( WaitForSingleObject(*(HANDLE *)(i + 16), 0) )
        v2 = *(_QWORD *)(i + 16);
      break;
    }
  }
  LeaveCriticalSection(&CriticalSection);
  return v2;
}
// 140020630: using guessed type __int64 qword_140020630;

//----- (0000000140007204) ----------------------------------------------------
void __fastcall sub_140007204(__int64 a1)
{
  __int64 v1; // rdi
  void *v2; // rax
  __int64 i; // rbx

  v1 = a1;
  v2 = (void *)sub_140007194(a1);
  TerminateThread(v2, 0);
  EnterCriticalSection(&CriticalSection);
  for ( i = qword_140020630; i; i = *(_QWORD *)i )
  {
    if ( *(_QWORD *)(i + 24) == v1 )
    {
      CloseHandle(*(HANDLE *)(i + 16));
      sub_1400123B8((__int64 **)&qword_140020630, i + 16);
      break;
    }
  }
  LeaveCriticalSection(&CriticalSection);
}
// 140020630: using guessed type __int64 qword_140020630;

//----- (000000014000727C) ----------------------------------------------------
__int64 __fastcall sub_14000727C(LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter)
{
  __int64 v2; // rdi
  HANDLE v3; // rbp
  __int64 v4; // rbx
  HANDLE *v5; // rsi
  _QWORD *v6; // rax
  __int64 v8; // [rsp+50h] [rbp+18h]

  v2 = 0i64;
  v3 = CreateThread(0i64, 0x1000ui64, lpStartAddress, lpParameter, 0, (LPDWORD)&v8);
  if ( v3 )
  {
    EnterCriticalSection(&CriticalSection);
    v4 = qword_140020630;
    while ( v4 )
    {
      v5 = (HANDLE *)(v4 + 16);
      if ( WaitForSingleObject(*(HANDLE *)(v4 + 16), 0) )
      {
        v4 = *(_QWORD *)v4;
      }
      else
      {
        CloseHandle(*v5);
        v4 = *(_QWORD *)v4;
        sub_1400123B8((__int64 **)&qword_140020630, (__int64)v5);
      }
    }
    v2 = qword_14001F110++;
    v6 = (_QWORD *)sub_140012400((__int64)&qword_140020630, 32);
    *v6 = v3;
    v6[1] = v2;
    LeaveCriticalSection(&CriticalSection);
  }
  return v2;
}
// 14001F110: using guessed type __int64 qword_14001F110;
// 140020630: using guessed type __int64 qword_140020630;

//----- (000000014000735C) ----------------------------------------------------
void __fastcall sub_14000735C(DWORD a1)
{
  DWORD v1; // ebx

  v1 = a1;
  if ( !dword_140020638 )
  {
    timeBeginPeriod(1u);
    dword_140020638 = 1;
  }
  Sleep(v1);
}
// 140020638: using guessed type int dword_140020638;

//----- (0000000140007390) ----------------------------------------------------
CHAR *__fastcall sub_140007390(LPCWSTR lpWideCharStr)
{
  const WCHAR *v1; // rdi
  int v2; // eax
  int cbMultiByte; // esi
  CHAR *result; // rax
  CHAR *v5; // rbx

  v1 = word_14001968C;
  if ( lpWideCharStr )
    v1 = lpWideCharStr;
  v2 = WideCharToMultiByte(0xFDE9u, 0, v1, -1, 0i64, 0, 0i64, 0i64);
  cbMultiByte = v2;
  result = (CHAR *)sub_14000D130(v2);
  v5 = result;
  if ( result )
  {
    WideCharToMultiByte(0xFDE9u, 0, v1, -1, result, cbMultiByte, 0i64, 0i64);
    result = v5;
  }
  return result;
}

//----- (0000000140007430) ----------------------------------------------------
__int64 __fastcall sub_140007430(_WORD *a1, _WORD *a2)
{
  int v2; // er9
  _WORD *v3; // r11
  __int16 v4; // bx
  __int16 v5; // ax
  __int16 v6; // dx
  _WORD *v7; // rax
  _WORD *v8; // r10

  v2 = 0;
  v3 = a2;
  if ( a1 )
  {
    if ( a2 )
    {
      v4 = *a2;
      if ( *a2 )
      {
        v5 = *a1;
        while ( *a1 )
        {
          ++a1;
          if ( v5 == v4 )
          {
            v6 = *a1;
            v7 = v3 + 1;
            v8 = a1;
            if ( *a1 )
            {
              while ( *v7 )
              {
                if ( v6 == *v7 )
                {
                  v6 = a1[1];
                  ++a1;
                  ++v7;
                  if ( v6 )
                    continue;
                }
                goto LABEL_10;
              }
            }
            else
            {
LABEL_10:
              if ( *v7 )
              {
                a1 = v8;
                goto LABEL_13;
              }
            }
            ++v2;
          }
LABEL_13:
          v5 = *a1;
        }
      }
    }
  }
  return v2;
}

//----- (00000001400074D0) ----------------------------------------------------
wchar_t *__fastcall sub_1400074D0(wchar_t *Source, signed int a2, const wchar_t *a3, int a4)
{
  int v4; // er13
  signed int v5; // er12
  signed __int64 v6; // rbp
  const wchar_t *v7; // r14
  wchar_t *v8; // rbx
  int v9; // edi
  wchar_t *v10; // rsi
  signed __int64 v11; // rax
  size_t v12; // r15
  int v13; // edi
  void *v14; // rax
  wchar_t *result; // rax
  wchar_t *v16; // rbx
  wchar_t v17; // ax

  v4 = a4;
  v5 = a2;
  LODWORD(v6) = 0;
  if ( a2 < 1 )
    return (wchar_t *)sub_140012F20(a4);
  v7 = word_14001968C;
  v8 = word_14001968C;
  v9 = 0;
  if ( Source )
    v8 = Source;
  if ( a3 )
    v7 = a3;
  v10 = v8;
  if ( !*v7 || !v7[1] )
  {
    while ( 1 )
    {
      v17 = *v8;
      if ( *v8 == *v7 || !v17 )
      {
        if ( ++v9 == a2 )
        {
          v6 = v8 - v10;
          goto LABEL_18;
        }
        if ( !v17 )
          goto LABEL_18;
        v10 = v8 + 1;
      }
      ++v8;
    }
  }
  v11 = -1i64;
  do
    ++v11;
  while ( v7[v11] );
  v12 = (signed int)v11;
  while ( 1 )
  {
    while ( wcsncmp(v8, v7, v12) && *v8 )
      ++v8;
    if ( ++v9 == v5 )
      break;
    if ( !*v8 )
      goto LABEL_18;
    v8 += v12;
    v10 = v8;
  }
  v6 = v8 - v10;
LABEL_18:
  v13 = sub_140012DA0((unsigned __int64)v8);
  if ( v13 )
  {
    v14 = (void *)sub_140012E10(v4);
    memmove(v14, v10, 2i64 * (signed int)v6);
  }
  result = (wchar_t *)sub_140012E40(v6, v4);
  v16 = result;
  if ( !v13 )
    result = wcsncpy(result, v10, (signed int)v6);
  v16[(signed int)v6] = 0;
  return result;
}

//----- (0000000140007650) ----------------------------------------------------
signed __int64 __fastcall sub_140007650(_WORD *a1, const wchar_t *a2)
{
  _WORD *v2; // rbx
  signed int v3; // ecx
  _WORD *v4; // rax
  signed __int64 v5; // rax
  wchar_t *v6; // rax
  signed __int64 result; // rax

  v2 = a1;
  v3 = 1;
  v4 = v2;
  if ( !v2 || !a2 || !*v2 || !*a2 )
    goto LABEL_13;
  do
    ++v4;
  while ( *v4 );
  v5 = v4 - v2;
  if ( (signed int)v5 < 1 )
    v3 = v5 + 1;
  v6 = wcsstr(&v2[v3 - 1i64], a2);
  if ( v6 )
    result = v6 - v2 + 1;
  else
LABEL_13:
    result = 0i64;
  return result;
}

//----- (00000001400076D0) ----------------------------------------------------
signed __int64 __fastcall sub_1400076D0(_WORD *a1, const wchar_t *a2, signed int a3)
{
  _WORD *v3; // rbx
  _WORD *v4; // rax
  signed __int64 v5; // rax
  wchar_t *v6; // rax
  signed __int64 result; // rax

  v3 = a1;
  v4 = a1;
  if ( !a1 || !a2 || !*a1 || !*a2 )
    goto LABEL_15;
  do
    ++v4;
  while ( *v4 );
  v5 = v4 - a1;
  if ( a3 >= 1 )
  {
    if ( a3 > (signed int)v5 )
      a3 = v5 + 1;
  }
  else
  {
    a3 = 1;
  }
  v6 = wcsstr(&a1[a3 - 1i64], a2);
  if ( v6 )
    result = v6 - v3 + 1;
  else
LABEL_15:
    result = 0i64;
  return result;
}

//----- (0000000140007750) ----------------------------------------------------
__int64 __fastcall sub_140007750(_WORD *a1, _WORD *a2)
{
  if ( a1 && a2 && *a1 && *a2 )
    JUMPOUT(loc_14000776A);
  return 0i64;
}

//----- (00000001400077E0) ----------------------------------------------------
signed __int64 __fastcall sub_1400077E0(unsigned __int16 *a1)
{
  signed __int64 v1; // rdx
  signed int v2; // er9
  unsigned __int16 v3; // ax
  signed __int64 v4; // r10
  int v5; // er8
  signed __int64 v6; // rdx
  signed __int64 v7; // rdx
  unsigned __int16 v8; // ax
  unsigned __int16 *v9; // rcx

  v1 = 0i64;
  if ( !a1 )
    return v1;
  while ( *a1 == 32 || *a1 == 9 )
    ++a1;
  if ( *a1 == 45 )
  {
    v2 = 1;
LABEL_8:
    ++a1;
    goto LABEL_9;
  }
  v2 = 0;
  if ( *a1 == 43 )
    goto LABEL_8;
LABEL_9:
  v3 = *a1;
  if ( *a1 == 36 )
  {
    v4 = 35465847073801215i64;
    while ( 1 )
    {
      v5 = a1[1];
      ++a1;
      if ( (unsigned __int16)(v5 - 48) > 0x36u || !_bittest64(&v4, (unsigned int)(v5 - 48)) )
        break;
      if ( (unsigned __int16)(v5 - 48) > 9u )
      {
        v6 = 16 * v1;
        if ( (unsigned __int16)v5 < 0x61u )
          v7 = v6 - 55;
        else
          v7 = v6 - 87;
        v1 = (unsigned __int16)v5 + v7;
      }
      else
      {
        v1 = (unsigned __int16)v5 + 16 * (v1 - 3);
      }
    }
  }
  else if ( v3 == 37 )
  {
    v8 = a1[1];
    v9 = a1 + 1;
    if ( v8 >= 0x30u )
    {
      do
      {
        if ( v8 > 0x31u )
          break;
        ++v9;
        v1 = v8 + 2 * (v1 - 24);
        v8 = *v9;
      }
      while ( *v9 >= 0x30u );
    }
  }
  else if ( v3 >= 0x30u )
  {
    do
    {
      if ( v3 > 0x39u )
        break;
      ++a1;
      v1 = v3 + 2 * (5 * v1 - 24);
      v3 = *a1;
    }
    while ( *a1 >= 0x30u );
  }
  if ( v2 )
    v1 = -v1;
  return v1;
}

//----- (0000000140007910) ----------------------------------------------------
__int64 __fastcall sub_140007910(__int64 a1, int a2, int a3)
{
  int v3; // edi
  int v4; // ebx
  unsigned __int64 v5; // rsi
  int v6; // eax
  int v7; // er14
  int v8; // ebp
  int v9; // er15
  __int64 result; // rax
  _DWORD *v11; // rbx

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = sub_140007CB0(a1);
  if ( v4 < 0 )
    v4 = 0;
  v7 = v6;
  v8 = v6;
  if ( v6 > v4 )
    v7 = v4;
  v9 = sub_140012DA0(v5);
  result = sub_140012E40(v7, v3);
  v11 = (_DWORD *)result;
  if ( v9 )
  {
    result = sub_140012F60(v9);
    v5 = result;
  }
  if ( v5 )
    return sub_140012F90(v11, (_DWORD *)(v5 + 2i64 * (v8 - v7)), v7);
  *(_WORD *)v11 = 0;
  return result;
}

//----- (00000001400079C0) ----------------------------------------------------
__int64 __fastcall sub_1400079C0(wchar_t *a1, _WORD *a2, int a3)
{
  return sub_140007A40(a1, a2, 0, 1, -1, a3);
}

//----- (00000001400079F0) ----------------------------------------------------
__int64 __fastcall sub_1400079F0(wchar_t *a1, _WORD *a2, int a3, int a4)
{
  return sub_140007A40(a1, a2, a3, 1, -1, a4);
}

//----- (0000000140007A20) ----------------------------------------------------
__int64 __fastcall sub_140007A20(wchar_t *a1, _WORD *a2, int a3, signed int a4, int a5)
{
  return sub_140007A40(a1, a2, a3, a4, -1, a5);
}

//----- (0000000140007A40) ----------------------------------------------------
__int64 __usercall sub_140007A40@<rax>(wchar_t *Source@<rcx>, _WORD *a2@<rdx>, int a3@<r8d>, signed int a4@<r9d>, int a5, int a6)
{
  signed __int64 v6; // r15
  _WORD *v7; // rsi
  const wchar_t *v8; // rbx
  signed __int64 v9; // rbp
  int v10; // edi
  int v11; // er12
  wchar_t *v12; // r14
  LPVOID v13; // rax
  void *v14; // r13
  signed __int64 v15; // rdx
  __int16 v16; // cx
  int (__cdecl *v17)(const wchar_t *, const wchar_t *, size_t); // r12
  size_t v18; // rdi
  int v19; // edi
  size_t v20; // rdi
  wchar_t v21; // ax
  signed __int64 v22; // rcx
  wchar_t v23; // ax
  __int64 result; // rax
  const wchar_t *v25; // [rsp+20h] [rbp-48h]
  wchar_t *v26; // [rsp+28h] [rbp-40h]
  void *v27; // [rsp+70h] [rbp+8h]
  int v28; // [rsp+80h] [rbp+18h]
  signed int v29; // [rsp+88h] [rbp+20h]

  v29 = a4;
  v28 = a3;
  v6 = -1i64;
  v7 = a2;
  v8 = Source;
  if ( Source )
  {
    v9 = -1i64;
    do
      ++v9;
    while ( Source[v9] );
  }
  else
  {
    LODWORD(v9) = 0;
  }
  v10 = sub_140012DA0((unsigned __int64)Source);
  v11 = sub_140012DA0((unsigned __int64)v7);
  LODWORD(v27) = v11;
  v12 = (wchar_t *)sub_140012E40(v9, a6);
  if ( v10 )
    v8 = (const wchar_t *)sub_140012F60(v10);
  if ( v11 )
    v7 = (_WORD *)sub_140012F60(v11);
  v26 = v12;
  if ( v8 && *v8 )
  {
    if ( v7 && *v7 )
    {
      v25 = v8;
      do
        ++v6;
      while ( v7[v6] );
      if ( v11 )
      {
        v13 = HeapAlloc(hHeap, 0, 2i64 * ((signed int)v6 + 1));
        v14 = v13;
        v15 = (_BYTE *)v13 - (_BYTE *)v7;
        do
        {
          v16 = *v7;
          ++v7;
          *(_WORD *)((char *)v7 + v15 - 2) = v16;
        }
        while ( v16 );
        v7 = v13;
      }
      else
      {
        v14 = v27;
      }
      v17 = wcsncmp;
      if ( v28 & 1 )
        v17 = wcsnicmp;
      if ( v29 > 1 )
      {
        v18 = v29 - 1;
        wcsncpy(v12, v8, v18);
        v12 += v18;
        v8 += v18;
      }
      if ( *v8 )
      {
        v19 = a5;
        v6 = (signed int)v6;
        do
        {
          if ( ((unsigned int (__fastcall *)(const wchar_t *, _WORD *, signed __int64))v17)(v8, v7, v6) )
          {
            v21 = *v8;
            ++v12;
            ++v8;
            *(v12 - 1) = v21;
          }
          else
          {
            v8 += v6;
            if ( v19 != -1 && --v19 <= 0 )
            {
              v20 = (signed int)v9 - (v8 - v25);
              wcsncpy(v12, v8, v20);
              v12 += v20;
              break;
            }
          }
        }
        while ( *v8 );
      }
      if ( (_DWORD)v27 )
        HeapFree(hHeap, 0, v14);
    }
    else
    {
      v22 = (char *)v12 - (char *)v8;
      do
      {
        v23 = *v8;
        ++v8;
        *(const wchar_t *)((char *)v8 + v22 - 2) = v23;
      }
      while ( v23 );
      v12 += (signed int)v9;
    }
  }
  sub_140013010(v9 - (v12 - v26));
  result = 0i64;
  *v12 = 0;
  return result;
}

//----- (0000000140007C80) ----------------------------------------------------
_WORD *__fastcall sub_140007C80(__int16 a1, int a2)
{
  __int16 v2; // bx
  _WORD *result; // rax

  v2 = a1;
  result = (_WORD *)sub_140012E40(1, a2);
  *result = v2;
  result[1] = 0;
  return result;
}

//----- (0000000140007CB0) ----------------------------------------------------
signed __int64 __fastcall sub_140007CB0(__int64 a1)
{
  signed __int64 result; // rax

  if ( !a1 )
    return 0i64;
  result = -1i64;
  do
    ++result;
  while ( *(_WORD *)(a1 + 2 * result) );
  return result;
}

//----- (0000000140007CD0) ----------------------------------------------------
__int64 __fastcall sub_140007CD0(__int16 *a1, int a2)
{
  wchar_t *v2; // rbx
  int v3; // ebp
  signed __int64 v4; // rdi
  int v5; // esi
  __int64 v6; // r14
  wchar_t *v7; // rdx
  __int64 v8; // r9
  signed __int64 v9; // r8
  wchar_t v10; // ax
  wchar_t v11; // cx
  __int64 result; // rax

  v2 = word_14001968C;
  v3 = a2;
  if ( a1 )
    v2 = (wchar_t *)a1;
  v4 = -1i64;
  do
    ++v4;
  while ( v2[v4] );
  v5 = sub_140012DA0((unsigned __int64)v2);
  v6 = sub_140012E40(v4, v3);
  if ( (_DWORD)v4 )
  {
    if ( v5 )
      v2 = (wchar_t *)sub_140012F60(v5);
    v7 = &v2[(signed int)v4 - 1i64];
    if ( v2 <= v7 )
    {
      v8 = v6 - (_QWORD)v2;
      v9 = v6 + 2 * ((signed int)v4 - 1i64) - (_QWORD)v7;
      do
      {
        v10 = *v7;
        v11 = *v2;
        --v7;
        *(wchar_t *)((char *)v2 + v8) = v10;
        *(wchar_t *)((char *)v7 + v9 + 2) = v11;
        ++v2;
      }
      while ( v2 <= v7 );
    }
  }
  result = (signed int)v4;
  *(_WORD *)(v6 + 2i64 * (signed int)v4) = 0;
  return result;
}

//----- (0000000140007DB0) ----------------------------------------------------
LPWSTR __fastcall sub_140007DB0(__int64 a1, int a2)
{
  int v2; // esi
  char *v3; // rbx
  int v4; // edi
  int v5; // ebp
  WCHAR *v6; // rdi
  signed __int64 v7; // rcx
  __int16 v8; // ax
  LPWSTR result; // rax

  v2 = a2;
  v3 = (char *)a1;
  v4 = sub_140007CB0(a1);
  v5 = sub_140012DA0((unsigned __int64)v3);
  v6 = (WCHAR *)sub_140012E40(v4, v2);
  if ( v5 )
    v3 = (char *)sub_140012F60(v5);
  if ( v3 )
  {
    v7 = (char *)v6 - v3;
    do
    {
      v8 = *(_WORD *)v3;
      v3 += 2;
      *(_WORD *)&v3[v7 - 2] = v8;
    }
    while ( v8 );
    result = CharUpperW(v6);
  }
  else
  {
    result = 0i64;
    *v6 = 0;
  }
  return result;
}

//----- (0000000140007E40) ----------------------------------------------------
__int64 __fastcall sub_140007E40(__int64 a1, int a2, int a3)
{
  int v3; // edi
  int v4; // ebx
  _DWORD *v5; // rsi
  int v6; // eax
  int v7; // ebp
  int v8; // er14
  __int64 result; // rax
  _DWORD *v10; // rbx

  v3 = a3;
  v4 = a2;
  v5 = (_DWORD *)a1;
  v6 = sub_140007CB0(a1);
  if ( v4 < 0 )
    v4 = 0;
  v7 = v6;
  if ( v6 > v4 )
    v7 = v4;
  v8 = sub_140012DA0((unsigned __int64)v5);
  result = sub_140012E40(v7, v3);
  v10 = (_DWORD *)result;
  if ( v8 )
  {
    result = sub_140012F60(v8);
    v5 = (_DWORD *)result;
  }
  if ( v5 && v7 > 0 )
    return sub_140012F90(v10, v5, v7);
  *(_WORD *)v10 = 0;
  return result;
}

//----- (0000000140007EE0) ----------------------------------------------------
__int64 __fastcall sub_140007EE0(__int64 a1, int a2)
{
  return sub_140007EF0(a1, &word_140019690, a2);
}

//----- (0000000140007EF0) ----------------------------------------------------
__int64 __fastcall sub_140007EF0(__int64 a1, unsigned __int16 *a2, int a3)
{
  unsigned __int16 *v3; // rbx
  signed int v4; // edi
  int v5; // er12
  signed int v6; // eax
  int v7; // er14
  unsigned __int64 v8; // rsi
  int v9; // ecx
  signed __int64 v10; // rbx
  signed __int64 v11; // rdx
  unsigned __int16 *v12; // rcx
  int v13; // eax
  int v14; // er15
  __int64 result; // rax
  _DWORD *v16; // rdi
  int v17; // [rsp+50h] [rbp+8h]

  v3 = (unsigned __int16 *)a1;
  v4 = 32;
  v5 = a3;
  if ( a2 )
    v4 = *a2;
  v6 = sub_140007CB0(a1);
  v7 = v6;
  if ( v3 )
  {
    v8 = (unsigned __int64)v3;
    if ( *v3 == v4 )
    {
      do
      {
        v9 = v3[1];
        ++v3;
      }
      while ( v9 == v4 );
    }
    v10 = (signed __int64)((signed __int64)v3 - v8) >> 1;
    if ( (signed int)v10 >= v6 )
    {
      v7 = v6 - v10;
    }
    else
    {
      v11 = 2i64 * v6;
      v12 = (unsigned __int16 *)(v11 + v8 - 2);
      if ( *v12 == v4 )
      {
        do
        {
          v13 = *(v12 - 1);
          --v12;
        }
        while ( v13 == v4 );
      }
      v7 -= v10 + ((signed __int64)(v11 - (_QWORD)v12 + v8 - 2) >> 1);
    }
  }
  else
  {
    LODWORD(v10) = v17;
    v8 = 0i64;
  }
  v14 = sub_140012DA0(v8);
  result = sub_140012E40(v7, v5);
  v16 = (_DWORD *)result;
  if ( v14 )
  {
    result = sub_140012F60(v14);
    v8 = result;
  }
  if ( v8 )
    return sub_140012F90(v16, (_DWORD *)(v8 + 2i64 * (signed int)v10), v7);
  *(_WORD *)v16 = 0;
  return result;
}

//----- (0000000140008000) ----------------------------------------------------
__int64 __fastcall sub_140008000(unsigned __int64 a1, signed int a2, int a3)
{
  signed __int64 v3; // rax

  if ( !a1 )
    return sub_140012F20(a3);
  v3 = -1i64;
  do
    ++v3;
  while ( *(_WORD *)(a1 + 2 * v3) );
  return sub_140008040(a1, a2, 1 - a2 + (signed int)v3, a3);
}

//----- (0000000140008040) ----------------------------------------------------
__int64 __fastcall sub_140008040(unsigned __int64 a1, signed int a2, int a3, int a4)
{
  int v4; // ebp
  int v5; // edi
  signed int v6; // esi
  char *v7; // rbx
  int v8; // er14
  char *v9; // rdi
  __int16 v10; // ax
  signed __int64 v11; // rbx
  __int64 result; // rax

  v4 = a3;
  v5 = a4;
  v6 = a2;
  v7 = (char *)a1;
  if ( a3 < 0 )
    v4 = 0;
  v8 = sub_140012DA0(a1);
  v9 = (char *)sub_140012E40(v4, v5);
  if ( v8 )
    v7 = (char *)sub_140012F60(v8);
  if ( v7 )
  {
    if ( v6 <= 1 )
    {
LABEL_9:
      v10 = *(_WORD *)v7;
      if ( *(_WORD *)v7 )
      {
        v11 = v7 - v9;
        do
        {
          if ( !v4 )
            break;
          *(_WORD *)v9 = v10;
          v10 = *(_WORD *)&v9[v11 + 2];
          v9 += 2;
          --v4;
        }
        while ( v10 );
      }
    }
    else
    {
      while ( *(_WORD *)v7 )
      {
        --v6;
        v7 += 2;
        if ( v6 <= 1 )
          goto LABEL_9;
      }
    }
  }
  result = sub_140013010(v4);
  *(_WORD *)v9 = 0;
  return result;
}

//----- (0000000140008100) ----------------------------------------------------
__int64 __fastcall sub_140008100(signed __int64 a1, int a2)
{
  signed __int64 v2; // rbx
  _WORD *v3; // rdi
  signed __int64 v4; // rdx

  v2 = a1;
  v3 = (_WORD *)sub_140012E40(64, a2);
  sub_140016B9C(v3, v2);
  v4 = -1i64;
  do
    ++v4;
  while ( v3[v4] );
  return sub_140013010(64 - (signed int)v4);
}

//----- (0000000140008160) ----------------------------------------------------
_WORD *__fastcall sub_140008160(signed int a1, int a2)
{
  unsigned int v2; // edi
  _WORD *result; // rax
  _WORD *v4; // r8
  __int64 v5; // rdx
  _WORD *v6; // rdi
  __int64 i; // rcx

  v2 = a1;
  if ( a1 < 0 )
    v2 = 0;
  result = (_WORD *)sub_140012E40(v2, a2);
  v4 = result;
  if ( v2 )
  {
    v5 = v2;
    v6 = result;
    result = (_WORD *)32;
    for ( i = (unsigned int)v5; i; --i )
    {
      *v6 = 32;
      ++v6;
    }
    v4[v5] = 0;
  }
  else
  {
    *result = 0;
  }
  return result;
}

//----- (00000001400081C0) ----------------------------------------------------
void __fastcall sub_1400081C0(wchar_t *a1, void *a2, wchar_t *a3, int a4)
{
  sub_140008250(a1, a2, a3, 0, 0, -1, a4);
}

//----- (00000001400081F0) ----------------------------------------------------
void __fastcall sub_1400081F0(wchar_t *a1, void *a2, wchar_t *a3, char a4, int a5)
{
  sub_140008250(a1, a2, a3, a4, 0, -1, a5);
}

//----- (0000000140008220) ----------------------------------------------------
void __fastcall sub_140008220(wchar_t *a1, void *a2, wchar_t *a3, char a4, int a5, int a6)
{
  sub_140008250(a1, a2, a3, a4, a5, -1, a6);
}

//----- (0000000140008250) ----------------------------------------------------
void __usercall sub_140008250(wchar_t *Str@<rcx>, void *Memory@<rdx>, wchar_t *a3@<r8>, char a4@<r9b>, int a5, int a6, int a7)
{
  wchar_t *v7; // rdi
  int v8; // ebp
  wchar_t *v9; // rbx
  wchar_t *v10; // r14
  int (__cdecl *v11)(const wchar_t *, const wchar_t *, size_t); // r12
  int v12; // eax
  signed __int64 v13; // rsi
  signed __int64 v14; // r15
  signed __int64 v15; // r13
  wchar_t *v16; // rdi
  wchar_t *v17; // rsi
  wchar_t *v18; // rbx
  wchar_t i; // ax
  __int64 v20; // rdi
  wchar_t *v21; // rbx
  wchar_t *v22; // rax
  wchar_t *v23; // rdi
  wchar_t *v24; // rax
  signed __int64 v25; // rdi
  wchar_t v26; // cx
  wchar_t *v27; // rsi
  __int64 v28; // rcx
  wchar_t v29; // ax
  __int64 v30; // r12
  wchar_t v31; // ax
  wchar_t *Source; // [rsp+20h] [rbp-68h]
  int (__cdecl *v33)(const wchar_t *, const wchar_t *, size_t); // [rsp+28h] [rbp-60h]
  wchar_t *v34; // [rsp+30h] [rbp-58h]
  int v35; // [rsp+90h] [rbp+8h]
  int v36; // [rsp+98h] [rbp+10h]
  int v37; // [rsp+A0h] [rbp+18h]
  int v38; // [rsp+A8h] [rbp+20h]
  int v39; // [rsp+B0h] [rbp+28h]

  v7 = word_14001968C;
  v8 = 0;
  v9 = word_14001968C;
  v10 = word_14001968C;
  if ( Str )
    v9 = Str;
  if ( Memory )
    v10 = (wchar_t *)Memory;
  v11 = wcsncmp;
  if ( a3 )
    v7 = a3;
  v38 = a4 & 1;
  v34 = v9;
  if ( a4 & 1 )
    v11 = wcsnicmp;
  v12 = a5;
  Source = v7;
  v33 = v11;
  if ( a5 <= 0 )
    v12 = 1;
  v13 = -1i64;
  v14 = -1i64;
  v39 = v12;
  do
    ++v14;
  while ( v10[v14] );
  v15 = -1i64;
  do
    ++v15;
  while ( v7[v15] );
  if ( a4 & 2 )
  {
    if ( (_DWORD)v14 )
    {
      if ( a6 )
      {
        v16 = &v9[v12 - 1];
        v17 = v16;
        while ( *v17 )
        {
          if ( a6 != -1 && a6 <= v8 )
            break;
          if ( ((unsigned int (__fastcall *)(wchar_t *, wchar_t *, _QWORD))v11)(v16, v10, (signed int)v14) )
          {
            ++v16;
            ++v17;
          }
          else
          {
            wcsncpy(v16, Source, (signed int)v15);
            v16 += (signed int)v15;
            v17 += (signed int)v14;
            ++v8;
          }
        }
      }
    }
    return;
  }
  v35 = sub_140012DA0((unsigned __int64)v9);
  if ( v35 )
  {
    v9 = wcsdup(v9);
    v34 = v9;
  }
  v36 = sub_140012DA0((unsigned __int64)v10);
  if ( v36 )
    v10 = wcsdup(v10);
  v37 = sub_140012DA0((unsigned __int64)v7);
  if ( v37 )
    Source = wcsdup(v7);
  v18 = &v9[v39 - 1];
  if ( a6 )
  {
    for ( i = *v18; *v18; i = *v18 )
    {
      if ( v38 )
      {
        v20 = (signed int)v14;
        if ( ((unsigned int (__fastcall *)(wchar_t *, wchar_t *, _QWORD))v11)(v18, v10, (signed int)v14) )
          goto LABEL_37;
      }
      else if ( i != *v10
             || (v20 = (signed int)v14,
                 ((unsigned int (__fastcall *)(wchar_t *, wchar_t *, _QWORD))v11)(v18, v10, (signed int)v14)) )
      {
LABEL_37:
        ++v18;
        continue;
      }
      ++v8;
      v18 += v20;
      if ( a6 != -1 && a6 <= v8 )
        break;
    }
  }
  v21 = v34;
  do
    ++v13;
  while ( v34[v13] );
  v22 = (wchar_t *)sub_140012E40((signed int)v13 + v8 * ((signed int)v15 - (signed int)v14), a7);
  v23 = v22;
  if ( !v8 )
  {
    v24 = v34;
    v25 = (char *)v23 - (char *)v34;
    do
    {
      v26 = *v24;
      ++v24;
      *(wchar_t *)((char *)v24 + v25 - 2) = v26;
    }
    while ( v26 );
    goto LABEL_60;
  }
  v27 = v34;
  if ( v39 > 1 )
  {
    wcsncpy(v22, v34, v39);
    v28 = v39 - 1;
    v23 += v28;
    v27 = &v34[v28];
  }
  v29 = *v27;
  if ( *v27 )
  {
    while ( 1 )
    {
      if ( v8 > 0 )
      {
        if ( v38 )
        {
          v30 = (signed int)v14;
          if ( !((unsigned int (__fastcall *)(wchar_t *, wchar_t *, _QWORD))v33)(v27, v10, (signed int)v14) )
            goto LABEL_68;
        }
        else if ( v29 == *v10 )
        {
          v30 = (signed int)v14;
          if ( !((unsigned int (__fastcall *)(wchar_t *, wchar_t *, _QWORD))v33)(v27, v10, (signed int)v14) )
          {
LABEL_68:
            wcsncpy(v23, Source, (signed int)v15);
            v23 += (signed int)v15;
            v27 += v30;
            --v8;
            goto LABEL_57;
          }
        }
      }
      v31 = *v27;
      ++v23;
      ++v27;
      *(v23 - 1) = v31;
LABEL_57:
      v29 = *v27;
      if ( !*v27 )
      {
        v21 = v34;
        break;
      }
    }
  }
  *v23 = 0;
LABEL_60:
  if ( v35 )
    free(v21);
  if ( v36 )
    free(v10);
  if ( v37 )
    free(Source);
}

//----- (00000001400085E0) ----------------------------------------------------
unsigned __int16 *__fastcall sub_1400085E0(unsigned __int16 *a1, _WORD *a2)
{
  unsigned __int16 *v2; // rbx
  signed __int64 v3; // r13
  LPWSTR v4; // rax
  signed __int64 v5; // r15
  __int16 v6; // di
  unsigned __int16 v7; // ax
  signed __int64 v8; // rsi
  unsigned __int16 *v9; // r14
  WCHAR *v10; // rcx
  unsigned int v11; // ebp
  int v12; // edi
  LPWSTR v14; // [rsp+70h] [rbp+18h]

  v2 = a1;
  v3 = (signed __int64)(a2 + 1);
  if ( !*a2 )
    return v2;
  v4 = CharLowerW((LPWSTR)(unsigned __int16)*a2);
  v5 = -1i64;
  v6 = (signed __int16)v4;
  v14 = v4;
  do
    ++v5;
  while ( *(_WORD *)(v3 + 2 * v5) );
  while ( 1 )
  {
    v7 = *v2;
    ++v2;
    if ( !v7 )
      return 0i64;
    if ( (unsigned __int16)CharLowerW((LPWSTR)v7) == v6 )
    {
      v8 = v5;
      v9 = (unsigned __int16 *)v3;
      if ( !v5 )
      {
LABEL_10:
        --v2;
        return v2;
      }
      while ( 1 )
      {
        v10 = (WCHAR *)*v9;
        v11 = *(unsigned __int16 *)((char *)v9 + (_QWORD)v2 - v3);
        ++v9;
        v12 = (unsigned __int16)CharLowerW(v10);
        if ( (unsigned __int16)CharLowerW((LPWSTR)v11) != v12 )
          break;
        if ( (_WORD)v11 )
        {
          if ( --v8 )
            continue;
        }
        goto LABEL_10;
      }
      v6 = (signed __int16)v14;
    }
  }
}

//----- (00000001400086C0) ----------------------------------------------------
__int64 __fastcall sub_1400086C0(__int64 a1, unsigned __int16 *a2, __int64 a3)
{
  __int64 v3; // rbx
  unsigned __int16 *v4; // rsi
  __int64 result; // rax
  __int64 v6; // r14
  WCHAR *v7; // rcx
  unsigned int v8; // ebp
  int v9; // edi

  v3 = a3;
  v4 = a2;
  if ( !a3 )
    return 0i64;
  v6 = a1 - (_QWORD)a2;
  do
  {
    v7 = (WCHAR *)*v4;
    v8 = *(unsigned __int16 *)((char *)v4 + v6);
    ++v4;
    v9 = (unsigned __int16)CharLowerW(v7);
    result = (unsigned int)(unsigned __int16)CharLowerW((LPWSTR)v8) - v9;
    if ( (_DWORD)result )
      break;
    if ( !(_WORD)v8 )
      break;
    --v3;
  }
  while ( v3 );
  return result;
}

//----- (0000000140008750) ----------------------------------------------------
void __fastcall sub_140008750(__int64 *a1, __int64 a2, signed __int64 a3, signed __int64 a4)
{
  signed __int64 v4; // rbx
  __int64 *v5; // rsi
  __int64 v6; // rdx
  __int64 v7; // rbx
  signed __int64 v8; // rax
  signed __int64 v9; // [rsp+8h] [rbp+8h]

  if ( a1 )
  {
    v4 = a4;
    v5 = a1;
    if ( *a1 )
    {
      if ( a3 == -1 )
      {
        v6 = a1[1];
        v7 = a1[4];
        goto LABEL_7;
      }
      v9 = sub_14000DEC4(a1, a3);
      v8 = sub_14000DEC4(v5, v4);
      if ( v9 && v8 )
LABEL_7:
        JUMPOUT(loc_1400087E1);
    }
  }
}

//----- (0000000140008A80) ----------------------------------------------------
void __fastcall sub_140008A80(_QWORD *a1)
{
  __int64 v1; // rax

  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = a1[1];
      JUMPOUT(loc_140008AA9);
    }
  }
}

//----- (0000000140008D30) ----------------------------------------------------
__int64 __fastcall sub_140008D30(__int64 *a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    result = *a1;
    if ( *a1 )
      JUMPOUT(loc_140008D5E);
  }
  return result;
}

//----- (0000000140009060) ----------------------------------------------------
__int64 __fastcall sub_140009060(__int64 *a1)
{
  return sub_140008D30(a1);
}

//----- (0000000140009080) ----------------------------------------------------
void __fastcall sub_140009080(_QWORD *a1, __int64 **a2, signed __int64 a3, __int64 a4)
{
  __int64 v4; // rsi
  __int64 **v5; // r10
  __int64 *v6; // rcx
  signed __int64 v7; // rcx
  signed __int64 v8; // rdi
  __int64 *v9; // rax
  signed __int64 v10; // rbx
  _QWORD *v11; // rdx
  _QWORD *v12; // r8
  __int64 *v13; // rax
  _QWORD *v14; // [rsp+20h] [rbp-20h]
  __int64 v15; // [rsp+28h] [rbp-18h]
  _QWORD *v16; // [rsp+60h] [rbp+20h]
  __int64 **v17; // [rsp+68h] [rbp+28h]
  __int64 *i; // [rsp+70h] [rbp+30h]

  v17 = a2;
  v16 = a1;
  v4 = a4;
  v5 = (__int64 **)a1;
  if ( a3 == 2 )
  {
    v6 = (__int64 *)*a1;
    if ( *((_BYTE *)v6 + a4) < *((_BYTE *)*a2 + a4) )
    {
      *v5 = *a2;
      *a2 = v6;
      **v5 = (__int64)v6;
      (*a2)[1] = (__int64)*v5;
    }
  }
  else if ( a3 > 2 )
  {
    v7 = a3 / 2;
    v8 = a3 - a3 / 2;
    v9 = *v5;
    for ( i = *v5; v7; --v7 )
    {
      v9 = (__int64 *)*v9;
      i = v9;
    }
    v10 = a3 / 2;
    v14 = (_QWORD *)v9[1];
    sub_140009080(v5, &v14, a3 / 2);
    sub_140009080(&i, v17, v8);
    v11 = i;
    v12 = (_QWORD *)*v16;
    v13 = &v15;
    v14 = (_QWORD *)*v16;
    if ( v10 )
    {
      while ( v8 )
      {
        if ( *((_BYTE *)v12 + v4) < *((_BYTE *)v11 + v4) )
        {
          *v13 = (__int64)v11;
          --v8;
          i[1] = (__int64)v13;
          v13 = i;
          v12 = v14;
          v11 = (_QWORD *)*i;
          i = (__int64 *)*i;
        }
        else
        {
          *v13 = (__int64)v12;
          --v10;
          v14[1] = v13;
          v13 = v14;
          v11 = i;
          v12 = (_QWORD *)*v14;
          v14 = (_QWORD *)*v14;
        }
        if ( !v10 )
          goto LABEL_13;
      }
      for ( ; v10; --v10 )
      {
        *v13 = (__int64)v12;
        v14[1] = v13;
        v13 = v14;
        v12 = (_QWORD *)*v14;
        v14 = (_QWORD *)*v14;
      }
    }
    else
    {
LABEL_13:
      while ( v8 )
      {
        *v13 = (__int64)v11;
        i[1] = (__int64)v13;
        v13 = i;
        v11 = (_QWORD *)*i;
        i = (__int64 *)*i;
        --v8;
      }
    }
    *v16 = v15;
    *v17 = v13;
  }
}

//----- (0000000140009220) ----------------------------------------------------
void __fastcall sub_140009220(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4)
{
  _QWORD *v4; // r10
  __int64 v5; // rcx

  v4 = a1;
  if ( a3 == 2 )
  {
    v5 = *a1;
    if ( *(_BYTE *)(v5 + a4) < *(_BYTE *)(a4 + *(_QWORD *)a2) )
    {
      *v4 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v5;
      *(_QWORD *)*v4 = v5;
      *(_QWORD *)(*(_QWORD *)a2 + 8i64) = *v4;
    }
  }
  else if ( a3 > 2 )
  {
    JUMPOUT(loc_140009280);
  }
}

//----- (00000001400093C0) ----------------------------------------------------
void __fastcall sub_1400093C0(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4)
{
  _QWORD *v4; // r10
  __int64 v5; // rcx

  v4 = a1;
  if ( a3 == 2 )
  {
    v5 = *a1;
    if ( *(_WORD *)(v5 + a4) < *(_WORD *)(a4 + *(_QWORD *)a2) )
    {
      *v4 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v5;
      *(_QWORD *)*v4 = v5;
      *(_QWORD *)(*(_QWORD *)a2 + 8i64) = *v4;
    }
  }
  else if ( a3 > 2 )
  {
    JUMPOUT(loc_140009421);
  }
}

//----- (0000000140009560) ----------------------------------------------------
void __fastcall sub_140009560(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4)
{
  _QWORD *v4; // r10
  __int64 v5; // rcx

  v4 = a1;
  if ( a3 == 2 )
  {
    v5 = *a1;
    if ( *(double *)(a4 + *(_QWORD *)a2) > *(double *)(v5 + a4) )
    {
      *v4 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v5;
      *(_QWORD *)*v4 = v5;
      *(_QWORD *)(*(_QWORD *)a2 + 8i64) = *v4;
    }
  }
  else if ( a3 > 2 )
  {
    JUMPOUT(loc_1400095C3);
  }
}

//----- (0000000140009700) ----------------------------------------------------
void __fastcall sub_140009700(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4)
{
  _QWORD *v4; // r10
  __int64 v5; // rcx

  v4 = a1;
  if ( a3 == 2 )
  {
    v5 = *a1;
    if ( *(float *)(a4 + *(_QWORD *)a2) > *(float *)(v5 + a4) )
    {
      *v4 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v5;
      *(_QWORD *)*v4 = v5;
      *(_QWORD *)(*(_QWORD *)a2 + 8i64) = *v4;
    }
  }
  else if ( a3 > 2 )
  {
    JUMPOUT(loc_140009762);
  }
}

//----- (00000001400098A0) ----------------------------------------------------
void __fastcall sub_1400098A0(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4)
{
  _QWORD *v4; // r10
  __int64 v5; // rcx

  v4 = a1;
  if ( a3 == 2 )
  {
    v5 = *a1;
    if ( *(_DWORD *)(v5 + a4) < *(_DWORD *)(a4 + *(_QWORD *)a2) )
    {
      *v4 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v5;
      *(_QWORD *)*v4 = v5;
      *(_QWORD *)(*(_QWORD *)a2 + 8i64) = *v4;
    }
  }
  else if ( a3 > 2 )
  {
    JUMPOUT(loc_1400098FF);
  }
}

//----- (0000000140009A30) ----------------------------------------------------
void __fastcall sub_140009A30(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4)
{
  _QWORD *v4; // r10
  __int64 v5; // rcx

  v4 = a1;
  if ( a3 == 2 )
  {
    v5 = *a1;
    if ( *(_QWORD *)(v5 + a4) < *(_QWORD *)(a4 + *(_QWORD *)a2) )
    {
      *v4 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v5;
      *(_QWORD *)*v4 = v5;
      *(_QWORD *)(*(_QWORD *)a2 + 8i64) = *v4;
    }
  }
  else if ( a3 > 2 )
  {
    JUMPOUT(loc_140009A8F);
  }
}

//----- (0000000140009BC0) ----------------------------------------------------
void __fastcall sub_140009BC0(_QWORD *a1, __int64 **a2, signed __int64 a3, __int64 a4)
{
  __int64 **v4; // rsi
  __int64 *v5; // rcx
  signed __int64 v6; // rcx
  signed __int64 v7; // rsi
  _QWORD *v8; // rax
  signed __int64 v9; // rdi
  _QWORD *v10; // rdx
  _QWORD *v11; // rax
  _QWORD *v12; // rcx
  __int64 *v13; // rbx
  _QWORD *v14; // [rsp+20h] [rbp-28h]
  __int64 v15; // [rsp+28h] [rbp-20h]
  _QWORD *v16; // [rsp+70h] [rbp+28h]
  __int64 **v17; // [rsp+78h] [rbp+30h]
  _QWORD *i; // [rsp+80h] [rbp+38h]
  __int64 v19; // [rsp+88h] [rbp+40h]

  v19 = a4;
  v17 = a2;
  v16 = a1;
  v4 = (__int64 **)a1;
  if ( a3 == 2 )
  {
    if ( (signed int)sub_14000B4C0(*(char **)(*a1 + a4), *(char **)((char *)*a2 + a4)) < 0 )
    {
      v5 = *v4;
      *v4 = *v17;
      *v17 = v5;
      **v4 = (__int64)v5;
      (*v17)[1] = (__int64)*v4;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = a3 / 2;
    v7 = a3 - a3 / 2;
    v8 = (_QWORD *)*v16;
    for ( i = (_QWORD *)*v16; v6; --v6 )
    {
      v8 = (_QWORD *)*v8;
      i = v8;
    }
    v9 = a3 / 2;
    v14 = (_QWORD *)v8[1];
    sub_140009BC0(v16, &v14, a3 / 2);
    sub_140009BC0(&i, v17, v7);
    v10 = v16;
    v11 = i;
    v12 = (_QWORD *)*v16;
    v13 = &v15;
    v14 = (_QWORD *)*v16;
    if ( v9 )
    {
      while ( v7 )
      {
        if ( (signed int)sub_14000B4C0(*(char **)((char *)v12 + v19), *(char **)((char *)v11 + v19)) < 0 )
        {
          --v7;
          *v13 = (__int64)i;
          i[1] = v13;
          v13 = i;
          v12 = v14;
          v11 = (_QWORD *)*i;
          i = (_QWORD *)*i;
        }
        else
        {
          --v9;
          *v13 = (__int64)v14;
          v14[1] = v13;
          v13 = v14;
          v11 = i;
          v12 = (_QWORD *)*v14;
          v14 = (_QWORD *)*v14;
        }
        if ( !v9 )
        {
          v10 = v16;
          goto LABEL_14;
        }
      }
      for ( ; v9; --v9 )
      {
        *v13 = (__int64)v12;
        v14[1] = v13;
        v13 = v14;
        v12 = (_QWORD *)*v14;
        v14 = (_QWORD *)*v14;
      }
      v10 = v16;
    }
    else
    {
LABEL_14:
      while ( v7 )
      {
        *v13 = (__int64)v11;
        i[1] = v13;
        v13 = i;
        v11 = (_QWORD *)*i;
        i = (_QWORD *)*i;
        --v7;
      }
    }
    *v10 = v15;
    *v17 = v13;
  }
}

//----- (0000000140009D90) ----------------------------------------------------
void __fastcall sub_140009D90(_QWORD *a1, __int64 **a2, signed __int64 a3, __int64 a4)
{
  __int64 **v4; // rsi
  __int64 *v5; // rcx
  signed __int64 v6; // rcx
  signed __int64 v7; // rsi
  _QWORD *v8; // rax
  signed __int64 v9; // rdi
  _QWORD *v10; // rdx
  _QWORD *v11; // rax
  _QWORD *v12; // rcx
  __int64 *v13; // rbx
  _QWORD *v14; // [rsp+20h] [rbp-28h]
  __int64 v15; // [rsp+28h] [rbp-20h]
  _QWORD *v16; // [rsp+70h] [rbp+28h]
  __int64 **v17; // [rsp+78h] [rbp+30h]
  _QWORD *i; // [rsp+80h] [rbp+38h]
  __int64 v19; // [rsp+88h] [rbp+40h]

  v19 = a4;
  v17 = a2;
  v16 = a1;
  v4 = (__int64 **)a1;
  if ( a3 == 2 )
  {
    if ( (signed int)sub_14000B500(*(_QWORD *)(*a1 + a4), *(_WORD **)((char *)*a2 + a4)) < 0 )
    {
      v5 = *v4;
      *v4 = *v17;
      *v17 = v5;
      **v4 = (__int64)v5;
      (*v17)[1] = (__int64)*v4;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = a3 / 2;
    v7 = a3 - a3 / 2;
    v8 = (_QWORD *)*v16;
    for ( i = (_QWORD *)*v16; v6; --v6 )
    {
      v8 = (_QWORD *)*v8;
      i = v8;
    }
    v9 = a3 / 2;
    v14 = (_QWORD *)v8[1];
    sub_140009D90(v16, &v14, a3 / 2);
    sub_140009D90(&i, v17, v7);
    v10 = v16;
    v11 = i;
    v12 = (_QWORD *)*v16;
    v13 = &v15;
    v14 = (_QWORD *)*v16;
    if ( v9 )
    {
      while ( v7 )
      {
        if ( (signed int)sub_14000B500(*(_QWORD *)((char *)v12 + v19), *(_WORD **)((char *)v11 + v19)) < 0 )
        {
          --v7;
          *v13 = (__int64)i;
          i[1] = v13;
          v13 = i;
          v12 = v14;
          v11 = (_QWORD *)*i;
          i = (_QWORD *)*i;
        }
        else
        {
          --v9;
          *v13 = (__int64)v14;
          v14[1] = v13;
          v13 = v14;
          v11 = i;
          v12 = (_QWORD *)*v14;
          v14 = (_QWORD *)*v14;
        }
        if ( !v9 )
        {
          v10 = v16;
          goto LABEL_14;
        }
      }
      for ( ; v9; --v9 )
      {
        *v13 = (__int64)v12;
        v14[1] = v13;
        v13 = v14;
        v12 = (_QWORD *)*v14;
        v14 = (_QWORD *)*v14;
      }
      v10 = v16;
    }
    else
    {
LABEL_14:
      while ( v7 )
      {
        *v13 = (__int64)v11;
        i[1] = v13;
        v13 = i;
        v11 = (_QWORD *)*i;
        i = (_QWORD *)*i;
        --v7;
      }
    }
    *v10 = v15;
    *v17 = v13;
  }
}

//----- (0000000140009F60) ----------------------------------------------------
void __fastcall sub_140009F60(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4)
{
  _QWORD *v4; // r10
  __int64 v5; // rcx

  v4 = a1;
  if ( a3 == 2 )
  {
    v5 = *a1;
    if ( *(_WORD *)(v5 + a4) < *(_WORD *)(a4 + *(_QWORD *)a2) )
    {
      *v4 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v5;
      *(_QWORD *)*v4 = v5;
      *(_QWORD *)(*(_QWORD *)a2 + 8i64) = *v4;
    }
  }
  else if ( a3 > 2 )
  {
    JUMPOUT(loc_140009FC1);
  }
}

//----- (000000014000A100) ----------------------------------------------------
void __fastcall sub_14000A100(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4)
{
  _QWORD *v4; // r10
  __int64 v5; // rcx

  v4 = a1;
  if ( a3 == 2 )
  {
    v5 = *a1;
    if ( *(_WORD *)(v5 + a4) < *(_WORD *)(a4 + *(_QWORD *)a2) )
    {
      *v4 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v5;
      *(_QWORD *)*v4 = v5;
      *(_QWORD *)(*(_QWORD *)a2 + 8i64) = *v4;
    }
  }
  else if ( a3 > 2 )
  {
    JUMPOUT(loc_14000A161);
  }
}

//----- (000000014000A2A0) ----------------------------------------------------
void __fastcall sub_14000A2A0(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4)
{
  _QWORD *v4; // r10
  __int64 v5; // rcx

  v4 = a1;
  if ( a3 == 2 )
  {
    v5 = *a1;
    if ( *(_BYTE *)(v5 + a4) > *(_BYTE *)(a4 + *(_QWORD *)a2) )
    {
      *v4 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v5;
      *(_QWORD *)*v4 = v5;
      *(_QWORD *)(*(_QWORD *)a2 + 8i64) = *v4;
    }
  }
  else if ( a3 > 2 )
  {
    JUMPOUT(loc_14000A300);
  }
}

//----- (000000014000A440) ----------------------------------------------------
void __fastcall sub_14000A440(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4)
{
  _QWORD *v4; // r10
  __int64 v5; // rcx

  v4 = a1;
  if ( a3 == 2 )
  {
    v5 = *a1;
    if ( *(_BYTE *)(v5 + a4) > *(_BYTE *)(a4 + *(_QWORD *)a2) )
    {
      *v4 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v5;
      *(_QWORD *)*v4 = v5;
      *(_QWORD *)(*(_QWORD *)a2 + 8i64) = *v4;
    }
  }
  else if ( a3 > 2 )
  {
    JUMPOUT(loc_14000A4A0);
  }
}

//----- (000000014000A5E0) ----------------------------------------------------
void __fastcall sub_14000A5E0(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4)
{
  _QWORD *v4; // r10
  __int64 v5; // rcx

  v4 = a1;
  if ( a3 == 2 )
  {
    v5 = *a1;
    if ( *(_WORD *)(v5 + a4) > *(_WORD *)(a4 + *(_QWORD *)a2) )
    {
      *v4 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v5;
      *(_QWORD *)*v4 = v5;
      *(_QWORD *)(*(_QWORD *)a2 + 8i64) = *v4;
    }
  }
  else if ( a3 > 2 )
  {
    JUMPOUT(loc_14000A641);
  }
}

//----- (000000014000A780) ----------------------------------------------------
void __fastcall sub_14000A780(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4)
{
  _QWORD *v4; // r10
  __int64 v5; // rcx

  v4 = a1;
  if ( a3 == 2 )
  {
    v5 = *a1;
    if ( *(double *)(v5 + a4) > *(double *)(a4 + *(_QWORD *)a2) )
    {
      *v4 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v5;
      *(_QWORD *)*v4 = v5;
      *(_QWORD *)(*(_QWORD *)a2 + 8i64) = *v4;
    }
  }
  else if ( a3 > 2 )
  {
    JUMPOUT(loc_14000A7E3);
  }
}

//----- (000000014000A920) ----------------------------------------------------
void __fastcall sub_14000A920(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4)
{
  _QWORD *v4; // r10
  __int64 v5; // rcx

  v4 = a1;
  if ( a3 == 2 )
  {
    v5 = *a1;
    if ( *(float *)(v5 + a4) > *(float *)(a4 + *(_QWORD *)a2) )
    {
      *v4 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v5;
      *(_QWORD *)*v4 = v5;
      *(_QWORD *)(*(_QWORD *)a2 + 8i64) = *v4;
    }
  }
  else if ( a3 > 2 )
  {
    JUMPOUT(loc_14000A982);
  }
}

//----- (000000014000AAC0) ----------------------------------------------------
void __fastcall sub_14000AAC0(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4)
{
  _QWORD *v4; // r10
  __int64 v5; // rcx

  v4 = a1;
  if ( a3 == 2 )
  {
    v5 = *a1;
    if ( *(_DWORD *)(v5 + a4) > *(_DWORD *)(a4 + *(_QWORD *)a2) )
    {
      *v4 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v5;
      *(_QWORD *)*v4 = v5;
      *(_QWORD *)(*(_QWORD *)a2 + 8i64) = *v4;
    }
  }
  else if ( a3 > 2 )
  {
    JUMPOUT(loc_14000AB1F);
  }
}

//----- (000000014000AC50) ----------------------------------------------------
void __fastcall sub_14000AC50(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4)
{
  _QWORD *v4; // r10
  __int64 v5; // rcx

  v4 = a1;
  if ( a3 == 2 )
  {
    v5 = *a1;
    if ( *(_QWORD *)(v5 + a4) > *(_QWORD *)(a4 + *(_QWORD *)a2) )
    {
      *v4 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v5;
      *(_QWORD *)*v4 = v5;
      *(_QWORD *)(*(_QWORD *)a2 + 8i64) = *v4;
    }
  }
  else if ( a3 > 2 )
  {
    JUMPOUT(loc_14000ACAF);
  }
}

//----- (000000014000ADE0) ----------------------------------------------------
void __fastcall sub_14000ADE0(_QWORD *a1, __int64 **a2, signed __int64 a3, __int64 a4)
{
  __int64 **v4; // rsi
  __int64 *v5; // rcx
  signed __int64 v6; // rcx
  signed __int64 v7; // rsi
  _QWORD *v8; // rax
  signed __int64 v9; // rdi
  _QWORD *v10; // rdx
  _QWORD *v11; // rax
  _QWORD *v12; // rcx
  __int64 *v13; // rbx
  _QWORD *v14; // [rsp+20h] [rbp-28h]
  __int64 v15; // [rsp+28h] [rbp-20h]
  _QWORD *v16; // [rsp+70h] [rbp+28h]
  __int64 **v17; // [rsp+78h] [rbp+30h]
  _QWORD *i; // [rsp+80h] [rbp+38h]
  __int64 v19; // [rsp+88h] [rbp+40h]

  v19 = a4;
  v17 = a2;
  v16 = a1;
  v4 = (__int64 **)a1;
  if ( a3 == 2 )
  {
    if ( (signed int)sub_14000B4C0(*(char **)(*a1 + a4), *(char **)((char *)*a2 + a4)) > 0 )
    {
      v5 = *v4;
      *v4 = *v17;
      *v17 = v5;
      **v4 = (__int64)v5;
      (*v17)[1] = (__int64)*v4;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = a3 / 2;
    v7 = a3 - a3 / 2;
    v8 = (_QWORD *)*v16;
    for ( i = (_QWORD *)*v16; v6; --v6 )
    {
      v8 = (_QWORD *)*v8;
      i = v8;
    }
    v9 = a3 / 2;
    v14 = (_QWORD *)v8[1];
    sub_14000ADE0(v16, &v14, a3 / 2);
    sub_14000ADE0(&i, v17, v7);
    v10 = v16;
    v11 = i;
    v12 = (_QWORD *)*v16;
    v13 = &v15;
    v14 = (_QWORD *)*v16;
    if ( v9 )
    {
      while ( v7 )
      {
        if ( (signed int)sub_14000B4C0(*(char **)((char *)v12 + v19), *(char **)((char *)v11 + v19)) > 0 )
        {
          --v7;
          *v13 = (__int64)i;
          i[1] = v13;
          v13 = i;
          v12 = v14;
          v11 = (_QWORD *)*i;
          i = (_QWORD *)*i;
        }
        else
        {
          --v9;
          *v13 = (__int64)v14;
          v14[1] = v13;
          v13 = v14;
          v11 = i;
          v12 = (_QWORD *)*v14;
          v14 = (_QWORD *)*v14;
        }
        if ( !v9 )
        {
          v10 = v16;
          goto LABEL_14;
        }
      }
      for ( ; v9; --v9 )
      {
        *v13 = (__int64)v12;
        v14[1] = v13;
        v13 = v14;
        v12 = (_QWORD *)*v14;
        v14 = (_QWORD *)*v14;
      }
      v10 = v16;
    }
    else
    {
LABEL_14:
      while ( v7 )
      {
        *v13 = (__int64)v11;
        i[1] = v13;
        v13 = i;
        v11 = (_QWORD *)*i;
        i = (_QWORD *)*i;
        --v7;
      }
    }
    *v10 = v15;
    *v17 = v13;
  }
}

//----- (000000014000AFB0) ----------------------------------------------------
void __fastcall sub_14000AFB0(_QWORD *a1, __int64 **a2, signed __int64 a3, __int64 a4)
{
  __int64 **v4; // rsi
  __int64 *v5; // rcx
  signed __int64 v6; // rcx
  signed __int64 v7; // rsi
  _QWORD *v8; // rax
  signed __int64 v9; // rdi
  _QWORD *v10; // rdx
  _QWORD *v11; // rax
  _QWORD *v12; // rcx
  __int64 *v13; // rbx
  _QWORD *v14; // [rsp+20h] [rbp-28h]
  __int64 v15; // [rsp+28h] [rbp-20h]
  _QWORD *v16; // [rsp+70h] [rbp+28h]
  __int64 **v17; // [rsp+78h] [rbp+30h]
  _QWORD *i; // [rsp+80h] [rbp+38h]
  __int64 v19; // [rsp+88h] [rbp+40h]

  v19 = a4;
  v17 = a2;
  v16 = a1;
  v4 = (__int64 **)a1;
  if ( a3 == 2 )
  {
    if ( (signed int)sub_14000B500(*(_QWORD *)(*a1 + a4), *(_WORD **)((char *)*a2 + a4)) > 0 )
    {
      v5 = *v4;
      *v4 = *v17;
      *v17 = v5;
      **v4 = (__int64)v5;
      (*v17)[1] = (__int64)*v4;
    }
  }
  else if ( a3 > 2 )
  {
    v6 = a3 / 2;
    v7 = a3 - a3 / 2;
    v8 = (_QWORD *)*v16;
    for ( i = (_QWORD *)*v16; v6; --v6 )
    {
      v8 = (_QWORD *)*v8;
      i = v8;
    }
    v9 = a3 / 2;
    v14 = (_QWORD *)v8[1];
    sub_14000AFB0(v16, &v14, a3 / 2);
    sub_14000AFB0(&i, v17, v7);
    v10 = v16;
    v11 = i;
    v12 = (_QWORD *)*v16;
    v13 = &v15;
    v14 = (_QWORD *)*v16;
    if ( v9 )
    {
      while ( v7 )
      {
        if ( (signed int)sub_14000B500(*(_QWORD *)((char *)v12 + v19), *(_WORD **)((char *)v11 + v19)) > 0 )
        {
          --v7;
          *v13 = (__int64)i;
          i[1] = v13;
          v13 = i;
          v12 = v14;
          v11 = (_QWORD *)*i;
          i = (_QWORD *)*i;
        }
        else
        {
          --v9;
          *v13 = (__int64)v14;
          v14[1] = v13;
          v13 = v14;
          v11 = i;
          v12 = (_QWORD *)*v14;
          v14 = (_QWORD *)*v14;
        }
        if ( !v9 )
        {
          v10 = v16;
          goto LABEL_14;
        }
      }
      for ( ; v9; --v9 )
      {
        *v13 = (__int64)v12;
        v14[1] = v13;
        v13 = v14;
        v12 = (_QWORD *)*v14;
        v14 = (_QWORD *)*v14;
      }
      v10 = v16;
    }
    else
    {
LABEL_14:
      while ( v7 )
      {
        *v13 = (__int64)v11;
        i[1] = v13;
        v13 = i;
        v11 = (_QWORD *)*i;
        i = (_QWORD *)*i;
        --v7;
      }
    }
    *v10 = v15;
    *v17 = v13;
  }
}

//----- (000000014000B180) ----------------------------------------------------
void __fastcall sub_14000B180(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4)
{
  _QWORD *v4; // r10
  __int64 v5; // rcx

  v4 = a1;
  if ( a3 == 2 )
  {
    v5 = *a1;
    if ( *(_WORD *)(v5 + a4) > *(_WORD *)(a4 + *(_QWORD *)a2) )
    {
      *v4 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v5;
      *(_QWORD *)*v4 = v5;
      *(_QWORD *)(*(_QWORD *)a2 + 8i64) = *v4;
    }
  }
  else if ( a3 > 2 )
  {
    JUMPOUT(loc_14000B1E1);
  }
}

//----- (000000014000B320) ----------------------------------------------------
void __fastcall sub_14000B320(_QWORD *a1, __int64 a2, signed __int64 a3, __int64 a4)
{
  _QWORD *v4; // r10
  __int64 v5; // rcx

  v4 = a1;
  if ( a3 == 2 )
  {
    v5 = *a1;
    if ( *(_WORD *)(v5 + a4) > *(_WORD *)(a4 + *(_QWORD *)a2) )
    {
      *v4 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v5;
      *(_QWORD *)*v4 = v5;
      *(_QWORD *)(*(_QWORD *)a2 + 8i64) = *v4;
    }
  }
  else if ( a3 > 2 )
  {
    JUMPOUT(loc_14000B381);
  }
}

//----- (000000014000B4C0) ----------------------------------------------------
signed __int64 __fastcall sub_14000B4C0(char *a1, char *a2)
{
  signed __int64 v2; // rdx
  unsigned __int16 v3; // ax
  signed __int64 result; // rax

  if ( a1 )
  {
    if ( a2 )
    {
      v2 = a2 - a1;
      while ( 1 )
      {
        v3 = *(_WORD *)a1;
        if ( *(_WORD *)a1 != *(_WORD *)&a1[v2] )
          break;
        a1 += 2;
        if ( !v3 )
          goto LABEL_6;
      }
      result = -(v3 < *(_WORD *)&a1[v2]) | 1u;
    }
    else
    {
      result = 1i64;
    }
  }
  else if ( a2 && *(_WORD *)a2 )
  {
    result = 0xFFFFFFFFi64;
  }
  else
  {
LABEL_6:
    result = 0i64;
  }
  return result;
}

//----- (000000014000B500) ----------------------------------------------------
signed __int64 __fastcall sub_14000B500(__int64 a1, _WORD *a2)
{
  signed __int64 result; // rax

  if ( a1 )
  {
    JUMPOUT(a2, 0i64, wcsicmp);
    result = 1i64;
  }
  else if ( a2 && *a2 )
  {
    result = 0xFFFFFFFFi64;
  }
  else
  {
    result = 0i64;
  }
  return result;
}

//----- (000000014000B528) ----------------------------------------------------
HRESULT sub_14000B528()
{
  int Dst; // [rsp+30h] [rbp+8h]
  int v2; // [rsp+34h] [rbp+Ch]

  Dst = 8;
  v2 = 2888;
  InitCommonControlsEx((const INITCOMMONCONTROLSEX *)&Dst);
  return CoInitialize(0i64);
}

//----- (000000014000B564) ----------------------------------------------------
__int64 __fastcall sub_14000B564(LPCWSTR lpCaption, LPCWSTR lpText, UINT uType)
{
  UINT v3; // esi
  const WCHAR *v4; // rbp
  const WCHAR *v5; // rdi
  HWND v6; // rbx
  __int64 v7; // rbx

  v3 = uType;
  v4 = lpText;
  v5 = lpCaption;
  v6 = sub_14000BE4C();
  sub_14000BF34(1);
  v7 = MessageBoxW(v6, v4, v5, v3);
  sub_14000BF34(0);
  return v7;
}

//----- (000000014000B5C8) ----------------------------------------------------
wchar_t *__fastcall sub_14000B5C8(wchar_t *Source)
{
  wchar_t *v1; // rbx
  size_t v2; // rax
  wchar_t *v3; // rax
  wchar_t *v4; // rdi

  v1 = Source;
  if ( !Source )
    return 0i64;
  v2 = wcslen(Source);
  v3 = (wchar_t *)HeapAlloc(hHeap, 0, 2 * v2 + 2);
  v4 = v3;
  if ( !v3 )
    return 0i64;
  wcscpy(v3, v1);
  return v4;
}

//----- (000000014000B61C) ----------------------------------------------------
BOOL __fastcall sub_14000B61C(LPVOID lpMem)
{
  BOOL result; // eax

  if ( lpMem )
    result = HeapFree(hHeap, 0, lpMem);
  return result;
}

//----- (000000014000B63C) ----------------------------------------------------
LRESULT __fastcall sub_14000B63C(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4)
{
  HWND v4; // rsi
  _QWORD *v6; // rdi
  int v7; // eax
  int v8; // ebx
  WCHAR *v9; // rax
  HWND v10; // rcx

  v4 = hWnd;
  if ( a2 == 2 )
  {
    UnregisterClassW(lpClassName, hModule);
    dword_140020648 = 1;
    return 0i64;
  }
  if ( a2 == 16 )
  {
LABEL_9:
    if ( dword_14002064C )
      EnableWindow(qword_140020668, 1);
    sub_14000BF34(0);
    DestroyWindow(v4);
    return 0i64;
  }
  if ( a2 != 273 )
    return DefWindowProcW(hWnd, a2, a3, a4);
  if ( (unsigned __int16)a3 == 1000 )
  {
    v6 = (_QWORD *)GetWindowLongPtrW(hWnd, -21);
    v7 = GetWindowTextLengthW(::hWnd);
    v8 = v7 + 1;
    v9 = (WCHAR *)HeapAlloc(hHeap, 0, 2i64 * (v7 + 1));
    v10 = ::hWnd;
    *v6 = v9;
    GetWindowTextW(v10, v9, v8);
    goto LABEL_9;
  }
  if ( (unsigned __int16)a3 == 1001 )
    goto LABEL_9;
  return 0i64;
}
// 140020648: using guessed type int dword_140020648;
// 14002064C: using guessed type int dword_14002064C;

//----- (000000014000B730) ----------------------------------------------------
int __fastcall sub_14000B730(wchar_t *a1, wchar_t *a2, wchar_t *a3)
{
  return sub_14000B748(a1, a2, a3, 0);
}

//----- (000000014000B748) ----------------------------------------------------
int __fastcall sub_14000B748(wchar_t *a1, wchar_t *a2, wchar_t *a3, char a4)
{
  char v4; // r12
  wchar_t *v5; // rdi
  wchar_t *v6; // rbx
  wchar_t *v7; // r14
  wchar_t *v8; // r15
  wchar_t *v9; // rsi
  HCURSOR v10; // rax
  HWND v11; // rdi
  int Y; // ebx
  int v13; // eax
  HWND v14; // rax
  HWND v15; // rdi
  signed int v16; // er9
  LPARAM v17; // rbx
  WPARAM v18; // rax
  HACCEL v19; // rbx
  int v20; // eax
  wchar_t *v21; // rax
  struct tagACCEL nHeight; // [rsp+38h] [rbp-61h]
  char v24; // [rsp+3Eh] [rbp-5Bh]
  HWND hWndParent; // [rsp+40h] [rbp-59h]
  WNDCLASSEXW v26; // [rsp+48h] [rbp-51h]
  struct tagMSG Msg; // [rsp+98h] [rbp-1h]
  LONG_PTR dwNewLong; // [rsp+F8h] [rbp+5Fh]
  void *retaddr; // [rsp+118h] [rbp+7Fh]

  v4 = a4;
  v5 = a3;
  dwNewLong = 0i64;
  v6 = a2;
  v7 = sub_14000B5C8(a1);
  v8 = sub_14000B5C8(v6);
  v9 = sub_14000B5C8(v5);
  if ( !wParam )
    wParam = (WPARAM)GetStockObject(17);
  v26.cbSize = 80;
  v26.style = 3;
  v26.hInstance = hModule;
  v26.lpfnWndProc = (WNDPROC)sub_14000B63C;
  *(_QWORD *)&v26.cbClsExtra = 0i64;
  v26.hIcon = LoadIconW(hModule, (LPCWSTR)1);
  v10 = LoadCursorW(0i64, (LPCWSTR)0x7F00);
  _mm_store_si128((__m128i *)&v26.hbrBackground, _mm_load_si128((const __m128i *)&xmmword_1400196F0));
  v26.hCursor = v10;
  v26.hIconSm = 0i64;
  v26.lpszClassName = lpClassName;
  RegisterClassExW(&v26);
  dword_140020648 = 0;
  qword_140020668 = sub_14000BE4C();
  sub_14000BF34(1);
  if ( qword_140020668 && IsWindowEnabled(qword_140020668) )
  {
    EnableWindow(qword_140020668, 0);
    dword_14002064C = 1;
  }
  else
  {
    dword_14002064C = 0;
  }
  v11 = sub_14000BE4C();
  Y = GetSystemMetrics(1) / 2 - 65;
  v13 = GetSystemMetrics(0);
  v14 = CreateWindowExW(0, lpClassName, v7, 0x10C80000u, v13 / 2 - 150, Y, 300, 130, v11, 0i64, hModule, 0i64);
  v15 = v14;
  if ( !v14 )
  {
LABEL_21:
    if ( dwNewLong )
      goto LABEL_23;
    goto LABEL_22;
  }
  SetWindowLongPtrW(v14, -21, (LONG_PTR)&dwNewLong);
  qword_140020660 = (__int64)CreateWindowExW(0, L"STATIC", v8, 0x5000000Bu, 10, 10, 280, 22, v15, 0i64, hModule, 0i64);
  SendMessageW((HWND)qword_140020660, 0x30u, wParam, 1i64);
  *(_QWORD *)&v26.cbClsExtra = 0i64;
  v26.lpfnWndProc = (WNDPROC)hModule;
  *(_QWORD *)&v26.cbSize = 10i64;
  hWndParent = v15;
  *(_DWORD *)&nHeight.fVirt = 21;
  v16 = 0;
  if ( v4 & 1 )
    v16 = 32;
  hWnd = CreateWindowExW(
           0x200u,
           L"EDIT",
           0i64,
           v16 | 0x50010080u,
           10,
           32,
           275,
           *(int *)&nHeight.fVirt,
           hWndParent,
           *(HMENU *)&v26.cbSize,
           (HINSTANCE)v26.lpfnWndProc,
           *(LPVOID *)&v26.cbClsExtra);
  SendMessageW(hWnd, 0x30u, wParam, 1i64);
  SetFocus(hWnd);
  if ( v9 )
  {
    SendMessageW(hWnd, 0xCu, 0i64, (LPARAM)v9);
    v17 = wcslen(v9);
    v18 = wcslen(v9);
    SendMessageW(hWnd, 0xB1u, v18, v17);
  }
  qword_140020650 = (__int64)CreateWindowExW(
                               0,
                               L"BUTTON",
                               L"OK",
                               0x50010001u,
                               110,
                               67,
                               80,
                               25,
                               v15,
                               (HMENU)0x3E8,
                               hModule,
                               0i64);
  SendMessageW((HWND)qword_140020650, 0x30u, wParam, 1i64);
  nHeight.fVirt = 1;
  *(_DWORD *)&nHeight.key = 65536013;
  v24 = 1;
  LODWORD(hWndParent) = 65601563;
  v19 = CreateAcceleratorTableW(&nHeight, 2);
  SetForegroundWindow(v15);
  BringWindowToTop(v15);
  while ( !dword_140020648 && GetMessageW(&Msg, 0i64, 0, 0) )
  {
    if ( !TranslateAcceleratorW(v15, v19, &Msg) )
    {
      TranslateMessage(&Msg);
      DispatchMessageW(&Msg);
    }
  }
  if ( v19 )
    DestroyAcceleratorTable(v19);
  if ( dwNewLong )
  {
    v20 = wcslen((const wchar_t *)dwNewLong);
    v21 = (wchar_t *)sub_140012E40(v20, (int)retaddr);
    wcscpy(v21, (const wchar_t *)dwNewLong);
    LODWORD(v14) = HeapFree(hHeap, 0, (LPVOID)dwNewLong);
    goto LABEL_21;
  }
LABEL_22:
  LODWORD(v14) = sub_140012F20((int)retaddr);
LABEL_23:
  if ( v7 )
    LODWORD(v14) = HeapFree(hHeap, 0, v7);
  if ( v8 )
    LODWORD(v14) = HeapFree(hHeap, 0, v8);
  if ( v9 )
    LODWORD(v14) = HeapFree(hHeap, 0, v9);
  return (signed int)v14;
}
// 1400196F0: using guessed type __int128 xmmword_1400196F0;
// 140020648: using guessed type int dword_140020648;
// 14002064C: using guessed type int dword_14002064C;
// 140020650: using guessed type __int64 qword_140020650;
// 140020660: using guessed type __int64 qword_140020660;

//----- (000000014000BBFC) ----------------------------------------------------
void sub_14000BBFC()
{
  if ( dword_14002064C )
    EnableWindow(qword_140020668, 1);
  sub_14000BF34(0);
}
// 14002064C: using guessed type int dword_14002064C;

//----- (000000014000BC28) ----------------------------------------------------
__int64 __fastcall sub_14000BC28(HWND hWnd, int a2, __int64 a3, LPARAM a4)
{
  LPARAM v4; // rbx
  HWND v5; // rdi

  v4 = a4;
  v5 = hWnd;
  if ( a2 == 1 && a4 )
  {
    SendMessageW(hWnd, 0x467u, 1ui64, a4);
    Sleep(0xC8u);
    PostMessageW(v5, 0x467u, 1ui64, v4);
  }
  return 0i64;
}

//----- (000000014000BC84) ----------------------------------------------------
__int64 __fastcall sub_14000BC84(__int64 a1, const wchar_t *a2, int a3)
{
  int v3; // er12
  const wchar_t *v4; // rsi
  __int64 v5; // r15
  int v6; // ebx
  HMODULE v7; // rax
  HMODULE v8; // r14
  FARPROC v9; // r13
  FARPROC v10; // rax
  const wchar_t *v11; // rdx
  __int64 v12; // rax
  void *v13; // r15
  wchar_t *v14; // rax
  const wchar_t *v15; // rsi
  int v16; // eax
  HWND Dst; // [rsp+20h] [rbp-B8h]
  __int64 v19; // [rsp+38h] [rbp-A0h]
  int v20; // [rsp+40h] [rbp-98h]
  __int64 (__fastcall *v21)(HWND, int, __int64, LPARAM); // [rsp+48h] [rbp-90h]
  wchar_t *v22; // [rsp+50h] [rbp-88h]
  __int16 v23; // [rsp+5Eh] [rbp-7Ah]
  wchar_t Dest; // [rsp+60h] [rbp-78h]
  __int16 v25; // [rsp+23Eh] [rbp+166h]
  void (__fastcall *vars0)(void *, wchar_t *); // [rsp+290h] [rbp+1B8h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !dword_140020670 )
  {
    dword_140020670 = 1;
    CoInitialize(0i64);
  }
  memset(&Dst, 0, 0x40ui64);
  v6 = 0;
  v7 = LoadLibraryW(L"SHELL32.DLL");
  v8 = v7;
  if ( !v7 )
    goto LABEL_17;
  v9 = GetProcAddress(v7, "SHBrowseForFolderW");
  v10 = GetProcAddress(v8, "SHGetPathFromIDListW");
  v11 = word_14001968C;
  if ( v4 )
    v11 = v4;
  vars0 = (void (__fastcall *)(void *, wchar_t *))v10;
  wcsncpy(&Dest, v11, 0x103ui64);
  v25 = 0;
  LODWORD(v12) = wcslen(&Dest);
  if ( (signed int)v12 > 3 )
  {
    v12 = (signed int)v12;
    if ( *(&v23 + (signed int)v12) == 92 )
      *(&v23 + v12) = 0;
  }
  v19 = v5;
  Dst = sub_14000BE4C();
  v20 = 80;
  v21 = sub_14000BC28;
  v22 = &Dest;
  sub_14000BF34(1);
  v13 = (void *)((__int64 (__fastcall *)(HWND *))v9)(&Dst);
  sub_14000BF34(0);
  if ( v13 )
  {
    v14 = (wchar_t *)sub_140012E40(260, v3);
    v15 = v14;
    *v14 = 0;
    vars0(v13, v14);
    CoTaskMemFree(v13);
    v16 = wcslen(v15);
    v6 = v16;
    if ( v15[v16 - 1] != 92 )
    {
      *(_DWORD *)&v15[v16] = 92;
      v6 = v16 + 1;
    }
  }
  FreeLibrary(v8);
  if ( !v6 )
LABEL_17:
    *(_WORD *)sub_140012E40(260, v3) = 0;
  return sub_140013010(260 - v6);
}
// 140020670: using guessed type int dword_140020670;

//----- (000000014000BE4C) ----------------------------------------------------
HWND sub_14000BE4C()
{
  HWND v0; // rax
  HWND v1; // rbx
  DWORD dwProcessId; // [rsp+30h] [rbp+8h]

  v0 = GetForegroundWindow();
  v1 = v0;
  if ( v0 )
  {
    GetWindowThreadProcessId(v0, &dwProcessId);
    if ( dwProcessId != GetCurrentProcessId() )
      v1 = 0i64;
  }
  return v1;
}

//----- (000000014000BE90) ----------------------------------------------------
signed __int64 __fastcall EnumFunc(HWND a1)
{
  HWND v1; // rdi
  DWORD v2; // ebx
  signed __int64 v3; // rbx
  DWORD v4; // eax

  v1 = a1;
  v2 = GetWindowThreadProcessId(a1, 0i64);
  if ( v2 == GetCurrentThreadId() && IsWindowVisible(v1) )
  {
    v3 = sub_140012400((__int64)&qword_140020678, 40);
    *(_QWORD *)(v3 + 8) = v1;
    v4 = GetCurrentThreadId();
    *(_WORD *)(v3 + 16) = 0;
    *(_DWORD *)v3 = v4;
    if ( GetWindowLongPtrW(v1, -20) & 8 )
      *(_BYTE *)(v3 + 16) = 1;
    if ( v1 != GetForegroundWindow() && IsWindowEnabled(v1) )
    {
      *(_BYTE *)(v3 + 17) = 1;
      EnableWindow(v1, 0);
    }
  }
  return 1i64;
}
// 140020678: using guessed type __int64 qword_140020678;

//----- (000000014000BF34) ----------------------------------------------------
void __fastcall sub_14000BF34(int a1)
{
  __int64 v1; // rbx
  __int64 v2; // rdi
  __int64 v3; // rbx
  __int64 v4; // rdi

  if ( a1 )
  {
    EnumWindows((WNDENUMPROC)EnumFunc, a1);
    v1 = qword_140020678;
    if ( qword_140020678 )
    {
      do
      {
        v2 = *(_QWORD *)v1;
        if ( *(_DWORD *)(v1 + 16) == GetCurrentThreadId() )
        {
          if ( *(_BYTE *)(v1 + 32) )
            SetWindowPos(*(HWND *)(v1 + 24), (HWND)0xFFFFFFFFFFFFFFFEi64, 0, 0, 0, 0, 3u);
        }
        v1 = v2;
      }
      while ( v2 );
    }
  }
  else
  {
    v3 = qword_140020678;
    if ( qword_140020678 )
    {
      do
      {
        v4 = *(_QWORD *)v3;
        if ( *(_DWORD *)(v3 + 16) == GetCurrentThreadId() )
        {
          if ( *(_BYTE *)(v3 + 33) )
            EnableWindow(*(HWND *)(v3 + 24), 1);
          if ( *(_BYTE *)(v3 + 32) )
            SetWindowPos(*(HWND *)(v3 + 24), HWND_MESSAGE|0x2, 0, 0, 0, 0, 3u);
          sub_1400123B8((__int64 **)&qword_140020678, v3 + 16);
        }
        v3 = v4;
      }
      while ( v4 );
    }
  }
}
// 140020678: using guessed type __int64 qword_140020678;

//----- (000000014000C030) ----------------------------------------------------
void __fastcall sub_14000C030(_QWORD *a1)
{
  __int64 v1; // rbx
  HANDLE *v2; // rax

  v1 = (__int64)a1;
  v2 = (HANDLE *)sub_140011998(qword_140021250, a1);
  if ( v2 )
  {
    CloseHandle(*v2);
    sub_14001192C((signed int *)qword_140021250, v1);
  }
}
// 140021250: using guessed type __int64 qword_140021250;

//----- (000000014000C06C) ----------------------------------------------------
void sub_14000C06C()
{
  qword_140021260 = sub_14001182C(24, 0i64, 0i64);
  qword_140021250 = (__int64)sub_140011AC0(8, 4, (__int64)sub_14000C030);
  InitializeCriticalSection(&stru_140021270);
}
// 140021250: using guessed type __int64 qword_140021250;
// 140021260: using guessed type __int64 qword_140021260;

//----- (000000014000C0B4) ----------------------------------------------------
__int64 __fastcall sub_14000C0B4(int a1)
{
  WCHAR *v1; // rsi
  signed int v2; // ebx
  __int64 result; // rax

  v1 = (WCHAR *)sub_140012E40(260, a1);
  v2 = GetModuleFileNameW(hModule, v1, 0x104u);
  if ( !wcscmp(v1, L"\\\\?\\") )
  {
    v2 -= 4;
    memmove(v1, v1 + 4, 2i64 * v2);
  }
  sub_140013010(260 - v2);
  result = v2;
  v1[v2] = 0;
  return result;
}

//----- (000000014000C178) ----------------------------------------------------
LPWSTR __fastcall sub_14000C178(_DWORD *a1)
{
  _DWORD *v1; // rdi
  signed int v2; // esi
  char *v3; // r14
  WCHAR *v4; // rbx
  LPWSTR result; // rax
  WCHAR v6; // dx
  LPWSTR v7; // rcx
  WCHAR v8; // dx
  signed int v9; // er8
  WCHAR v10; // cx
  WCHAR v11; // cx
  WCHAR *v12; // [rsp+40h] [rbp+8h]

  v1 = a1;
  v2 = -1;
  v3 = sub_140011794(qword_140021260);
  v4 = 0i64;
  result = GetCommandLineW();
  v6 = *result;
  if ( !*result )
  {
LABEL_27:
    if ( !v1 )
      return (LPWSTR)v2;
    goto LABEL_31;
  }
  v7 = v12;
  while ( 1 )
  {
    if ( v6 == 32 )
    {
      do
        ++result;
      while ( *result == 32 );
    }
    v8 = *result;
    v9 = 1;
    if ( *result == 34 )
    {
      ++result;
      v4 = result;
      v10 = *result;
      if ( !*result )
        goto LABEL_20;
      do
      {
        if ( v10 == 34 )
          break;
        ++result;
        v10 = *result;
      }
      while ( *result );
    }
    else
    {
      if ( !v8 )
      {
        v9 = 0;
        goto LABEL_22;
      }
      v4 = result;
      do
      {
        if ( v8 == 32 )
          break;
        ++result;
        if ( *result == 34 )
        {
          ++result;
          v11 = *result;
          if ( !*result )
            goto LABEL_20;
          do
          {
            if ( v11 == 34 )
              break;
            ++result;
            v11 = *result;
          }
          while ( *result );
        }
        v8 = *result;
      }
      while ( *result );
    }
    if ( !*result )
    {
LABEL_20:
      v7 = result;
      goto LABEL_22;
    }
    v7 = result;
    ++result;
LABEL_22:
    if ( *(_DWORD *)v3 == v2 )
    {
      if ( v1 )
        break;
    }
    if ( v9 )
      ++v2;
    v6 = *result;
    v4 = 0i64;
    if ( !*result )
      goto LABEL_27;
  }
  if ( v4 )
  {
    result = v4;
    *v1 = v7 - v4;
    ++*(_DWORD *)v3;
    return result;
  }
LABEL_31:
  *v1 = 0;
  return result;
}
// 140021260: using guessed type __int64 qword_140021260;

//----- (000000014000C2AC) ----------------------------------------------------
LPWSTR sub_14000C2AC()
{
  sub_140011794(qword_140021260);
  return sub_14000C178(0i64);
}
// 140021260: using guessed type __int64 qword_140021260;

//----- (000000014000C2C8) ----------------------------------------------------
__int64 __fastcall sub_14000C2C8(int a1)
{
  int v1; // ebx
  LPWSTR v2; // rax
  int v3; // esi
  LPWSTR v4; // rdi
  _WORD *v5; // rax
  int v6; // ecx
  int v8; // [rsp+38h] [rbp+10h]

  v1 = a1;
  v8 = 0;
  v2 = sub_14000C178(&v8);
  v3 = v8;
  v4 = v2;
  v5 = (_WORD *)sub_140012E40(v8, v1);
  v6 = 0;
  while ( *v4 && v3 )
  {
    if ( *v4 == 34 )
    {
      ++v6;
    }
    else
    {
      *v5 = *v4;
      ++v5;
    }
    ++v4;
    --v3;
  }
  *v5 = 0;
  return sub_140013010(v6);
}

//----- (000000014000C340) ----------------------------------------------------
__int64 __fastcall sub_14000C340(int a1, int a2)
{
  int v2; // ebx
  int v3; // esi
  char *v4; // rax
  LPWSTR v5; // rax
  int v6; // edi
  LPWSTR v7; // rbx
  _WORD *v8; // rax
  int v9; // ecx
  int v11; // [rsp+30h] [rbp+8h]

  v2 = a1;
  v3 = a2;
  v11 = 0;
  v4 = sub_140011794(qword_140021260);
  if ( v2 >= 0 )
    *(_DWORD *)v4 = v2;
  v5 = sub_14000C178(&v11);
  v6 = v11;
  v7 = v5;
  v8 = (_WORD *)sub_140012E40(v11, v3);
  v9 = 0;
  while ( *v7 && v6 )
  {
    if ( *v7 == 34 )
    {
      ++v9;
    }
    else
    {
      *v8 = *v7;
      ++v8;
    }
    ++v7;
    --v6;
  }
  *v8 = 0;
  return sub_140013010(v9);
}
// 140021260: using guessed type __int64 qword_140021260;

//----- (000000014000C3CC) ----------------------------------------------------
__int64 __fastcall sub_14000C3CC(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rdi

  v1 = a1;
  v2 = 0i64;
  EnterCriticalSection(&stru_140021270);
  if ( sub_140012444((_QWORD *)qword_140020680, v1) )
    v2 = v1;
  LeaveCriticalSection(&stru_140021270);
  return v2;
}
// 140020680: using guessed type __int64 qword_140020680;

//----- (000000014000C41C) ----------------------------------------------------
signed __int64 __fastcall sub_14000C41C(HANDLE *a1)
{
  HANDLE *v1; // rdi
  __int64 v2; // rbx
  HANDLE v3; // rcx
  DWORD TotalBytesAvail; // [rsp+40h] [rbp+8h]

  v1 = a1;
  v2 = 0i64;
  if ( WaitForSingleObject(*a1, 0) )
    return 1i64;
  v3 = v1[3];
  if ( !v3 )
    return 0i64;
  TotalBytesAvail = 0;
  PeekNamedPipe(v3, 0i64, 0, 0i64, &TotalBytesAvail, 0i64);
  LOBYTE(v2) = TotalBytesAvail != 0;
  return v2;
}

//----- (000000014000C484) ----------------------------------------------------
BOOL __fastcall sub_14000C484(HANDLE *a1)
{
  return TerminateProcess(*a1, 0xFFFFFFFF);
}

//----- (000000014000C494) ----------------------------------------------------
void __fastcall sub_14000C494(HANDLE *a1)
{
  HANDLE *v1; // rbx
  HANDLE v2; // rcx
  HANDLE v3; // rcx
  HANDLE v4; // rcx

  v1 = a1;
  CloseHandle(*a1);
  v2 = v1[2];
  if ( v2 )
    CloseHandle(v2);
  v3 = v1[3];
  if ( v3 )
    CloseHandle(v3);
  v4 = v1[4];
  if ( v4 )
    CloseHandle(v4);
  EnterCriticalSection(&stru_140021270);
  sub_1400123B8((__int64 **)&qword_140020680, (__int64)v1);
  LeaveCriticalSection(&stru_140021270);
}
// 140020680: using guessed type __int64 qword_140020680;

//----- (000000014000C504) ----------------------------------------------------
DWORD __fastcall sub_14000C504(LPCWSTR lpName, int a2)
{
  int v2; // ebx
  const WCHAR *v3; // rsi
  int v4; // edi
  WCHAR *v5; // rbx
  DWORD result; // eax

  v2 = a2;
  v3 = lpName;
  v4 = GetEnvironmentVariableW(lpName, 0i64, 0);
  if ( v4 )
    --v4;
  v5 = (WCHAR *)sub_140012E40(v4, v2);
  result = GetEnvironmentVariableW(v3, v5, v4 + 1);
  v5[v4] = 0;
  return result;
}

//----- (000000014000C56C) ----------------------------------------------------
BOOL __fastcall sub_14000C56C(const WCHAR *a1)
{
  BOOL result; // eax

  if ( a1 )
    result = SetEnvironmentVariableW(a1, 0i64);
  return result;
}

//----- (000000014000C584) ----------------------------------------------------
int __fastcall sub_14000C584(const WCHAR *a1, const WCHAR *a2)
{
  const WCHAR *v2; // rax
  const WCHAR *v3; // rdx

  v2 = a2;
  if ( a1 )
  {
    v3 = word_14001968C;
    if ( v2 )
      v3 = v2;
    LODWORD(v2) = SetEnvironmentVariableW(a1, v3);
  }
  return (signed int)v2;
}

//----- (000000014000C5AC) ----------------------------------------------------
int __fastcall sub_14000C5AC(HANDLE *a1)
{
  HANDLE *v1; // rdi
  HANDLE v2; // rbx
  HANDLE v3; // rax
  int result; // eax
  HANDLE TargetHandle; // [rsp+58h] [rbp+10h]

  v1 = a1;
  v2 = GetCurrentProcess();
  v3 = GetCurrentProcess();
  result = DuplicateHandle(v3, *v1, v2, &TargetHandle, 0, 0, 2u);
  if ( result )
  {
    CloseHandle(*v1);
    result = (signed int)TargetHandle;
    *v1 = TargetHandle;
  }
  return result;
}

//----- (000000014000C610) ----------------------------------------------------
signed __int64 __fastcall sub_14000C610(wchar_t *a1)
{
  return sub_14000C660(a1, word_14001968C, word_14001968C, 0, 0i64);
}

//----- (000000014000C634) ----------------------------------------------------
signed __int64 __fastcall sub_14000C634(wchar_t *a1, const wchar_t *a2, const WCHAR *a3)
{
  return sub_14000C660(a1, a2, a3, 0, 0i64);
}

//----- (000000014000C64C) ----------------------------------------------------
signed __int64 __fastcall sub_14000C64C(wchar_t *a1, const wchar_t *a2, const WCHAR *a3, int a4)
{
  return sub_14000C660(a1, a2, a3, a4, 0i64);
}

//----- (000000014000C660) ----------------------------------------------------
signed __int64 __fastcall sub_14000C660(wchar_t *a1, const wchar_t *a2, const WCHAR *a3, int a4, __int64 a5)
{
  signed __int64 v5; // rdi
  unsigned __int64 lpCurrentDirectory; // r13
  const wchar_t *v7; // rbx
  int v8; // er14
  DWORD dwCreationFlags; // er12
  HANDLE v10; // rcx
  const wchar_t *v11; // r15
  const wchar_t *v12; // rsi
  size_t v13; // rbx
  size_t v14; // rax
  wchar_t *v15; // r15
  HANDLE v16; // rax
  HANDLE v17; // rcx
  const wchar_t *v18; // rbx
  signed __int64 v19; // rbx
  HANDLE v20; // rcx
  HANDLE v22; // [rsp+50h] [rbp-B0h]
  HANDLE v23; // [rsp+58h] [rbp-A8h]
  HANDLE v24; // [rsp+60h] [rbp-A0h]
  HANDLE hReadPipe; // [rsp+68h] [rbp-98h]
  HANDLE hWritePipe; // [rsp+70h] [rbp-90h]
  struct _SECURITY_ATTRIBUTES PipeAttributes; // [rsp+78h] [rbp-88h]
  struct _PROCESS_INFORMATION ProcessInformation; // [rsp+90h] [rbp-70h]
  int Dst; // [rsp+B0h] [rbp-50h]
  int v30; // [rsp+ECh] [rbp-14h]
  unsigned __int16 v31; // [rsp+F0h] [rbp-10h]
  HANDLE v32; // [rsp+100h] [rbp+0h]
  HANDLE v33; // [rsp+108h] [rbp+8h]
  HANDLE v34; // [rsp+110h] [rbp+10h]
  SHELLEXECUTEINFOW pExecInfo; // [rsp+120h] [rbp+20h]
  wchar_t *Str; // [rsp+1E0h] [rbp+E0h]
  wchar_t *Stra; // [rsp+1E0h] [rbp+E0h]
  HANDLE hObject; // [rsp+1F0h] [rbp+F0h]
  BOOL bInheritHandles; // [rsp+1F8h] [rbp+F8h]

  Str = a1;
  v5 = 0i64;
  lpCurrentDirectory = (unsigned __int64)a3;
  v7 = a2;
  v8 = a4;
  dwCreationFlags = 32;
  hReadPipe = 0i64;
  hWritePipe = 0i64;
  v23 = 0i64;
  hObject = 0i64;
  v22 = 0i64;
  v24 = 0i64;
  bInheritHandles = 0;
  PipeAttributes.nLength = 24;
  PipeAttributes.lpSecurityDescriptor = 0i64;
  PipeAttributes.bInheritHandle = 1;
  memset(&Dst, 0, 0x68ui64);
  Dst = 104;
  v30 = 1;
  if ( v8 & 2 )
  {
    v31 = 0;
    dwCreationFlags = 48;
  }
  else
  {
    v31 = 1;
  }
  if ( v8 & 0x40 )
  {
    if ( a5 )
    {
      v10 = *(HANDLE *)(a5 + 24);
      if ( v10 )
      {
        v30 = 257;
        v32 = v10;
LABEL_12:
        bInheritHandles = 1;
        dwCreationFlags &= 0xFFFFFFEF;
        goto LABEL_13;
      }
    }
  }
  if ( v8 & 4 && v8 & 0x10 && CreatePipe(&hReadPipe, &hWritePipe, &PipeAttributes, 0) )
  {
    v30 |= 0x100u;
    v32 = hReadPipe;
    sub_14000C5AC(&hWritePipe);
    goto LABEL_12;
  }
LABEL_13:
  if ( v8 & 4 )
  {
    if ( v8 & 8 && CreatePipe(&v23, &hObject, &PipeAttributes, 0) )
    {
      v30 |= 0x100u;
      v33 = hObject;
      sub_14000C5AC(&v23);
      dwCreationFlags &= 0xFFFFFFEF;
      bInheritHandles = 1;
    }
    if ( v8 & 0x20 && CreatePipe(&v22, &v24, &PipeAttributes, 0) )
    {
      v30 |= 0x100u;
      v34 = v24;
      sub_14000C5AC(&v22);
      dwCreationFlags &= 0xFFFFFFEF;
      bInheritHandles = 1;
    }
  }
  if ( v30 & 0x100 )
  {
    if ( !v32 )
      v32 = GetStdHandle(0xFFFFFFF6);
    if ( !v33 )
      v33 = GetStdHandle(0xFFFFFFF5);
    if ( !v34 )
      v34 = GetStdHandle(0xFFFFFFF4);
  }
  v11 = word_14001968C;
  v12 = word_14001968C;
  if ( Str )
    v12 = Str;
  if ( v7 )
    v11 = v7;
  Stra = (wchar_t *)v11;
  v13 = wcslen(v12);
  v14 = wcslen(v11);
  v15 = (wchar_t *)HeapAlloc(hHeap, 0, 2 * (v14 + v13) + 8);
  if ( *v12 == 34 )
  {
    wcscpy(v15, v12);
  }
  else
  {
    wcscpy(v15, L"\"");
    wcscat(v15, v12);
    wcscat(v15, L"\"");
  }
  if ( *Stra )
  {
    wcscat(v15, &word_140019690);
    wcscat(v15, Stra);
  }
  if ( lpCurrentDirectory )
    lpCurrentDirectory &= -(signed __int64)(*(_WORD *)lpCurrentDirectory != 0);
  if ( CreateProcessW(
         0i64,
         v15,
         0i64,
         0i64,
         bInheritHandles,
         dwCreationFlags,
         0i64,
         (LPCWSTR)lpCurrentDirectory,
         (LPSTARTUPINFOW)&Dst,
         &ProcessInformation) )
  {
    if ( hObject )
      CloseHandle(hObject);
    if ( hReadPipe )
      CloseHandle(hReadPipe);
    if ( v24 )
      CloseHandle(v24);
    CloseHandle(ProcessInformation.hThread);
    if ( v8 & 1 )
      WaitForSingleObject(ProcessInformation.hProcess, 0xFFFFFFFF);
    if ( v8 & 4 )
    {
      EnterCriticalSection(&stru_140021270);
      v5 = sub_140012400((__int64)&qword_140020680, 64);
      LeaveCriticalSection(&stru_140021270);
      *(_QWORD *)v5 = ProcessInformation.hProcess;
      *(_DWORD *)(v5 + 8) = ProcessInformation.dwProcessId;
      *(_QWORD *)(v5 + 24) = v23;
      *(_QWORD *)(v5 + 16) = hWritePipe;
      v16 = v22;
      *(_DWORD *)(v5 + 40) = v8;
      *(_QWORD *)(v5 + 32) = v16;
      goto LABEL_76;
    }
    v17 = ProcessInformation.hProcess;
LABEL_75:
    CloseHandle(v17);
    v5 = 1i64;
    goto LABEL_76;
  }
  if ( hObject )
    CloseHandle(hObject);
  if ( v23 )
    CloseHandle(v23);
  if ( hWritePipe )
    CloseHandle(hWritePipe);
  if ( hReadPipe )
    CloseHandle(hReadPipe);
  if ( v24 )
    CloseHandle(v24);
  if ( v22 )
    CloseHandle(v22);
  if ( !(v8 & 0x78) )
  {
    if ( !lpCurrentDirectory )
    {
      v18 = &v12[wcslen(v12) - 1];
      if ( v18 > v12 )
      {
        do
        {
          if ( *v18 == 92 )
            break;
          --v18;
        }
        while ( v18 > v12 );
        if ( v18 > v12 )
        {
          wcscpy(v15, v12);
          lpCurrentDirectory = (unsigned __int64)v15;
          v15[v18 - v12 + 1] = 0;
        }
      }
    }
    memset(&pExecInfo, 0, 0x70ui64);
    pExecInfo.nShow = v31;
    pExecInfo.cbSize = 112;
    pExecInfo.fMask = 1344;
    pExecInfo.lpVerb = 0i64;
    pExecInfo.lpDirectory = (LPCWSTR)lpCurrentDirectory;
    pExecInfo.lpParameters = Stra;
    pExecInfo.lpFile = v12;
    if ( ShellExecuteExW(&pExecInfo) )
    {
      if ( v8 & 1 )
        WaitForSingleObject(pExecInfo.hProcess, 0xFFFFFFFF);
      if ( v8 & 4 )
      {
        EnterCriticalSection(&stru_140021270);
        v19 = sub_140012400((__int64)&qword_140020680, 64);
        LeaveCriticalSection(&stru_140021270);
        v20 = pExecInfo.hProcess;
        *(_DWORD *)(v19 + 8) = -1;
        *(_QWORD *)(v19 + 24) = 0i64;
        *(_QWORD *)(v19 + 16) = 0i64;
        *(_QWORD *)(v19 + 32) = 0i64;
        *(_QWORD *)v19 = v20;
        *(_DWORD *)(v19 + 40) = v8;
        v5 = v19;
        goto LABEL_76;
      }
      v17 = pExecInfo.hProcess;
      goto LABEL_75;
    }
  }
LABEL_76:
  HeapFree(hHeap, 0, v15);
  return v5;
}
// 140020680: using guessed type __int64 qword_140020680;

//----- (000000014000CBBC) ----------------------------------------------------
__int64 __fastcall sub_14000CBBC(void **a1)
{
  void *v1; // rcx
  DWORD ExitCode; // [rsp+30h] [rbp+8h]

  v1 = *a1;
  ExitCode = 0;
  GetExitCodeProcess(v1, &ExitCode);
  return (signed int)ExitCode;
}

//----- (000000014000CBE0) ----------------------------------------------------
__int64 __fastcall Handler(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  HANDLE v1; // rax

  if ( (unsigned int)sub_14000CE30((__int64)ExceptionInfo) )
  {
    if ( qword_140020690 )
      qword_140020690();
    dword_14001F120 = -1;
    v1 = GetCurrentProcess();
    TerminateProcess(v1, 0);
  }
  return 0i64;
}
// 14001F120: using guessed type int dword_14001F120;
// 140020690: using guessed type __int64 (*qword_140020690)(void);

//----- (000000014000CC20) ----------------------------------------------------
void __fastcall sub_14000CC20(__int64 (*a1)(void))
{
  qword_140020690 = a1;
  sub_14000CFE0((PVECTORED_EXCEPTION_HANDLER)Handler);
}
// 140020690: using guessed type __int64 (*qword_140020690)(void);

//----- (000000014000CC40) ----------------------------------------------------
unsigned __int64 __fastcall sub_14000CC40(__int64 a1)
{
  M128A *v1; // rdx
  struct _CONTEXT *v2; // rax
  signed __int64 v3; // rcx
  M128A v4; // xmm0
  DWORD64 v5; // rbx
  PRUNTIME_FUNCTION v6; // rcx
  __int64 v7; // rax
  struct _CONTEXT ContextRecord; // [rsp+40h] [rbp-4D8h]
  unsigned __int64 ImageBase; // [rsp+520h] [rbp+8h]
  unsigned __int64 EstablisherFrame; // [rsp+528h] [rbp+10h]
  PVOID HandlerData; // [rsp+530h] [rbp+18h]

  v1 = *(M128A **)(a1 + 8);
  v2 = &ContextRecord;
  v3 = 9i64;
  do
  {
    v4 = *v1;
    v2 = (struct _CONTEXT *)((char *)v2 + 128);
    v1 += 8;
    v2[-1].VectorRegister[21] = v4;
    v2[-1].VectorRegister[22] = v1[-7];
    v2[-1].VectorRegister[23] = v1[-6];
    v2[-1].VectorRegister[24] = v1[-5];
    v2[-1].VectorRegister[25] = v1[-4];
    *(M128A *)&v2[-1].VectorControl = v1[-3];
    *(M128A *)&v2[-1].LastBranchToRip = v1[-2];
    *(M128A *)&v2[-1].LastExceptionToRip = v1[-1];
    --v3;
  }
  while ( v3 );
  *(M128A *)&v2->P1Home = *v1;
  *(M128A *)&v2->P3Home = v1[1];
  *(M128A *)&v2->P5Home = v1[2];
  *(M128A *)&v2->ContextFlags = v1[3];
  *(M128A *)&v2->SegGs = v1[4];
  v5 = ContextRecord.Rip;
  v6 = RtlLookupFunctionEntry(ContextRecord.Rip, &ImageBase, 0i64);
  if ( !v6 )
  {
    v5 = *(_QWORD *)ContextRecord.Rsp;
    ContextRecord.Rip = *(_QWORD *)ContextRecord.Rsp;
    ContextRecord.Rsp += 8i64;
    v6 = RtlLookupFunctionEntry(ContextRecord.Rip, &ImageBase, 0i64);
    if ( !v6 )
      return 0i64;
  }
  while ( 1 )
  {
    v7 = v6->UnwindData;
    if ( (_DWORD)v7 )
    {
      if ( *(_BYTE *)(v7 + ImageBase) & 8 && *(_DWORD *)(v7 + ImageBase + 8) )
        break;
    }
    RtlVirtualUnwind(0, ImageBase, v5, v6, &ContextRecord, &HandlerData, &EstablisherFrame, 0i64);
    if ( ContextRecord.Rip )
    {
      if ( ContextRecord.Rip != v5 )
      {
        v5 = ContextRecord.Rip;
        v6 = RtlLookupFunctionEntry(ContextRecord.Rip, &ImageBase, 0i64);
        if ( v6 )
          continue;
      }
    }
    return 0i64;
  }
  return ImageBase + *(unsigned int *)(v7 + ImageBase + 8);
}

//----- (000000014000CE00) ----------------------------------------------------
ULONG sub_14000CE00()
{
  ULONG result; // eax

  if ( Handle )
  {
    result = RemoveVectoredExceptionHandler(Handle);
    Handle = 0i64;
  }
  return result;
}

//----- (000000014000CE30) ----------------------------------------------------
signed __int64 __fastcall sub_14000CE30(__int64 a1)
{
  int **v1; // rbx
  signed __int64 result; // rax
  __int64 v3; // rcx
  int *v4; // rax

  v1 = (int **)a1;
  if ( sub_14000CC40(a1) )
    return 0i64;
  if ( dword_140020698 )
    dword_140020698 = 0;
  else
    dword_14001F120 = **v1;
  v3 = *((_QWORD *)*v1 + 2);
  dword_1400212A0 = dword_14001F001;
  qword_1400212B0 = v3;
  v4 = *v1;
  if ( **v1 != -1073741819 || (unsigned int)v4[6] < 2 )
    qword_1400212C0 = 0i64;
  else
    qword_1400212C0 = *((_QWORD *)v4 + 5);
  qword_1400212D0 = *((_QWORD *)v1[1] + 15);
  qword_1400212D8 = *((_QWORD *)v1[1] + 16);
  qword_1400212E0 = *((_QWORD *)v1[1] + 17);
  qword_1400212E8 = *((_QWORD *)v1[1] + 18);
  qword_1400212F0 = *((_QWORD *)v1[1] + 19);
  qword_1400212F8 = *((_QWORD *)v1[1] + 20);
  qword_140021300 = *((_QWORD *)v1[1] + 21);
  qword_140021308 = *((_QWORD *)v1[1] + 22);
  qword_140021310 = *((_QWORD *)v1[1] + 23);
  qword_140021318 = *((_QWORD *)v1[1] + 24);
  qword_140021320 = *((_QWORD *)v1[1] + 25);
  qword_140021328 = *((_QWORD *)v1[1] + 26);
  qword_140021330 = *((_QWORD *)v1[1] + 27);
  qword_140021338 = *((_QWORD *)v1[1] + 28);
  qword_140021340 = *((_QWORD *)v1[1] + 29);
  qword_140021348 = *((_QWORD *)v1[1] + 30);
  result = 1i64;
  qword_140021350 = (unsigned int)v1[1][17];
  return result;
}
// 14001F001: using guessed type int dword_14001F001;
// 14001F120: using guessed type int dword_14001F120;
// 140020698: using guessed type int dword_140020698;
// 1400212A0: using guessed type int dword_1400212A0;
// 1400212B0: using guessed type __int64 qword_1400212B0;
// 1400212C0: using guessed type __int64 qword_1400212C0;
// 1400212D0: using guessed type __int64 qword_1400212D0;
// 1400212D8: using guessed type __int64 qword_1400212D8;
// 1400212E0: using guessed type __int64 qword_1400212E0;
// 1400212E8: using guessed type __int64 qword_1400212E8;
// 1400212F0: using guessed type __int64 qword_1400212F0;
// 1400212F8: using guessed type __int64 qword_1400212F8;
// 140021300: using guessed type __int64 qword_140021300;
// 140021308: using guessed type __int64 qword_140021308;
// 140021310: using guessed type __int64 qword_140021310;
// 140021318: using guessed type __int64 qword_140021318;
// 140021320: using guessed type __int64 qword_140021320;
// 140021328: using guessed type __int64 qword_140021328;
// 140021330: using guessed type __int64 qword_140021330;
// 140021338: using guessed type __int64 qword_140021338;
// 140021340: using guessed type __int64 qword_140021340;
// 140021348: using guessed type __int64 qword_140021348;
// 140021350: using guessed type __int64 qword_140021350;

//----- (000000014000CFE0) ----------------------------------------------------
void __fastcall sub_14000CFE0(PVECTORED_EXCEPTION_HANDLER Handler)
{
  LONG (__stdcall *v1)(struct _EXCEPTION_POINTERS *); // rbx

  v1 = Handler;
  if ( Handle )
  {
    RemoveVectoredExceptionHandler(Handle);
    Handle = 0i64;
  }
  if ( v1 )
    Handle = AddVectoredExceptionHandler(0, v1);
}

//----- (000000014000D030) ----------------------------------------------------
__int64 __fastcall sub_14000D030(int a1)
{
  return sub_14000D040(dword_14001F120, a1);
}
// 14001F120: using guessed type int dword_14001F120;

//----- (000000014000D040) ----------------------------------------------------
__int64 __fastcall sub_14000D040(int a1, int a2)
{
  const wchar_t *v2; // rbx
  int v3; // er8
  _DWORD *v4; // r9
  signed __int64 v5; // rcx
  __int64 result; // rax
  wchar_t v7; // cx

  v2 = L"Unknown error code";
  v3 = 0;
  v4 = qword_140019760;
  while ( *v4 != a1 )
  {
    ++v3;
    v4 += 4;
    if ( (unsigned __int64)v3 >= 0x14 )
      goto LABEL_6;
  }
  v2 = (const wchar_t *)qword_140019760[2 * v3 + 1];
LABEL_6:
  v5 = -1i64;
  do
    ++v5;
  while ( v2[v5] );
  result = sub_140012E40(v5, a2) - (_QWORD)v2;
  do
  {
    v7 = *v2;
    ++v2;
    *(const wchar_t *)((char *)v2 + result - 2) = v7;
  }
  while ( v7 );
  return result;
}
// 140019DB0: using guessed type wchar_t aUnknownErrorCo[19];

//----- (000000014000D0C0) ----------------------------------------------------
BOOL sub_14000D0C0()
{
  return HeapDestroy((HANDLE)qword_140021360);
}
// 140021360: using guessed type __int64 qword_140021360;

//----- (000000014000D0D0) ----------------------------------------------------
HANDLE sub_14000D0D0()
{
  HANDLE result; // rax

  result = HeapCreate(0, 0x1000ui64, 0i64);
  qword_140021360 = (__int64)result;
  return result;
}
// 140021360: using guessed type __int64 qword_140021360;

//----- (000000014000D0F0) ----------------------------------------------------
SIZE_T __fastcall sub_14000D0F0(const void *a1)
{
  SIZE_T result; // rax

  if ( a1 )
    result = HeapSize((HANDLE)qword_140021360, 0, a1);
  else
    result = 0i64;
  return result;
}
// 140021360: using guessed type __int64 qword_140021360;

//----- (000000014000D110) ----------------------------------------------------
BOOL __fastcall sub_14000D110(void *a1)
{
  return HeapFree((HANDLE)qword_140021360, 0, a1);
}
// 140021360: using guessed type __int64 qword_140021360;

//----- (000000014000D130) ----------------------------------------------------
LPVOID __fastcall sub_14000D130(signed __int64 a1)
{
  LPVOID result; // rax

  if ( a1 <= 0 )
    result = 0i64;
  else
    result = HeapAlloc((HANDLE)qword_140021360, 8u, a1);
  return result;
}
// 140021360: using guessed type __int64 qword_140021360;

//----- (000000014000D150) ----------------------------------------------------
_WORD *__fastcall sub_14000D150(void *Src, int a2)
{
  void *v2; // rdi
  signed __int64 v3; // rbx
  _WORD *result; // rax
  _WORD *v5; // rsi

  v2 = Src;
  LODWORD(v3) = 0;
  if ( Src )
  {
    v3 = -1i64;
    do
      ++v3;
    while ( *((_WORD *)Src + v3) );
  }
  result = (_WORD *)sub_140012E40(v3, a2);
  v5 = result;
  if ( (_DWORD)v3 )
    result = memcpy(result, v2, 2i64 * (signed int)v3);
  v5[(signed int)v3] = 0;
  return result;
}

//----- (000000014000D1C0) ----------------------------------------------------
__int64 __fastcall sub_14000D1C0(signed __int16 *a1)
{
  return *a1;
}

//----- (000000014000D1D0) ----------------------------------------------------
_WORD *__fastcall sub_14000D1D0(char *a1, __int64 a2, int a3)
{
  __int64 v3; // rdi
  char *v4; // rsi
  _WORD *result; // rax
  __int64 v6; // rax
  _WORD *v7; // rbx
  __int64 v8; // rsi
  __int16 v9; // ax

  v3 = a2;
  v4 = a1;
  if ( a2 == -1 )
    return sub_14000D150(a1, a3);
  if ( a2 < 0 )
    v3 = 0i64;
  v6 = sub_140012E40(v3, a3);
  v7 = (_WORD *)v6;
  if ( v4 && v3 )
  {
    v8 = (__int64)&v4[-v6];
    do
    {
      v9 = *(_WORD *)((char *)v7 + v8);
      if ( !v9 )
        break;
      *v7 = v9;
      ++v7;
      --v3;
    }
    while ( v3 );
  }
  result = (_WORD *)sub_140013010(v3);
  *v7 = 0;
  return result;
}

//----- (000000014000D260) ----------------------------------------------------
char *__fastcall sub_14000D260(void *Src, void *Dst, size_t a3)
{
  char *v3; // rbx
  size_t v4; // rdi

  v3 = (char *)Dst;
  v4 = a3;
  memcpy(Dst, Src, a3);
  return &v3[v4];
}

//----- (000000014000D290) ----------------------------------------------------
__int64 __fastcall sub_14000D290(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000014000D2A0) ----------------------------------------------------
void __fastcall sub_14000D2A0(_DWORD *a1, int a2)
{
  *a1 = a2;
}

//----- (000000014000D2B0) ----------------------------------------------------
int __fastcall sub_14000D2B0(LPCSTR lpMultiByteStr, signed __int64 a2, char a3, int a4)
{
  __int64 v4; // rbx
  int v5; // eax
  int v6; // esi
  LPCSTR v7; // r14
  __int64 v8; // rax
  _WORD *v9; // rdi
  const CHAR *v10; // r14
  __int16 v11; // ax
  int result; // eax
  UINT v13; // ebp
  signed __int64 v14; // rbx
  __int64 v15; // rax
  int v16; // eax
  int v17; // edi
  WCHAR *lpWideCharStr; // rax
  WCHAR *v19; // rsi

  v4 = a2;
  v5 = a3 & 0x1F;
  v6 = a4;
  if ( a2 < -1 )
    v4 = 0i64;
  v7 = lpMultiByteStr;
  if ( v5 != 25 )
  {
    if ( v5 == 2 )
    {
      v13 = 65001;
      if ( v4 == -1 )
        goto LABEL_18;
      if ( !(a3 & 0x40) )
        v4 = (__int64)sub_140013050((char *)lpMultiByteStr, v4);
    }
    else
    {
      v13 = 0;
    }
    if ( v4 != -1 )
    {
      v15 = 0i64;
      if ( *v7 )
      {
        do
        {
          if ( v15 >= v4 )
            break;
          ++v15;
        }
        while ( v7[v15] );
      }
      LODWORD(v14) = v15;
      goto LABEL_25;
    }
LABEL_18:
    v14 = -1i64;
    do
      ++v14;
    while ( v7[v14] );
LABEL_25:
    v16 = MultiByteToWideChar(v13, 0, v7, v14, 0i64, 0);
    v17 = v16;
    lpWideCharStr = (WCHAR *)sub_140012E40(v16, v6);
    v19 = lpWideCharStr;
    result = MultiByteToWideChar(v13, 0, v7, v14, lpWideCharStr, v17 + 1);
    v19[result] = 0;
    return result;
  }
  if ( v4 == -1 )
  {
    do
      ++v4;
    while ( *(_WORD *)&lpMultiByteStr[2 * v4] );
  }
  v8 = sub_140012E40(v4, a4);
  v9 = (_WORD *)v8;
  if ( v7 && v4 )
  {
    v10 = &v7[-v8];
    do
    {
      v11 = *(_WORD *)((char *)v9 + (_QWORD)v10);
      if ( !v11 )
        break;
      *v9 = v11;
      ++v9;
      --v4;
    }
    while ( v4 );
  }
  result = sub_140013010(v4);
  *v9 = 0;
  return result;
}

//----- (000000014000D3FC) ----------------------------------------------------
BOOL (__fastcall *sub_14000D3FC())(LPVOID lpMem)
{
  BOOL (__fastcall *result)(LPVOID); // rax

  qword_140021170 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_14000D428;
  qword_140021188 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14000D614;
  result = sub_14000D580;
  qword_1400211A0 = (__int64 (__fastcall *)(_QWORD))sub_14000D580;
  return result;
}
// 140021170: using guessed type __int64 (__fastcall *qword_140021170)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140021188: using guessed type __int64 (__fastcall *qword_140021188)(_QWORD, _QWORD, _QWORD);
// 1400211A0: using guessed type __int64 (__fastcall *qword_1400211A0)(_QWORD);

//----- (000000014000D428) ----------------------------------------------------
_QWORD *__fastcall sub_14000D428(__int64 a1, int a2, signed __int64 *a3, LPVOID *a4, signed int a5)
{
  __int64 v5; // r14
  LPVOID *v6; // rsi
  signed __int64 *v7; // rbp
  int v8; // er15
  _QWORD *v9; // rdi
  signed int v10; // ebx
  LPVOID v11; // rax
  _QWORD *v12; // rax

  v5 = a1;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  sub_14000D580(*a4);
  v9 = HeapAlloc(hHeap, 0, 0x60ui64);
  if ( v9 )
  {
    v10 = a5;
    if ( a5 <= 0 )
      v10 = 1;
    v11 = HeapAlloc(hHeap, 8u, 8i64 * v10);
    v9[1] = v11;
    if ( v11 )
    {
      *v9 = 0i64;
      *((_DWORD *)v9 + 16) = 0;
      *((_DWORD *)v9 + 17) = 0;
      v9[10] = 0i64;
      *((_DWORD *)v9 + 15) = v10;
      v9[6] = v5;
      *((_DWORD *)v9 + 14) = v8;
      v9[4] = v7;
      v9[9] = v6;
      if ( sub_140016C40(v7) )
        *((_DWORD *)v9 + 17) |= 2u;
      v9[11] = sub_140011F4C(v5 + 16, 0x10u, 0x10000u, 4);
      v12 = HeapAlloc(hHeap, 8u, v5 + 16);
      v9[3] = v12;
      v12[1] = word_14001968C;
      *v6 = v9;
    }
    else
    {
      HeapFree(hHeap, 0, v9);
      v9 = 0i64;
    }
  }
  return v9;
}

//----- (000000014000D54C) ----------------------------------------------------
__int64 *__fastcall sub_14000D54C(__int64 a1, unsigned __int16 *a2)
{
  unsigned __int16 *v2; // rbx
  __int64 v3; // rdi
  __int64 *result; // rax

  v2 = a2;
  v3 = a1;
  result = sub_14000D6C4(a1, a2);
  if ( !result )
    result = sub_14000D77C(v3, v2, 0);
  return result;
}

//----- (000000014000D580) ----------------------------------------------------
BOOL __fastcall sub_14000D580(LPVOID lpMem)
{
  LPVOID v1; // rdi
  _QWORD *v2; // r8
  _QWORD *v3; // rbx
  BOOL result; // eax

  if ( lpMem )
  {
    v1 = lpMem;
    sub_14000D890((__int64)lpMem);
    sub_1400120B8(*((_QWORD *)v1 + 11));
    HeapFree(hHeap, 0, *((LPVOID *)v1 + 1));
    HeapFree(hHeap, 0, *((LPVOID *)v1 + 3));
    v2 = (_QWORD *)*((_QWORD *)v1 + 10);
    if ( v2 )
    {
      do
      {
        v3 = (_QWORD *)*v2;
        HeapFree(hHeap, 0, v2);
        v2 = v3;
      }
      while ( v3 );
    }
    **((_QWORD **)v1 + 9) = 0i64;
    result = HeapFree(hHeap, 0, v1);
  }
  return result;
}

//----- (000000014000D614) ----------------------------------------------------
signed __int64 __fastcall sub_14000D614(__int64 a1, __int64 a2, int a3)
{
  signed __int64 v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rbx
  __int64 v6; // r14
  int v7; // er15
  unsigned __int16 *v8; // rdx
  char *v9; // rax
  signed __int64 v10; // rax
  char *v11; // rbp

  v3 = 0i64;
  v4 = a2;
  v5 = a1;
  if ( a1 && a2 )
  {
    v6 = *(_QWORD *)a1;
    v7 = *(_DWORD *)(a1 + 40);
    if ( a3 )
      sub_14000D890(a2);
    sub_14000D934(v5);
    while ( 1 )
    {
      v10 = sub_14000DA3C(v5);
      v11 = (char *)v10;
      if ( !v10 )
        break;
      v8 = *(unsigned __int16 **)(v10 - 8);
      if ( *(_BYTE *)(v5 + 68) & 4 )
        v9 = (char *)sub_14000D940(v4, (__int64)v8, 0);
      else
        v9 = (char *)sub_14000D77C(v4, v8, 0);
      sub_140016CA8(v9, *(_QWORD *)(v5 + 48), *(int **)(v5 + 32), v11);
    }
    *(_QWORD *)v5 = v6;
    *(_DWORD *)(v5 + 40) = v7;
    v3 = 1i64;
  }
  return v3;
}

//----- (000000014000D6C4) ----------------------------------------------------
__int64 *__fastcall sub_14000D6C4(__int64 a1, unsigned __int16 *a2)
{
  wchar_t *v2; // rsi
  __int64 v3; // rbx
  unsigned int v4; // eax
  __int64 **v5; // rdi
  int v6; // ebp
  unsigned int v8; // eax

  v2 = word_14001968C;
  v3 = a1;
  if ( a2 )
    v2 = a2;
  if ( *(_BYTE *)(a1 + 68) & 1 )
  {
    v4 = sub_14000DAF4(v2);
    v5 = *(__int64 ***)(*(_QWORD *)(v3 + 8) + 8i64 * (v4 % *(_DWORD *)(v3 + 60)));
    v6 = v4 % *(_DWORD *)(v3 + 60);
    while ( v5 )
    {
      if ( !wcsicmp((const wchar_t *)v5[1], v2) )
        goto LABEL_9;
      *(_QWORD *)(v3 + 16) = v5;
      v5 = (__int64 **)*v5;
    }
  }
  else
  {
    v8 = sub_14000DADC(v2);
    v5 = *(__int64 ***)(*(_QWORD *)(v3 + 8) + 8i64 * (v8 % *(_DWORD *)(v3 + 60)));
    v6 = v8 % *(_DWORD *)(v3 + 60);
    while ( v5 )
    {
      if ( !wcscmp((const wchar_t *)v5[1], v2) )
      {
LABEL_9:
        *(_DWORD *)(v3 + 40) = v6;
        *(_QWORD *)v3 = v5;
        return (__int64 *)(v5 + 2);
      }
      *(_QWORD *)(v3 + 16) = v5;
      v5 = (__int64 **)*v5;
    }
  }
  return 0i64;
}

//----- (000000014000D77C) ----------------------------------------------------
_QWORD *__fastcall sub_14000D77C(__int64 a1, unsigned __int16 *a2, int a3)
{
  unsigned __int16 *v3; // rbp
  __int64 v4; // rbx
  __int64 *v5; // rax
  _QWORD *v6; // rdi
  signed __int64 *v7; // rdx
  unsigned __int16 *v8; // rsi
  unsigned int v9; // eax
  unsigned int v10; // ebp
  size_t v11; // rax
  wchar_t *v12; // rax

  v3 = a2;
  v4 = a1;
  if ( a3 == 1 )
  {
    v5 = sub_14000D6C4(a1, a2);
    v6 = v5;
    if ( v5 )
    {
      v7 = *(signed __int64 **)(v4 + 32);
      if ( v7 )
        sub_140017030((__int64)v5, v7);
      goto LABEL_12;
    }
  }
  v8 = word_14001968C;
  if ( v3 )
    v8 = v3;
  if ( *(_BYTE *)(v4 + 68) & 1 )
    v9 = sub_14000DAF4(v8);
  else
    v9 = sub_14000DADC(v8);
  v10 = v9 % *(_DWORD *)(v4 + 60);
  v6 = (_QWORD *)sub_140011BCC(*(__int64 **)(v4 + 88));
  if ( v6 )
  {
    v11 = wcslen(v8);
    v12 = (wchar_t *)HeapAlloc(hHeap, 0, 2 * v11 + 2);
    v6[1] = v12;
    wcscpy(v12, v8);
    *v6 = *(_QWORD *)(*(_QWORD *)(v4 + 8) + 8i64 * v10);
    *(_QWORD *)(*(_QWORD *)(v4 + 8) + 8i64 * v10) = v6;
    *(_QWORD *)(v4 + 16) = 0i64;
    ++*(_DWORD *)(v4 + 64);
    *(_QWORD *)v4 = v6;
    *(_DWORD *)(v4 + 40) = v10;
    v6 += 2;
LABEL_12:
    if ( v6 )
    {
      memset(v6, 0, *(signed int *)(v4 + 48));
      if ( *(_BYTE *)(v4 + 68) & 2 )
        sub_14001717C((__int64)v6, *(_QWORD **)(v4 + 32));
    }
  }
  return v6;
}

//----- (000000014000D890) ----------------------------------------------------
void __fastcall sub_14000D890(__int64 a1)
{
  signed __int64 *v1; // rsi
  __int64 v2; // rbx
  __int64 v3; // rcx
  signed __int64 v4; // rax
  __int64 v5; // rdi
  __int64 v6; // [rsp+20h] [rbp-18h]

  v1 = *(signed __int64 **)(a1 + 32);
  v2 = a1;
  sub_14000D934(a1);
  while ( 1 )
  {
    v4 = sub_14000DA3C(v2);
    v5 = v4;
    if ( !v4 )
      break;
    if ( !(*(_BYTE *)(v2 + 68) & 4) )
      HeapFree(hHeap, 0, *(LPVOID *)(v4 - 8));
    if ( v1 )
      sub_140017030(v5, v1);
    v3 = *(_QWORD *)(v2 + 88);
    v6 = *(_QWORD *)(v5 - 16);
    *(_QWORD *)v2 = &v6;
    sub_140011E44(v3, v5 - 16);
  }
  memset(*(void **)(v2 + 8), 0, 8 * *(_DWORD *)(v2 + 60));
  sub_14000D934(v2);
  *(_DWORD *)(v2 + 64) = 0;
}

//----- (000000014000D934) ----------------------------------------------------
void __fastcall sub_14000D934(__int64 a1)
{
  *(_QWORD *)a1 = 0i64;
  *(_DWORD *)(a1 + 40) = -1;
}

//----- (000000014000D940) ----------------------------------------------------
void *__fastcall sub_14000D940(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // rsi
  __int64 v4; // rdi
  _QWORD *v5; // rax
  void *v6; // rbx
  signed __int64 *v7; // rdx
  signed __int64 v8; // rbp
  _QWORD *v9; // rax

  v3 = a2;
  v4 = a1;
  if ( a3 == 1 && (v5 = sub_14000DB30(a1, a2), (v6 = v5) != 0i64) )
  {
    v7 = *(signed __int64 **)(v4 + 32);
    if ( v7 )
      sub_140017030((__int64)v5, v7);
  }
  else
  {
    v8 = v3 % *(signed int *)(v4 + 60);
    v9 = (_QWORD *)sub_140011BCC(*(__int64 **)(v4 + 88));
    v6 = v9;
    if ( !v9 )
      return v6;
    v9[1] = v3;
    *v9 = *(_QWORD *)(*(_QWORD *)(v4 + 8) + 8i64 * (unsigned int)v8);
    *(_QWORD *)(*(_QWORD *)(v4 + 8) + 8i64 * (unsigned int)v8) = v9;
    *(_QWORD *)(v4 + 16) = 0i64;
    ++*(_DWORD *)(v4 + 64);
    *(_QWORD *)v4 = v9;
    *(_DWORD *)(v4 + 40) = v8;
    v6 = v9 + 2;
  }
  if ( v6 )
  {
    memset(v6, 0, *(signed int *)(v4 + 48));
    if ( *(_BYTE *)(v4 + 68) & 2 )
      sub_14001717C((__int64)v6, *(_QWORD **)(v4 + 32));
  }
  return v6;
}

//----- (000000014000DA3C) ----------------------------------------------------
signed __int64 __fastcall sub_14000DA3C(__int64 a1)
{
  __int64 *v1; // rax
  int v2; // edx
  int v3; // eax
  __int64 v4; // r8
  _QWORD *v5; // rdx
  __int64 v6; // rdx
  __int64 v8; // rax
  int v9; // edx
  __int64 v10; // r9
  _QWORD *v11; // r8

  v1 = *(__int64 **)a1;
  v2 = *(_DWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)a1;
  *(_DWORD *)(a1 + 44) = v2;
  if ( v1 )
  {
    v8 = *v1;
    *(_QWORD *)a1 = v8;
    if ( v8 )
      return *(_QWORD *)a1 + 16i64;
    v9 = v2 + 1;
    *(_DWORD *)(a1 + 40) = v9;
    if ( v9 < *(_DWORD *)(a1 + 60) )
    {
      v10 = *(_QWORD *)(a1 + 8);
      v11 = (_QWORD *)(v10 + 8i64 * v9);
      while ( !*v11 )
      {
        ++v9;
        ++v11;
        if ( v9 >= *(_DWORD *)(a1 + 60) )
          goto LABEL_7;
      }
      *(_DWORD *)(a1 + 40) = v9;
      v6 = *(_QWORD *)(v10 + 8i64 * v9);
      goto LABEL_8;
    }
  }
  else
  {
    if ( v2 != -1 )
      goto LABEL_9;
    *(_DWORD *)(a1 + 40) = 0;
    v3 = 0;
    if ( *(_DWORD *)(a1 + 60) > 0 )
    {
      v4 = *(_QWORD *)(a1 + 8);
      v5 = *(_QWORD **)(a1 + 8);
      while ( !*v5 )
      {
        ++v3;
        ++v5;
        if ( v3 >= *(_DWORD *)(a1 + 60) )
          goto LABEL_7;
      }
      *(_DWORD *)(a1 + 40) = v3;
      v6 = *(_QWORD *)(v4 + 8i64 * v3);
      goto LABEL_8;
    }
  }
LABEL_7:
  v6 = 0i64;
LABEL_8:
  *(_QWORD *)a1 = v6;
LABEL_9:
  if ( !*(_QWORD *)a1 )
    return 0i64;
  return *(_QWORD *)a1 + 16i64;
}

//----- (000000014000DADC) ----------------------------------------------------
__int64 __fastcall sub_14000DADC(_WORD *a1)
{
  __int64 result; // rax
  int v2; // edx

  for ( result = 0i64; ; result = (unsigned int)(v2 + 65599 * result) )
  {
    v2 = (unsigned __int16)*a1;
    if ( !*a1 )
      break;
    ++a1;
  }
  return result;
}

//----- (000000014000DAF4) ----------------------------------------------------
__int64 __fastcall sub_14000DAF4(unsigned __int16 *a1)
{
  unsigned __int16 *v1; // rdi
  int v2; // ecx
  unsigned int v3; // ebx
  int v4; // eax

  v1 = a1;
  v2 = *a1;
  v3 = 0;
  while ( 1 )
  {
    v4 = tolower(v2);
    if ( !v4 )
      break;
    ++v1;
    v3 = v4 + 65599 * v3;
    v2 = *v1;
  }
  return v3;
}

//----- (000000014000DB30) ----------------------------------------------------
_QWORD *__fastcall sub_14000DB30(__int64 a1, __int64 a2)
{
  __int64 v2; // r9
  signed __int64 v3; // rdx
  _QWORD *result; // rax

  v2 = a2;
  v3 = a2 % *(signed int *)(a1 + 60);
  for ( result = *(_QWORD **)(*(_QWORD *)(a1 + 8) + 8 * v3); result; result = (_QWORD *)*result )
  {
    if ( result[1] == v2 )
    {
      *(_QWORD *)a1 = result;
      *(_DWORD *)(a1 + 40) = v3;
      result += 2;
      return result;
    }
    *(_QWORD *)(a1 + 16) = result;
  }
  return result;
}

//----- (000000014000DB68) ----------------------------------------------------
BOOL (__fastcall *sub_14000DB68())(LPVOID lpMem)
{
  BOOL (__fastcall *result)(LPVOID); // rax

  qword_140021168 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))sub_14000DB94;
  qword_140021180 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_14000DFCC;
  result = sub_14000DC74;
  qword_140021198 = (__int64 (__fastcall *)(_QWORD))sub_14000DC74;
  return result;
}
// 140021168: using guessed type __int64 (__fastcall *qword_140021168)(_QWORD, _QWORD, _QWORD, _QWORD);
// 140021180: using guessed type __int64 (__fastcall *qword_140021180)(_QWORD, _QWORD, _QWORD);
// 140021198: using guessed type __int64 (__fastcall *qword_140021198)(_QWORD);

//----- (000000014000DB94) ----------------------------------------------------
_BYTE *__fastcall sub_14000DB94(__int64 a1, _QWORD *a2, signed __int64 *a3, int a4)
{
  _QWORD *v4; // rsi
  __int64 v5; // rbx
  signed __int64 *v6; // rbp
  int v7; // er14
  _BYTE *v8; // rax
  _BYTE *v9; // rdi
  _QWORD *v10; // rax
  __int64 v11; // rbx
  char v12; // al

  v4 = a2;
  v5 = a1;
  v6 = a3;
  v7 = a4;
  v8 = HeapAlloc(hHeap, 0, 0x60ui64);
  v9 = v8;
  if ( v4 )
  {
    v8[94] = 0;
  }
  else
  {
    v10 = HeapAlloc(hHeap, 0, 0x10ui64);
    v9[94] = 1;
    v4 = v10;
  }
  *((_QWORD *)v9 + 2) = 0i64;
  *(_QWORD *)v9 = 0i64;
  *((_QWORD *)v9 + 1) = 0i64;
  *((_QWORD *)v9 + 4) = 0i64;
  v11 = v5 + 16;
  *((_QWORD *)v9 + 10) = v11;
  *((_QWORD *)v9 + 6) = v6;
  *((_QWORD *)v9 + 3) = v4 + 1;
  v9[92] = 1;
  *((_DWORD *)v9 + 22) = v7;
  v12 = sub_140016C40(v6);
  *((_QWORD *)v9 + 8) = 0i64;
  *((_QWORD *)v9 + 9) = v4;
  v9[93] = v12;
  *v4 = v9;
  *((_QWORD *)v9 + 7) = sub_140011F4C(v11, 0x10u, 0x10000u, 4);
  return v9;
}

//----- (000000014000DC74) ----------------------------------------------------
BOOL __fastcall sub_14000DC74(LPVOID lpMem)
{
  LPVOID v1; // rdi
  _QWORD *v2; // r8
  _QWORD *v3; // rbx
  BOOL result; // eax

  if ( lpMem )
  {
    v1 = lpMem;
    sub_14000DD5C((_QWORD **)lpMem);
    sub_1400120B8(*((_QWORD *)v1 + 7));
    **((_QWORD **)v1 + 9) = 0i64;
    *(_QWORD *)(*((_QWORD *)v1 + 9) + 8i64) = 0i64;
    v2 = (_QWORD *)*((_QWORD *)v1 + 8);
    if ( v2 )
    {
      do
      {
        v3 = (_QWORD *)*v2;
        HeapFree(hHeap, 0, v2);
        v2 = v3;
      }
      while ( v3 );
    }
    if ( *((_BYTE *)v1 + 94) )
      HeapFree(hHeap, 0, *((LPVOID *)v1 + 9));
    result = HeapFree(hHeap, 0, v1);
  }
  return result;
}

//----- (000000014000DD04) ----------------------------------------------------
__int64 __fastcall sub_14000DD04(__int64 a1)
{
  return *(_QWORD *)(a1 + 32);
}

//----- (000000014000DD0C) ----------------------------------------------------
_QWORD *__fastcall sub_14000DD0C(__int64 a1)
{
  _QWORD *result; // rax

  result = *(_QWORD **)(a1 + 24);
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_BYTE *)(a1 + 92) = 1;
  *result = 0i64;
  return result;
}

//----- (000000014000DD20) ----------------------------------------------------
__int64 __fastcall sub_14000DD20(__int64 *a1)
{
  __int64 *v1; // rax
  __int64 result; // rax

  v1 = (__int64 *)a1[2];
  if ( v1 )
  {
    result = *v1;
    if ( result )
    {
      ++a1[5];
      a1[2] = result;
LABEL_5:
      result += 16i64;
      goto LABEL_6;
    }
  }
  else
  {
    result = *a1;
    a1[5] = 0i64;
    a1[2] = result;
    if ( result )
      goto LABEL_5;
  }
LABEL_6:
  *(_QWORD *)a1[3] = a1[2];
  return result;
}

//----- (000000014000DD5C) ----------------------------------------------------
_QWORD *__fastcall sub_14000DD5C(_QWORD **a1)
{
  signed __int64 *v1; // rsi
  _QWORD *v2; // rdi
  _QWORD **v3; // rbx
  __int64 v4; // rbp
  __int64 v5; // rdx
  _QWORD *result; // rax

  v1 = a1[6];
  v2 = *a1;
  v3 = a1;
  if ( v1 )
  {
    while ( 1 )
    {
      v4 = (__int64)v2;
      if ( !v2 )
        break;
      v2 = (_QWORD *)*v2;
      sub_140017030(v4 + 16, v1);
      sub_140011E44((__int64)v3[7], v4);
    }
  }
  else
  {
    while ( 1 )
    {
      v5 = (__int64)v2;
      if ( !v2 )
        break;
      v2 = (_QWORD *)*v2;
      sub_140011E44((__int64)v3[7], v5);
    }
  }
  v3[2] = 0i64;
  result = v3[3];
  *result = 0i64;
  *v3 = 0i64;
  v3[1] = 0i64;
  v3[4] = 0i64;
  *((_BYTE *)v3 + 92) = 1;
  return result;
}

//----- (000000014000DDF0) ----------------------------------------------------
_QWORD *__fastcall sub_14000DDF0(__int64 *a1)
{
  __int64 *v1; // rbx
  _QWORD *result; // rax
  _QWORD *v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  _QWORD *v7; // rcx

  v1 = a1;
  result = (_QWORD *)sub_140011BCC((__int64 *)a1[7]);
  v3 = result;
  if ( result )
  {
    memset(result, 0, v1[10]);
    if ( *((_BYTE *)v1 + 93) )
      sub_14001717C((__int64)(v3 + 2), (_QWORD *)v1[6]);
    v4 = v1[2];
    ++v1[4];
    if ( v4 )
    {
      v3[1] = v4;
      *v3 = *(_QWORD *)v1[2];
      v6 = v1[2];
      if ( *(_QWORD *)v6 )
        *(_QWORD *)(*(_QWORD *)v6 + 8i64) = v3;
      *(_QWORD *)v1[2] = v3;
      ++v1[5];
      v1[2] = (__int64)v3;
    }
    else
    {
      if ( *v1 )
        *(_QWORD *)(*v1 + 8) = v3;
      v5 = *v1;
      v1[2] = (__int64)v3;
      v3[1] = 0i64;
      *v3 = v5;
      v1[5] = 0i64;
      *((_BYTE *)v1 + 92) = 0;
    }
    v7 = (_QWORD *)v1[2];
    if ( !v7[1] )
      *v1 = (__int64)v7;
    if ( !*v7 )
      v1[1] = (__int64)v7;
    *(_QWORD *)v1[3] = v7;
    result = v3 + 2;
  }
  return result;
}

//----- (000000014000DEC4) ----------------------------------------------------
signed __int64 __fastcall sub_14000DEC4(__int64 *a1, signed __int64 a2)
{
  __int64 v2; // rax
  signed __int64 v3; // r8
  __int64 *v4; // r9
  signed __int64 v5; // r10
  signed __int64 v6; // r10
  signed __int64 v7; // r10
  signed __int64 v8; // r8
  signed __int64 i; // r10
  signed __int64 v10; // rax
  _QWORD *v11; // rax
  signed __int64 result; // rax

  v2 = a1[5];
  v3 = a2;
  v4 = a1;
  a1[5] = a2;
  if ( a2 < 0 || (v5 = a1[4], a2 >= v5) )
  {
    a1 = 0i64;
  }
  else if ( *((_BYTE *)a1 + 92) )
  {
    if ( a2 < v5 / 2 )
    {
      while ( 1 )
      {
        a1 = (__int64 *)*a1;
        if ( !a1 || !v3 )
          break;
        --v3;
      }
    }
    else
    {
      v6 = v5 - a2;
      do
      {
        a1 = (__int64 *)a1[1];
        --v6;
      }
      while ( a1 && v6 );
    }
  }
  else
  {
    a1 = (__int64 *)a1[2];
    if ( a2 <= v2 )
    {
      v10 = v2 - a2;
      if ( v10 < a2 )
      {
        while ( a1 && v10 )
        {
          a1 = (__int64 *)a1[1];
          --v10;
        }
      }
      else
      {
        a1 = (__int64 *)*v4;
        while ( a1 && v3 )
        {
          a1 = (__int64 *)*a1;
          --v3;
        }
      }
    }
    else
    {
      v7 = v5 - a2;
      v8 = a2 - v2;
      if ( a2 - v2 < v7 )
      {
        while ( a1 && v8 )
        {
          a1 = (__int64 *)*a1;
          --v8;
        }
      }
      else
      {
        a1 = (__int64 *)v4[1];
        for ( i = v7 - 1; a1 && i; --i )
          a1 = (__int64 *)a1[1];
      }
    }
  }
  v11 = (_QWORD *)v4[3];
  v4[2] = (__int64)a1;
  *v11 = a1;
  if ( a1 )
  {
    *((_BYTE *)v4 + 92) = 0;
    result = (signed __int64)(a1 + 2);
  }
  else
  {
    *((_BYTE *)v4 + 92) = 1;
    result = 0i64;
  }
  return result;
}

//----- (000000014000DFCC) ----------------------------------------------------
signed __int64 __fastcall sub_14000DFCC(char **a1, __int64 *a2, int a3)
{
  signed __int64 v3; // rbx
  __int64 *v4; // rbp
  char **v5; // rsi
  char *i; // rdi
  char *v7; // rax

  v3 = 0i64;
  v4 = a2;
  v5 = a1;
  if ( a1 && a2 )
  {
    if ( a3 )
      sub_14000DD5C((_QWORD **)a2);
    for ( i = *v5; i; i = *(char **)i )
    {
      v7 = (char *)sub_14000DDF0(v4);
      sub_140016CA8(v7, (signed __int64)(v5[10] - 16), (int *)v5[6], i + 16);
    }
    v3 = 1i64;
  }
  return v3;
}

//----- (000000014000E048) ----------------------------------------------------
void sub_14000E048()
{
  if ( qword_1400206A8 )
    sub_1400121A0(qword_1400206A8);
}
// 1400206A8: using guessed type __int64 qword_1400206A8;

//----- (000000014000E064) ----------------------------------------------------
_BOOL8 __fastcall sub_14000E064(wchar_t *Source)
{
  wchar_t *v1; // rcx
  wchar_t *v2; // rdx
  unsigned __int64 v3; // rax
  signed __int64 v4; // r8
  wchar_t Dest[260]; // [rsp+20h] [rbp-218h]
  __int16 v7; // [rsp+228h] [rbp-10h]

  if ( !Source )
    return 0i64;
  wcsncpy(Dest, Source, 0x104ui64);
  v7 = 0;
  v1 = &Dest[wcslen(Dest)];
  if ( v1 > Dest )
  {
    do
    {
      v2 = v1 - 1;
      v3 = *(v1 - 1);
      LOWORD(v3) = v3 - 32;
      if ( (unsigned __int16)v3 > 0x3Cu )
        break;
      v4 = 1152921504606879745i64;
      if ( !_bittest64(&v4, v3) )
        break;
      --v1;
    }
    while ( v2 > Dest );
  }
  *v1 = 0;
  return CreateDirectoryW(Dest, 0i64);
}
// 14000E064: using guessed type wchar_t Dest[260];

//----- (000000014000E0FC) ----------------------------------------------------
__int64 __fastcall sub_14000E0FC(const WCHAR *a1, DWORD a2)
{
  __int64 result; // rax

  LODWORD(result) = 0;
  if ( a1 )
    LODWORD(result) = SetFileAttributesW(a1, a2);
  return (signed int)result;
}

//----- (000000014000E114) ----------------------------------------------------
__int64 __fastcall sub_14000E114(int a1)
{
  WCHAR *v1; // rdi
  signed int v2; // esi
  HMODULE v3; // rax
  HMODULE v4; // rbp
  FARPROC v5; // rax
  __int64 result; // rax

  v1 = (WCHAR *)sub_140012E40(260, a1);
  v2 = GetTempPathW(0x104u, v1);
  v3 = LoadLibraryW(L"Kernel32.DLL");
  v4 = v3;
  if ( v3 )
  {
    v5 = GetProcAddress(v3, "GetLongPathNameW");
    if ( v5 )
      v2 = ((__int64 (__fastcall *)(WCHAR *, WCHAR *, signed __int64))v5)(v1, v1, 260i64);
    FreeLibrary(v4);
  }
  sub_140013010(260 - v2);
  result = v2;
  v1[v2] = 0;
  return result;
}

//----- (000000014000E1BC) ----------------------------------------------------
_BOOL8 __fastcall sub_14000E1BC(const WCHAR *a1)
{
  return sub_14000E1C4(a1, 0);
}

//----- (000000014000E1C4) ----------------------------------------------------
_BOOL8 __fastcall sub_14000E1C4(LPCWSTR lpFileName, char a2)
{
  const WCHAR *v2; // rbx

  v2 = lpFileName;
  if ( !lpFileName )
    return 0i64;
  if ( a2 & 2 )
    SetFileAttributesW(lpFileName, 0x80u);
  return DeleteFileW(v2);
}

//----- (000000014000E1F8) ----------------------------------------------------
__int64 __fastcall sub_14000E1F8(int a1)
{
  WCHAR *v1; // rax
  WCHAR *v2; // rdi
  signed int v3; // eax
  int v4; // ebx
  __int64 result; // rax

  v1 = (WCHAR *)sub_140012E40(260, a1);
  v2 = v1;
  v3 = GetCurrentDirectoryW(0x104u, v1);
  v4 = v3;
  if ( v3 && v2[v3 - 1] != 92 )
  {
    v2[v3] = 92;
    v4 = v3 + 1;
  }
  sub_140013010(260 - v4);
  result = v4;
  v2[v4] = 0;
  return result;
}

//----- (000000014000E268) ----------------------------------------------------
__int64 __fastcall sub_14000E268(int a1, int a2)
{
  int v2; // ebx
  int v3; // edi
  wchar_t *v4; // rax
  wchar_t *v5; // rsi
  HMODULE v6; // rax
  HMODULE v7; // rbx
  FARPROC v8; // rax
  int v9; // eax
  int v10; // ebx
  int v11; // ebx
  int v12; // ebx
  int v13; // ebx
  int v14; // ebx
  int v15; // ebx
  int v16; // ebx
  int v17; // ecx
  __int64 result; // rax
  wchar_t *Source; // [rsp+50h] [rbp+18h]

  v2 = a1;
  v3 = 0;
  v4 = (wchar_t *)sub_140012E40(260, a2);
  v5 = v4;
  if ( v2 != 2 )
  {
    if ( v2 )
    {
      v10 = v2 - 1;
      if ( v10 )
      {
        v11 = v10 - 2;
        if ( v11 )
        {
          v12 = v11 - 1;
          if ( v12 )
          {
            v13 = v12 - 1;
            if ( v13 )
            {
              v14 = v13 - 1;
              if ( v14 )
              {
                v15 = v14 - 1;
                if ( v15 )
                {
                  v16 = v15 - 1;
                  if ( v16 )
                  {
                    if ( v16 != 1 )
                      goto LABEL_28;
                    v17 = 46;
                  }
                  else
                  {
                    v17 = 39;
                  }
                }
                else
                {
                  v17 = 13;
                }
              }
              else
              {
                v17 = 14;
              }
            }
            else
            {
              v17 = 35;
            }
          }
          else
          {
            v17 = 26;
          }
        }
        else
        {
          v17 = 5;
        }
      }
      else
      {
        v17 = 38;
      }
    }
    else
    {
      v17 = 0;
    }
    v9 = sub_14000E3F4(v17, v4);
    goto LABEL_27;
  }
  v6 = LoadLibraryW(L"Shell32.DLL");
  v7 = v6;
  if ( !v6 )
    goto LABEL_31;
  v8 = GetProcAddress(v6, "SHGetKnownFolderPath");
  qword_1400206B0 = (__int64)v8;
  if ( v8 && !((unsigned int (__fastcall *)(void *, _QWORD, _QWORD, wchar_t **))v8)(&unk_14001F128, 0i64, 0i64, &Source) )
  {
    wcscpy(v5, Source);
    wcscat(v5, "\\");
    v3 = wcslen(v5);
    CoTaskMemFree(Source);
  }
  FreeLibrary(v7);
  if ( !v3 )
  {
LABEL_31:
    sub_14000E3F4(40, v5);
    wcscat(v5, L"Downloads\\");
    v9 = wcslen(v5);
LABEL_27:
    v3 = v9;
  }
LABEL_28:
  sub_140013010(260 - v3);
  result = v3;
  v5[v3] = 0;
  return result;
}
// 1400206B0: using guessed type __int64 qword_1400206B0;

//----- (000000014000E3D8) ----------------------------------------------------
_BOOL8 __fastcall sub_14000E3D8(const WCHAR *a1)
{
  _BOOL8 result; // rax

  if ( a1 )
    result = SetCurrentDirectoryW(a1);
  else
    result = 0i64;
  return result;
}

//----- (000000014000E3F4) ----------------------------------------------------
__int64 __fastcall sub_14000E3F4(int csidl, wchar_t *Str)
{
  wchar_t *v2; // rdi
  unsigned int v3; // ebx
  __int64 v4; // rax
  LPCITEMIDLIST pidl; // [rsp+48h] [rbp+10h]

  v2 = Str;
  v3 = 0;
  if ( !SHGetFolderLocation(0i64, csidl, 0i64, 0, (LPITEMIDLIST *)&pidl) )
  {
    if ( SHGetPathFromIDListW(pidl, v2) )
    {
      LODWORD(v4) = wcslen(v2);
      v3 = v4;
      if ( (_DWORD)v4 )
      {
        v4 = (signed int)v4;
        if ( v2[(signed int)v4 - 1] != 92 )
        {
          v2[v4] = 92;
          v3 = v4 + 1;
        }
      }
    }
    CoTaskMemFree((LPVOID)pidl);
  }
  v2[v3] = 0;
  return v3;
}

//----- (000000014000E480) ----------------------------------------------------
void __fastcall sub_14000E480(_QWORD *a1)
{
  __int64 v1; // rdi
  __int64 v2; // rax
  HANDLE *v3; // rbx

  v1 = (__int64)a1;
  if ( a1 == (_QWORD *)-1i64 )
  {
    sub_1400121A0(qword_140021390);
  }
  else
  {
    v2 = sub_140011998(qword_140021390, a1);
    v3 = (HANDLE *)v2;
    if ( v2 )
    {
      if ( *(_QWORD *)(v2 + 8) )
      {
        sub_14000E510(v2);
        HeapFree(hHeap, 0, v3[1]);
      }
      CloseHandle(*v3);
      sub_14001192C((signed int *)qword_140021390, v1);
    }
  }
}
// 140021390: using guessed type __int64 qword_140021390;

//----- (000000014000E510) ----------------------------------------------------
__int64 __fastcall sub_14000E510(__int64 a1)
{
  __int64 v1; // rbx
  DWORD NumberOfBytesWritten; // [rsp+40h] [rbp+8h]

  v1 = a1;
  NumberOfBytesWritten = 0;
  if ( *(_DWORD *)(a1 + 28) )
    return 0i64;
  WriteFile(
    *(HANDLE *)a1,
    *(LPCVOID *)(a1 + 8),
    *(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 20),
    &NumberOfBytesWritten,
    0i64);
  *(_DWORD *)(v1 + 20) = *(_DWORD *)(v1 + 16);
  return (signed int)NumberOfBytesWritten;
}

//----- (000000014000E560) ----------------------------------------------------
void sub_14000E560()
{
  sub_1400121A0(qword_140021390);
}
// 140021390: using guessed type __int64 qword_140021390;

//----- (000000014000E570) ----------------------------------------------------
_QWORD *sub_14000E570()
{
  _QWORD *result; // rax

  result = sub_140011AC0(40, 16, (__int64)sub_14000E480);
  qword_140021390 = (__int64)result;
  return result;
}
// 140021390: using guessed type __int64 qword_140021390;

//----- (000000014000E5A0) ----------------------------------------------------
signed __int64 __fastcall sub_14000E5A0(__int64 a1, const WCHAR *a2, int a3, int a4)
{
  const WCHAR *v4; // r13
  __int64 v5; // rbp
  signed __int64 v6; // rbx
  int v7; // eax
  int v8; // er15
  int v9; // er12
  signed __int64 v10; // rdi
  DWORD v11; // er8
  HANDLE v12; // rsi
  DWORD v13; // er8
  DWORD v14; // er14
  LONG DistanceToMoveHigh[2]; // [rsp+40h] [rbp-38h]
  int v17; // [rsp+98h] [rbp+20h]

  v4 = a2;
  v5 = a1;
  v6 = 0i64;
  v7 = a4 & 0x1F;
  v8 = a4;
  if ( !(a4 & 0x1F) )
    v7 = 2;
  v9 = a3;
  v17 = v7;
  v10 = sub_1400119F8((signed int *)qword_140021390, a1);
  if ( v10 )
  {
    switch ( v9 )
    {
      case 1:
        v11 = 0;
        if ( _bittest(&v8, 0x11u) )
          v11 = 1;
        if ( _bittest(&v8, 0x12u) )
          v11 |= 7u;
        v12 = CreateFileW(v4, 0x80000000, v11, 0i64, 3u, 0x80u, 0i64);
        break;
      case 2:
        v13 = 0;
        if ( _bittest(&v8, 0x11u) )
          v13 = 1;
        if ( _bittest(&v8, 0x12u) )
          v13 |= 7u;
        v12 = CreateFileW(v4, 0xC0000000, v13, 0i64, 4u, 0x80u, 0i64);
        break;
      case 3:
        v14 = 0;
        if ( _bittest(&v8, 0x11u) )
          v14 = 1;
        if ( _bittest(&v8, 0x12u) )
          v14 |= 7u;
        v12 = CreateFileW(v4, 0xC0000000, v14, 0i64, 2u, 0x80u, 0i64);
        if ( v12 != (HANDLE)-1i64 )
          goto LABEL_25;
        v12 = CreateFileW(v4, 0x40000000u, v14, 0i64, 5u, 0, 0i64);
        break;
      default:
        v12 = *(HANDLE *)DistanceToMoveHigh;
        break;
    }
    if ( v12 == (HANDLE)-1i64 )
    {
LABEL_36:
      if ( v5 == -1 )
        v5 = v10;
      sub_14001192C((signed int *)qword_140021390, v5);
      return v6;
    }
LABEL_25:
    if ( v12 )
    {
      if ( !dword_14001F138 || _bittest(&v8, 0x13u) )
        *(_QWORD *)(v10 + 8) = 0i64;
      else
        *(_QWORD *)(v10 + 8) = HeapAlloc(hHeap, 0, dword_14001F138);
      *(_QWORD *)v10 = v12;
      *(_DWORD *)(v10 + 16) = dword_14001F138;
      *(_DWORD *)(v10 + 20) = 0;
      *(_DWORD *)(v10 + 32) = v17;
      *(_DWORD *)(v10 + 36) = v9 == 1;
      *(_DWORD *)(v10 + 28) = 1;
      if ( v9 == 2 && _bittest(&v8, 0x14u) )
      {
        DistanceToMoveHigh[0] = 0;
        SetFilePointer(v12, 0, DistanceToMoveHigh, 2u);
      }
      v6 = (signed __int64)v12;
      if ( v5 == -1 )
        v6 = v10;
      if ( v6 )
        return v6;
    }
    goto LABEL_36;
  }
  return 0i64;
}
// 14001F138: using guessed type int dword_14001F138;
// 140021390: using guessed type __int64 qword_140021390;

//----- (000000014000E7F0) ----------------------------------------------------
signed __int64 __fastcall sub_14000E7F0(__int64 a1, const WCHAR *a2)
{
  const WCHAR *v2; // r14
  __int64 v3; // rsi
  signed __int64 v4; // rbx
  signed __int64 v5; // rdi
  HANDLE v6; // rbp
  int v7; // eax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  v5 = sub_1400119F8((signed int *)qword_140021390, a1);
  if ( !v5 )
    return 0i64;
  v6 = CreateFileW(v2, 0xC0000000, 0, 0i64, 2u, 0x80u, 0i64);
  if ( v6 == (HANDLE)-1i64 )
  {
    v6 = CreateFileW(v2, 0x40000000u, 0, 0i64, 5u, 0, 0i64);
    if ( v6 == (HANDLE)-1i64 )
      goto LABEL_19;
  }
  if ( !v6 )
    goto LABEL_19;
  if ( dword_14001F138 )
    *(_QWORD *)(v5 + 8) = HeapAlloc(hHeap, 0, dword_14001F138);
  else
    *(_QWORD *)(v5 + 8) = 0i64;
  *(_QWORD *)v5 = v6;
  v7 = dword_14001F138;
  *(_DWORD *)(v5 + 20) = 0;
  v4 = (signed __int64)v6;
  *(_DWORD *)(v5 + 28) = 1;
  if ( v3 == -1 )
    v4 = v5;
  *(_DWORD *)(v5 + 16) = v7;
  *(_QWORD *)(v5 + 32) = 2i64;
  if ( !v4 )
  {
LABEL_19:
    if ( v3 == -1 )
      v3 = v5;
    sub_14001192C((signed int *)qword_140021390, v3);
  }
  return v4;
}
// 14001F138: using guessed type int dword_14001F138;
// 140021390: using guessed type __int64 qword_140021390;

//----- (000000014000E930) ----------------------------------------------------
signed __int64 __fastcall sub_14000E930(__int64 a1, const WCHAR *a2, int a3)
{
  return sub_14000E5A0(a1, a2, 3, a3);
}

//----- (000000014000E940) ----------------------------------------------------
char *__fastcall sub_14000E940(__int64 a1, const WCHAR *a2)
{
  const WCHAR *v2; // rbp
  __int64 v3; // rsi
  char *v4; // rbx
  signed __int64 v5; // rdi
  char *v6; // rbp
  int v7; // eax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  v5 = sub_1400119F8((signed int *)qword_140021390, a1);
  if ( v5 )
  {
    v6 = (char *)CreateFileW(v2, 0xC0000000, 0, 0i64, 4u, 0x80u, 0i64);
    if ( (unsigned __int64)(v6 - 1) > 0xFFFFFFFFFFFFFFFDui64 )
      goto LABEL_15;
    if ( dword_14001F138 )
      *(_QWORD *)(v5 + 8) = HeapAlloc(hHeap, 0, dword_14001F138);
    else
      *(_QWORD *)(v5 + 8) = 0i64;
    *(_QWORD *)v5 = v6;
    v7 = dword_14001F138;
    *(_DWORD *)(v5 + 20) = 0;
    v4 = v6;
    *(_DWORD *)(v5 + 28) = 1;
    if ( v3 == -1 )
      v4 = (char *)v5;
    *(_DWORD *)(v5 + 16) = v7;
    *(_QWORD *)(v5 + 32) = 2i64;
    if ( !v4 )
    {
LABEL_15:
      if ( v3 == -1 )
        v3 = v5;
      sub_14001192C((signed int *)qword_140021390, v3);
    }
  }
  return v4;
}
// 14001F138: using guessed type int dword_14001F138;
// 140021390: using guessed type __int64 qword_140021390;

//----- (000000014000EA30) ----------------------------------------------------
char *__fastcall sub_14000EA30(__int64 a1, const WCHAR *a2)
{
  const WCHAR *v2; // rbp
  __int64 v3; // rsi
  char *v4; // rbx
  signed __int64 v5; // rdi
  char *v6; // rbp
  int v7; // eax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  v5 = sub_1400119F8((signed int *)qword_140021390, a1);
  if ( v5 )
  {
    v6 = (char *)CreateFileW(v2, 0x80000000, 0, 0i64, 3u, 0x80u, 0i64);
    if ( (unsigned __int64)(v6 - 1) > 0xFFFFFFFFFFFFFFFDui64 )
      goto LABEL_15;
    if ( dword_14001F138 )
      *(_QWORD *)(v5 + 8) = HeapAlloc(hHeap, 0, dword_14001F138);
    else
      *(_QWORD *)(v5 + 8) = 0i64;
    *(_QWORD *)v5 = v6;
    v7 = dword_14001F138;
    *(_DWORD *)(v5 + 20) = 0;
    v4 = v6;
    *(_DWORD *)(v5 + 28) = 1;
    if ( v3 == -1 )
      v4 = (char *)v5;
    *(_DWORD *)(v5 + 16) = v7;
    *(_DWORD *)(v5 + 32) = 2;
    *(_DWORD *)(v5 + 36) = 1;
    if ( !v4 )
    {
LABEL_15:
      if ( v3 == -1 )
        v3 = v5;
      sub_14001192C((signed int *)qword_140021390, v3);
    }
  }
  return v4;
}
// 14001F138: using guessed type int dword_14001F138;
// 140021390: using guessed type __int64 qword_140021390;

//----- (000000014000EB30) ----------------------------------------------------
signed __int64 __fastcall sub_14000EB30(__int64 a1, const WCHAR *a2, int a3)
{
  return sub_14000E5A0(a1, a2, 1, a3);
}

//----- (000000014000EB40) ----------------------------------------------------
__int64 __fastcall sub_14000EB40(__int64 a1, _BYTE *a2, int a3)
{
  signed __int64 v3; // rax
  bool v4; // zf
  __int64 result; // rax
  DWORD NumberOfBytesWritten; // [rsp+48h] [rbp+10h]

  NumberOfBytesWritten = 0;
  if ( !a2 || !*(_WORD *)a2 )
    return (signed int)NumberOfBytesWritten;
  if ( a3 != 25 )
  {
    JUMPOUT(a3 != 2, sub_14000EBE6);
    JUMPOUT(*(_QWORD *)sub_14000EBE6);
  }
  v3 = -1i64;
  if ( *(_QWORD *)(a1 + 8) )
  {
    do
      v4 = *(_WORD *)&a2[2 * v3++ + 2] == 0;
    while ( !v4 );
    result = (signed int)sub_14000ED70(a1, a2, 2 * (signed int)v3);
  }
  else
  {
    do
      v4 = *(_WORD *)&a2[2 * v3++ + 2] == 0;
    while ( !v4 );
    WriteFile(*(HANDLE *)a1, a2, 2 * v3, &NumberOfBytesWritten, 0i64);
    result = (signed int)NumberOfBytesWritten;
  }
  return result;
}
// 14000EBE6: using guessed type __int64 __fastcall sub_14000EBE6();

//----- (000000014000EC50) ----------------------------------------------------
__int64 __fastcall sub_14000EC50(_QWORD *a1, _BYTE *a2)
{
  _BYTE *v2; // rbx
  __int64 result; // rax

  v2 = a2;
  result = sub_140011998(qword_140021390, a1);
  if ( result )
    result = sub_14000EB40(result, v2, *(_DWORD *)(result + 32));
  return result;
}
// 140021390: using guessed type __int64 qword_140021390;

//----- (000000014000EC90) ----------------------------------------------------
__int64 __fastcall sub_14000EC90(_QWORD *a1, _BYTE *a2, int a3)
{
  _BYTE *v3; // rdi
  int v4; // ebx
  __int64 result; // rax

  v3 = a2;
  v4 = a3;
  result = sub_140011998(qword_140021390, a1);
  if ( result )
    result = sub_14000EB40(result, v3, v4);
  return result;
}
// 140021390: using guessed type __int64 qword_140021390;

//----- (000000014000ECE0) ----------------------------------------------------
__int64 __fastcall sub_14000ECE0(_QWORD *a1, _BYTE *a2, DWORD a3)
{
  signed int v3; // ebx
  DWORD v4; // edi
  _BYTE *v5; // rsi
  __int64 v6; // rax
  DWORD NumberOfBytesWritten; // [rsp+48h] [rbp+10h]

  v3 = 0;
  v4 = a3;
  v5 = a2;
  NumberOfBytesWritten = 0;
  if ( a2 && a3 )
  {
    v6 = sub_140011998(qword_140021390, a1);
    if ( v6 )
    {
      if ( *(_QWORD *)(v6 + 8) )
        return (signed int)sub_14000ED70(v6, v5, v4);
      WriteFile(*(HANDLE *)v6, v5, v4, &NumberOfBytesWritten, 0i64);
    }
    v3 = NumberOfBytesWritten;
  }
  return v3;
}
// 140021390: using guessed type __int64 qword_140021390;

//----- (000000014000ED70) ----------------------------------------------------
size_t __fastcall sub_14000ED70(__int64 a1, _BYTE *a2, int a3)
{
  size_t v3; // rdi
  _BYTE *v4; // rsi
  __int64 v5; // rbx
  int v6; // eax
  void *v7; // rcx
  int v8; // eax
  signed int v9; // ecx
  _BYTE *v10; // rcx
  size_t result; // rax
  signed int v12; // eax
  DWORD NumberOfBytesWritten; // [rsp+50h] [rbp+8h]
  __int64 v14; // [rsp+68h] [rbp+20h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  NumberOfBytesWritten = 0;
  if ( *(_DWORD *)(a1 + 36) )
    return 0i64;
  if ( *(_DWORD *)(a1 + 28) == 1 )
  {
    v6 = *(_DWORD *)(a1 + 20);
    v7 = *(void **)a1;
    v14 = -v6;
    SetFilePointer(v7, -v6, (PLONG)&v14 + 1, 1u);
    v8 = *(_DWORD *)(v5 + 16);
    *(_DWORD *)(v5 + 28) = 0;
    *(_DWORD *)(v5 + 20) = v8;
  }
  v9 = *(_DWORD *)(v5 + 20);
  if ( v9 <= (signed int)v3 )
  {
    sub_14000E510(v5);
    v12 = *(_DWORD *)(v5 + 16);
    if ( (signed int)v3 < v12 )
    {
      memcpy((void *)(*(_QWORD *)(v5 + 8) + v12 - *(_DWORD *)(v5 + 20)), v4, v3);
      *(_DWORD *)(v5 + 20) -= v3;
      result = v3;
    }
    else
    {
      WriteFile(*(HANDLE *)v5, v4, v3, &NumberOfBytesWritten, 0i64);
      result = (signed int)NumberOfBytesWritten;
    }
  }
  else
  {
    v10 = (_BYTE *)(*(_QWORD *)(v5 + 8) + *(_DWORD *)(v5 + 16) - v9);
    if ( (_DWORD)v3 == 1 )
    {
      *v10 = *v4;
      --*(_DWORD *)(v5 + 20);
      result = v3;
    }
    else if ( (_DWORD)v3 == 2 )
    {
      *(_WORD *)v10 = *(_WORD *)v4;
      *(_DWORD *)(v5 + 20) -= 2;
      result = v3;
    }
    else
    {
      if ( (_DWORD)v3 == 4 )
        *(_DWORD *)v10 = *(_DWORD *)v4;
      else
        memcpy(v10, v4, v3);
      *(_DWORD *)(v5 + 20) -= v3;
      result = v3;
    }
  }
  return result;
}

//----- (000000014000EEC0) ----------------------------------------------------
CHAR *__fastcall sub_14000EEC0(UINT CodePage, LPCWSTR lpWideCharStr, int *a3)
{
  int *v3; // rdi
  const WCHAR *v4; // rsi
  UINT v5; // ebp
  int v6; // eax
  CHAR *result; // rax
  CHAR *v8; // rbx

  v3 = a3;
  v4 = lpWideCharStr;
  v5 = CodePage;
  v6 = WideCharToMultiByte(CodePage, 0, lpWideCharStr, -1, 0i64, 0, 0i64, 0i64);
  *(_QWORD *)v3 = v6;
  if ( !v6 )
    return 0i64;
  result = (CHAR *)HeapAlloc(hHeap, 0, v6 + 1i64);
  v8 = result;
  if ( result )
  {
    WideCharToMultiByte(v5, 0, v4, -1, result, *v3, 0i64, 0i64);
    --*(_QWORD *)v3;
    result = v8;
  }
  return result;
}

//----- (000000014000EF74) ----------------------------------------------------
void *__fastcall sub_14000EF74(__int64 a1)
{
  return sub_14000F034((_BYTE *)(a1 + 4), (_DWORD *)(a1 + 68));
}

//----- (000000014000EF98) ----------------------------------------------------
_DWORD *__fastcall sub_14000EF98(__int64 a1, int a2)
{
  int v2; // edi
  _DWORD *v3; // rax
  _DWORD *v4; // rbx

  v2 = a2;
  v3 = HeapAlloc(hHeap, 0, 0xE4ui64);
  v4 = v3;
  *v3 = 160;
  sub_14000F168(v3 + 17, v2);
  return v4;
}

//----- (000000014000EFDC) ----------------------------------------------------
signed __int64 sub_14000EFDC()
{
  char *v0; // rax

  v0 = sub_1400115E0(3);
  if ( v0 )
  {
    *((_QWORD *)v0 + 1) = sub_14000EF98;
    *((_QWORD *)v0 + 2) = sub_14000F028;
    *((_QWORD *)v0 + 3) = sub_14000EF74;
    *((_QWORD *)v0 + 4) = sub_14000EF84;
  }
  return 1i64;
}
// 14000EF84: using guessed type __int64 __fastcall sub_14000EF84();
// 14000F028: using guessed type __int64 __fastcall sub_14000F028();

//----- (000000014000F034) ----------------------------------------------------
void *__fastcall sub_14000F034(_BYTE *a1, _DWORD *a2)
{
  unsigned int v2; // edi
  _DWORD *v3; // rbx
  _BYTE *v4; // r14
  unsigned int v5; // er8
  char *v6; // r9
  int v7; // ecx
  _BOOL8 v8; // rax
  unsigned __int64 v9; // r8
  char v10; // al
  char v11; // cl
  unsigned __int64 v12; // rax
  char Dst; // [rsp+48h] [rbp+10h]

  v2 = 0;
  v3 = a2;
  v4 = a1;
  v5 = 0;
  v6 = &Dst;
  do
  {
    v7 = 8 * (3 - (v5 & 3));
    v8 = v5++ < 4;
    *v6++ = a2[v8 + 5] >> v7;
  }
  while ( v5 < 8 );
  sub_140010634(a2, "", 1u);
  while ( (v3[5] & 0x1F8) != 448 )
    sub_140010634(v3, (char *)&unk_140019E64, 1u);
  sub_140010634(v3, &Dst, 8u);
  v9 = 0i64;
  do
  {
    v10 = v2++;
    v11 = 3 - (v10 & 3);
    v12 = v9++;
    *v4++ = v3[v12 >> 2] >> 8 * v11;
  }
  while ( v2 < 0x14 );
  memset(v3 + 7, 0, 0x40ui64);
  memset(v3, 0, 0x14ui64);
  memset(v3 + 5, 0, 8ui64);
  memset(&Dst, 0, 8ui64);
  return memset(v3 + 24, 0, 0x40ui64);
}

//----- (000000014000F168) ----------------------------------------------------
void __fastcall sub_14000F168(_DWORD *a1, int a2)
{
  a1[6] = 0;
  a1[5] = 0;
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[4] = -1009589776;
  a1[23] = a2;
}

//----- (000000014000F198) ----------------------------------------------------
__int64 __fastcall sub_14000F198(_DWORD *a1, const void *a2, _DWORD *a3)
{
  _DWORD *v3; // r15
  _DWORD *v4; // rdi
  int v5; // er9
  int v6; // er8
  int v7; // er10
  int v8; // ecx
  unsigned int v9; // er11
  unsigned int v10; // ST5C_4
  int v11; // er11
  int v12; // ebx
  unsigned int v13; // edx
  unsigned int v14; // ST3C_4
  int v15; // edx
  int v16; // er8
  unsigned int v17; // ST30_4
  int v18; // er8
  unsigned int v19; // er9
  int v20; // er9
  int v21; // er9
  int v22; // ecx
  unsigned int v23; // er10
  int v24; // er10
  int v25; // ecx
  unsigned int v26; // ST50_4
  int v27; // er11
  int v28; // ecx
  unsigned int v29; // ST4C_4
  int v30; // edx
  int v31; // ecx
  unsigned int v32; // ST48_4
  int v33; // er8
  unsigned int v34; // ST60_4
  int v35; // ebx
  int v36; // ebx
  int v37; // edi
  unsigned int v38; // ST28_4
  int v39; // eax
  int v40; // esi
  int v41; // edi
  int v42; // ecx
  unsigned int v43; // ST34_4
  int v44; // eax
  int v45; // esi
  unsigned int v46; // er9
  unsigned int v47; // ST40_4
  int v48; // er9
  unsigned int v49; // ST38_4
  int v50; // er10
  int v51; // er10
  int v52; // er11
  unsigned int v53; // ST2C_4
  int v54; // er11
  unsigned int v55; // er15
  int v56; // ST44_4
  int v57; // edx
  unsigned int v58; // ST54_4
  int v59; // edx
  int v60; // er8
  unsigned int v61; // ST58_4
  int v62; // er8
  int v63; // ecx
  int v64; // er9
  int v65; // er12
  int v66; // ecx
  int v67; // er10
  int v68; // ecx
  int v69; // ebx
  int v70; // er11
  int v71; // ecx
  int v72; // edx
  int v73; // ecx
  int v74; // er8
  int v75; // esi
  int v76; // er14
  int v77; // er15
  int v78; // ecx
  int v79; // er9
  int v80; // ecx
  int v81; // edi
  int v82; // er10
  int v83; // ecx
  int v84; // er11
  int v85; // er13
  int v86; // edx
  int v87; // er8
  int v88; // eax
  int v89; // ST30_4
  int v90; // ecx
  int v91; // er9
  int v92; // eax
  int v93; // ST28_4
  int v94; // ecx
  int v95; // er10
  int v96; // ebp
  int v97; // ST34_4
  int v98; // ecx
  int v99; // er11
  int v100; // eax
  int v101; // ST3C_4
  int v102; // ecx
  int v103; // edx
  int v104; // eax
  int v105; // ST2C_4
  int v106; // ecx
  int v107; // er8
  int v108; // ecx
  int v109; // ebp
  int v110; // ST58_4
  int v111; // er9
  int v112; // eax
  int v113; // ST44_4
  int v114; // ecx
  int v115; // er10
  int v116; // eax
  int v117; // ST40_4
  int v118; // ecx
  int v119; // er11
  int v120; // eax
  int v121; // ST38_4
  int v122; // ebp
  int v123; // ecx
  int v124; // edx
  int v125; // ecx
  int v126; // er12
  int v127; // er8
  int v128; // er12
  int v129; // ecx
  int v130; // er9
  int v131; // ecx
  int v132; // er12
  int v133; // ST48_4
  int v134; // ST50_4
  int v135; // er10
  int v136; // er11
  int v137; // ebx
  int v138; // er14
  int v139; // er12
  int v140; // ebx
  int v141; // ST54_4
  int v142; // eax
  int v143; // edi
  int v144; // er13
  int v145; // eax
  int v146; // ST30_4
  int v147; // ST28_4
  int v148; // eax
  int v149; // ecx
  int v150; // er8
  int v151; // ecx
  int v152; // edi
  int v153; // er9
  int v154; // ST34_4
  int v155; // ecx
  int v156; // er10
  int v157; // er14
  int v158; // ecx
  int v159; // ST38_4
  int v160; // er14
  int v161; // er11
  int v162; // ebp
  int v163; // ecx
  int v164; // ebx
  int v165; // er12
  int v166; // er8
  int v167; // ST2C_4
  int v168; // ST3C_4
  int v169; // ST4C_4
  int v170; // ecx
  int v171; // er9
  int v172; // ebp
  int v173; // edi
  int v174; // ecx
  int v175; // er12
  int v176; // eax
  int v177; // ST44_4
  int v178; // ST40_4
  int v179; // er10
  int v180; // ST5C_4
  int v181; // er11
  int v182; // ecx
  int v183; // ebx
  int v184; // ecx
  int v185; // eax
  int v186; // er8
  int v187; // ebp
  int v188; // ecx
  int v189; // er9
  int v190; // ecx
  int v191; // er13
  int v192; // eax
  int v193; // ebp
  int v194; // er10
  int v195; // er14
  int v196; // ecx
  int v197; // ST48_4
  int v198; // er11
  int v199; // ecx
  int v200; // eax
  int v201; // edi
  int v202; // esi
  int v203; // er13
  int v204; // er14
  int v205; // ecx
  int v206; // ebx
  int v207; // eax
  int v208; // edx
  int v209; // ST50_4
  int v210; // ST30_4
  int v211; // ecx
  int v212; // ST38_4
  int v213; // er9
  int v214; // ST34_4
  int v215; // ecx
  int v216; // er10
  int v217; // eax
  int v218; // ecx
  int v219; // ecx
  int v220; // eax
  int v221; // er15
  int v222; // er8
  int v223; // er14
  int v224; // ecx
  int v225; // ecx
  int v226; // er11
  int v227; // eax
  int v228; // er8
  int v229; // ST28_4
  int v230; // ST2C_4
  int v231; // ST3C_4
  int v232; // ST4C_4
  int v233; // edx
  int v234; // er9
  int v235; // er10
  int v236; // ebx
  int v237; // eax
  int v238; // ST44_4
  int v239; // ST60_4
  int v240; // er11
  int v241; // er13
  int v242; // er12
  int v243; // eax
  int v244; // er8
  int v245; // eax
  int v246; // edx
  int v247; // eax
  int v248; // er9
  int v249; // eax
  int v250; // ebx
  int v251; // er15
  int v252; // eax
  int v253; // er11
  int v254; // er15
  int v255; // eax
  int v256; // er14
  int v257; // esi
  int v258; // ebp
  int v259; // er10
  int v260; // er9
  int v261; // er8
  int v262; // eax
  int v263; // er12
  int v264; // edi
  int v265; // edx
  int v266; // ebx
  int v267; // eax
  int v268; // er11
  int v269; // esi
  int v270; // eax
  int v271; // er10
  int v272; // eax
  int v273; // er9
  int v274; // er12
  int v275; // edx
  int v276; // er8
  int v277; // er13
  int v278; // eax
  int v279; // edx
  __int64 result; // rax
  _DWORD *v281; // rcx
  _DWORD *v282; // [rsp+20h] [rbp-88h]
  _DWORD *v283; // [rsp+B0h] [rbp+8h]
  unsigned int v284; // [rsp+C0h] [rbp+18h]
  int v285; // [rsp+C0h] [rbp+18h]
  int v286; // [rsp+C0h] [rbp+18h]
  int v287; // [rsp+C0h] [rbp+18h]
  int v288; // [rsp+C0h] [rbp+18h]
  int v289; // [rsp+C0h] [rbp+18h]
  unsigned int v290; // [rsp+C8h] [rbp+20h]
  int v291; // [rsp+C8h] [rbp+20h]
  int v292; // [rsp+C8h] [rbp+20h]
  int v293; // [rsp+C8h] [rbp+20h]
  int v294; // [rsp+C8h] [rbp+20h]

  v283 = a1;
  v3 = a3;
  v282 = a3;
  v4 = a1;
  if ( a3 )
  {
    memcpy(a3, a2, 0x40ui64);
  }
  else
  {
    v3 = a2;
    v282 = a2;
  }
  v5 = v4[2];
  v6 = v4[3];
  v7 = v4[1];
  v8 = v7 & (v5 ^ v4[3]);
  v7 = __ROR4__(v7, 2);
  v9 = __ROL4__(*v3, 8) & 0xFF00FF | __ROR4__(*v3, 8) & 0xFF00FF00;
  v10 = v9;
  v11 = v4[4] + 1518500249 + (v6 ^ v8) + __ROL4__(*v4, 5) + v9;
  v12 = __ROR4__(*v4, 2);
  v13 = __ROL4__(v3[1], 8) & 0xFF00FF | __ROR4__(v3[1], 8) & 0xFF00FF00;
  v14 = v13;
  v15 = v6 + 1518500249 + (v5 ^ *v4 & (v7 ^ v5)) + __ROL4__(v11, 5) + v13;
  v16 = v11 & (v12 ^ v7);
  v11 = __ROR4__(v11, 2);
  v17 = __ROL4__(v3[2], 8) & 0xFF00FF | __ROR4__(v3[2], 8) & 0xFF00FF00;
  v18 = v5 + 1518500249 + v17 + __ROL4__(v15, 5) + (v7 ^ v16);
  v19 = __ROL4__(v3[3], 8) & 0xFF00FF | __ROR4__(v3[3], 8) & 0xFF00FF00;
  v290 = v19;
  v20 = (v12 ^ v15 & (v12 ^ v11)) + __ROL4__(v18, 5) + v19;
  v15 = __ROR4__(v15, 2);
  v21 = v7 + 1518500249 + v20;
  v22 = v11 ^ v18 & (v15 ^ v11);
  v18 = __ROR4__(v18, 2);
  v23 = __ROL4__(v3[4], 8) & 0xFF00FF | __ROR4__(v3[4], 8) & 0xFF00FF00;
  v284 = v23;
  v24 = v12 + 1518500249 + v22 + __ROL4__(v21, 5) + v23;
  v25 = v15 ^ v21 & (v18 ^ v15);
  v21 = __ROR4__(v21, 2);
  v26 = __ROL4__(v3[5], 8) & 0xFF00FF | __ROR4__(v3[5], 8) & 0xFF00FF00;
  v27 = v26 + __ROL4__(v24, 5) + 1518500249 + v25 + v11;
  v28 = v18 ^ v24 & (v21 ^ v18);
  v29 = __ROL4__(v3[6], 8) & 0xFF00FF | __ROR4__(v3[6], 8) & 0xFF00FF00;
  v24 = __ROR4__(v24, 2);
  v30 = v29 + __ROL4__(v27, 5) + 1518500249 + v28 + v15;
  v31 = v21 ^ v27 & (v24 ^ v21);
  v32 = __ROL4__(v3[7], 8) & 0xFF00FF | __ROR4__(v3[7], 8) & 0xFF00FF00;
  v27 = __ROR4__(v27, 2);
  v33 = v32 + __ROL4__(v30, 5) + v31 + v18 + 1518500249;
  v34 = __ROL4__(v3[8], 8) & 0xFF00FF | __ROR4__(v3[8], 8) & 0xFF00FF00;
  v35 = v24 ^ v30 & (v24 ^ v27);
  v30 = __ROR4__(v30, 2);
  v36 = v21 + 1518500249 + v34 + __ROL4__(v33, 5) + v35;
  v37 = v27 ^ v33 & (v30 ^ v27);
  v33 = __ROR4__(v33, 2);
  v38 = __ROL4__(v3[9], 8) & 0xFF00FF | __ROR4__(v3[9], 8) & 0xFF00FF00;
  v39 = __ROL4__(v36, 5);
  v40 = v30 ^ v36 & (v33 ^ v30);
  v36 = __ROR4__(v36, 2);
  v41 = v24 + v38 + v39 + 1518500249 + v37;
  v42 = v33 ^ v41 & (v36 ^ v33);
  v43 = __ROL4__(v3[10], 8) & 0xFF00FF | __ROR4__(v3[10], 8) & 0xFF00FF00;
  v44 = v43 + __ROL4__(v41, 5) + 1518500249;
  v41 = __ROR4__(v41, 2);
  v45 = v27 + v44 + v40;
  v46 = __ROL4__(v3[11], 8) & 0xFF00FF | __ROR4__(v3[11], 8) & 0xFF00FF00;
  v47 = v46;
  v48 = v30 + 1518500249 + v42 + __ROL4__(v45, 5) + v46;
  v49 = __ROL4__(v3[12], 8) & 0xFF00FF | __ROR4__(v3[12], 8) & 0xFF00FF00;
  v50 = v36 ^ v45 & (v41 ^ v36);
  v45 = __ROR4__(v45, 2);
  v51 = v33 + 1518500249 + v49 + __ROL4__(v48, 5) + v50;
  v52 = v41 ^ v48 & (v41 ^ v45);
  v53 = __ROL4__(v3[13], 8) & 0xFF00FF | __ROR4__(v3[13], 8) & 0xFF00FF00;
  v48 = __ROR4__(v48, 2);
  v54 = v36 + 1518500249 + v53 + __ROL4__(v51, 5) + v52;
  v55 = __ROL4__(v3[14], 8) & 0xFF00FF | __ROR4__(v3[14], 8) & 0xFF00FF00;
  v56 = __ROL4__(v34 ^ v53 ^ v10 ^ v17, 1);
  *v282 = v56;
  v57 = v45 ^ v51 & (v48 ^ v45);
  v58 = v55;
  v51 = __ROR4__(v51, 2);
  v59 = v41 + 1518500249 + v55 + __ROL4__(v54, 5) + v57;
  v60 = v48 ^ v54 & (v51 ^ v48);
  v61 = __ROL4__(v282[15], 8) & 0xFF00FF | __ROR4__(v282[15], 8) & 0xFF00FF00;
  v54 = __ROR4__(v54, 2);
  v62 = v45 + 1518500249 + v61 + __ROL4__(v59, 5) + v60;
  v63 = v59 & (v54 ^ v51);
  v59 = __ROR4__(v59, 2);
  v64 = v56 + __ROL4__(v62, 5) + 1518500249 + (v51 ^ v63) + v48;
  v65 = v38 ^ v55 ^ v14 ^ v290;
  v66 = v54 ^ v62 & (v59 ^ v54);
  v291 = __ROL4__(v26 ^ v47 ^ v56 ^ v290, 1);
  v65 = __ROL4__(v65, 1);
  v282[1] = v65;
  v62 = __ROR4__(v62, 2);
  v67 = v65 + __ROL4__(v64, 5) + 1518500249 + v66 + v51;
  v68 = v64 & (v59 ^ v62);
  v64 = __ROR4__(v64, 2);
  v69 = __ROL4__(v43 ^ v61 ^ v17 ^ v284, 1);
  v282[2] = v69;
  v282[3] = v291;
  v70 = v69 + __ROL4__(v67, 5) + 1518500249 + (v59 ^ v68) + v54;
  v71 = v291 + 1518500249 + __ROL4__(v70, 5) + (v62 ^ v67 & (v64 ^ v62));
  v67 = __ROR4__(v67, 2);
  v72 = v71 + v59;
  v285 = __ROL4__(v29 ^ v49 ^ v65 ^ v284, 1);
  v282[4] = v285;
  v73 = v70 ^ v67 ^ v64;
  v70 = __ROR4__(v70, 2);
  v74 = v285 + 1859775393 + __ROL4__(v72, 5) + v73 + v62;
  v75 = __ROL4__(v26 ^ v32 ^ v53 ^ v69, 1);
  v76 = __ROL4__(v29 ^ v34 ^ v55 ^ v291, 1);
  v282[5] = v75;
  v77 = __ROL4__(v32 ^ v38 ^ v61 ^ v285, 1);
  v78 = v75 + __ROL4__(v74, 5) + 1859775393 + (v72 ^ v70 ^ v67);
  v72 = __ROR4__(v72, 2);
  v79 = v78 + v64;
  v282[6] = v76;
  v80 = v72 ^ v70 ^ v74;
  v74 = __ROR4__(v74, 2);
  v81 = __ROL4__(v75 ^ v34 ^ v43 ^ v56, 1);
  v82 = v76 + __ROL4__(v79, 5) + 1859775393 + v80 + v67;
  v282[7] = v77;
  v83 = v72 ^ v79 ^ v74;
  v79 = __ROR4__(v79, 2);
  v84 = v77 + __ROL4__(v82, 5) + 1859775393 + v83 + v70;
  v282[8] = v81;
  v85 = __ROL4__(v76 ^ v38 ^ v47 ^ v65, 1);
  v86 = v81 + __ROL4__(v84, 5) + 1859775393 + (v82 ^ v79 ^ v74) + v72;
  v282[9] = v85;
  v82 = __ROR4__(v82, 2);
  v87 = v85 + __ROL4__(v86, 5) + 1859775393 + (v84 ^ v82 ^ v79) + v74;
  v84 = __ROR4__(v84, 2);
  v88 = __ROL4__(v77 ^ v43 ^ v49 ^ v69, 1);
  v282[10] = v88;
  v89 = __ROL4__(v77 ^ v43 ^ v49 ^ v69, 1);
  v90 = v88 + 1859775393 + __ROL4__(v87, 5) + (v86 ^ v84 ^ v82);
  v86 = __ROR4__(v86, 2);
  v91 = v90 + v79;
  v92 = __ROL4__(v81 ^ v47 ^ v53 ^ v291, 1);
  v282[11] = v92;
  v93 = __ROL4__(v81 ^ v47 ^ v53 ^ v291, 1);
  v94 = v84 ^ v87;
  v87 = __ROR4__(v87, 2);
  v95 = v92 + 1859775393 + __ROL4__(v91, 5) + (v86 ^ v94) + v82;
  v96 = __ROL4__(v85 ^ v49 ^ v58 ^ v285, 1);
  v282[12] = v96;
  v97 = __ROL4__(v85 ^ v49 ^ v58 ^ v285, 1);
  v98 = v96 + 1859775393 + __ROL4__(v95, 5) + (v86 ^ v91 ^ v87);
  v91 = __ROR4__(v91, 2);
  v99 = v98 + v84;
  v100 = __ROL4__(v75 ^ v89 ^ v53 ^ v61, 1);
  v282[13] = v100;
  v101 = __ROL4__(v75 ^ v89 ^ v53 ^ v61, 1);
  v102 = v100 + 1859775393 + __ROL4__(v99, 5) + (v95 ^ v91 ^ v87);
  v95 = __ROR4__(v95, 2);
  v103 = v102 + v86;
  v104 = __ROL4__(v76 ^ v93 ^ v58 ^ v56, 1);
  v105 = v104;
  v282[14] = v104;
  v106 = v99 ^ v95 ^ v91;
  v99 = __ROR4__(v99, 2);
  v107 = v104 + 1859775393 + __ROL4__(v103, 5) + v106 + v87;
  v108 = v103 ^ v99 ^ v95;
  v109 = __ROL4__(v77 ^ v97 ^ v61 ^ v65, 1);
  v282[15] = v109;
  v103 = __ROR4__(v103, 2);
  v110 = __ROL4__(v77 ^ v97 ^ v61 ^ v65, 1);
  v111 = v109 + __ROL4__(v107, 5) + 1859775393 + v108 + v91;
  v112 = __ROL4__(v81 ^ v101 ^ v56 ^ v69, 1);
  *v282 = v112;
  v113 = __ROL4__(v81 ^ v101 ^ v56 ^ v69, 1);
  v114 = v103 ^ v99 ^ v107;
  v107 = __ROR4__(v107, 2);
  v115 = v112 + __ROL4__(v111, 5) + 1859775393 + v114 + v95;
  v116 = __ROL4__(v85 ^ v105 ^ v65 ^ v291, 1);
  v282[1] = v116;
  v117 = __ROL4__(v85 ^ v105 ^ v65 ^ v291, 1);
  v118 = v111 ^ v107;
  v111 = __ROR4__(v111, 2);
  v119 = v116 + 1859775393 + __ROL4__(v115, 5) + (v103 ^ v118) + v99;
  v120 = __ROL4__(v89 ^ v109 ^ v69 ^ v285, 1);
  v282[2] = v120;
  v121 = __ROL4__(v89 ^ v109 ^ v69 ^ v285, 1);
  v122 = v93;
  v123 = v115 ^ v111 ^ v107;
  v115 = __ROR4__(v115, 2);
  v124 = v120 + 1859775393 + __ROL4__(v119, 5) + v123 + v103;
  v125 = v119 ^ v115 ^ v111;
  v126 = __ROL4__(v75 ^ v93 ^ v113 ^ v291, 1);
  v282[3] = v126;
  v292 = __ROL4__(v75 ^ v93 ^ v113 ^ v291, 1);
  v119 = __ROR4__(v119, 2);
  v127 = v126 + 1859775393 + __ROL4__(v124, 5) + v125 + v107;
  v128 = __ROL4__(v76 ^ v97 ^ v117 ^ v285, 1);
  v129 = v124 ^ v119 ^ v115;
  v282[4] = v128;
  v286 = __ROL4__(v76 ^ v97 ^ v117 ^ v285, 1);
  v124 = __ROR4__(v124, 2);
  v130 = v128 + 1859775393 + __ROL4__(v127, 5) + v129 + v111;
  v131 = v119 ^ v127;
  v127 = __ROR4__(v127, 2);
  v132 = __ROL4__(v75 ^ v77 ^ v101 ^ v121, 1);
  v282[5] = v132;
  v133 = __ROL4__(v75 ^ v77 ^ v101 ^ v121, 1);
  v134 = __ROL4__(v76 ^ v81 ^ v105 ^ v292, 1);
  v282[6] = v134;
  v135 = v132 + 1859775393 + __ROL4__(v130, 5) + (v124 ^ v131) + v115;
  v136 = v134 + __ROL4__(v135, 5) + 1859775393 + (v124 ^ v130 ^ v127) + v119;
  v130 = __ROR4__(v130, 2);
  v137 = v135 ^ v130 ^ v127;
  v138 = __ROL4__(v77 ^ v85 ^ v110 ^ v286, 1);
  v282[7] = v138;
  v135 = __ROR4__(v135, 2);
  v139 = v89;
  v140 = v124 + 1859775393 + v138 + __ROL4__(v136, 5) + v137;
  v141 = __ROL4__(v77 ^ v85 ^ v110 ^ v286, 1);
  v142 = v81 ^ v89 ^ v113;
  v143 = v85 ^ v93 ^ v117;
  v144 = v121;
  v145 = __ROL4__(v133 ^ v142, 1);
  v282[8] = v145;
  v146 = v145;
  v147 = __ROL4__(v134 ^ v143, 1);
  v148 = v136 & v135;
  v149 = v130 & (v136 | v135);
  v136 = __ROR4__(v136, 2);
  v282[9] = v147;
  v150 = v127 + v146 + (v148 | v149) + __ROL4__(v140, 5) - 1894007588;
  v151 = v147 + (v140 & v136 | v135 & (v140 | v136));
  v140 = __ROR4__(v140, 2);
  v152 = v97;
  v153 = v130 + v151 + __ROL4__(v150, 5) - 1894007588;
  v154 = __ROL4__(v138 ^ v139 ^ v97 ^ v121, 1);
  v155 = v135 + v154 + (v140 & v150 | v136 & (v140 | v150));
  v282[10] = v154;
  v150 = __ROR4__(v150, 2);
  v156 = v155 + __ROL4__(v153, 5) - 1894007588;
  v157 = __ROL4__(v146 ^ v122 ^ v101 ^ v292, 1);
  v158 = v157 + (v153 & v150 | v140 & (v153 | v150));
  v282[11] = v157;
  v153 = __ROR4__(v153, 2);
  v159 = __ROL4__(v146 ^ v122 ^ v101 ^ v292, 1);
  v160 = v105;
  v161 = v136 + v158 + __ROL4__(v156, 5) - 1894007588;
  v162 = __ROL4__(v147 ^ v152 ^ v105 ^ v286, 1);
  v163 = v162 + (v156 & v153 | v150 & (v156 | v153));
  v282[12] = v162;
  v156 = __ROR4__(v156, 2);
  v164 = v140 + v163 + __ROL4__(v161, 5) - 1894007588;
  v165 = __ROL4__(v133 ^ v154 ^ v101 ^ v110, 1);
  v166 = v150 + v165 + (v161 & v156 | v153 & (v161 | v156)) + __ROL4__(v164, 5) - 1894007588;
  v167 = __ROL4__(v147 ^ v152 ^ v105 ^ v286, 1);
  v161 = __ROR4__(v161, 2);
  v168 = __ROL4__(v133 ^ v154 ^ v101 ^ v110, 1);
  v282[13] = v165;
  v169 = __ROL4__(v134 ^ v159 ^ v160 ^ v113, 1);
  v282[14] = v169;
  v170 = v153 + v169 + (v164 & v161 | v156 & (v164 | v161));
  v164 = __ROR4__(v164, 2);
  v171 = v170 + __ROL4__(v166, 5) - 1894007588;
  v172 = __ROL4__(v141 ^ v167 ^ v110 ^ v117, 1);
  v282[15] = v172;
  v173 = __ROL4__(v146 ^ v165 ^ v113 ^ v144, 1);
  v174 = v161 & (v164 | v166);
  *v282 = v173;
  v175 = __ROL4__(v147 ^ v169 ^ v117 ^ v292, 1);
  v176 = v164 & v166;
  v166 = __ROR4__(v166, 2);
  v282[1] = v175;
  v177 = __ROL4__(v141 ^ v167 ^ v110 ^ v117, 1);
  v178 = v173;
  v179 = v156 + v172 + (v176 | v174) + __ROL4__(v171, 5) - 1894007588;
  v180 = __ROL4__(v154 ^ v172 ^ v144 ^ v286, 1);
  v282[2] = v180;
  v181 = v161 + v173 + (v171 & v166 | v164 & (v171 | v166)) + __ROL4__(v179, 5) - 1894007588;
  v171 = __ROR4__(v171, 2);
  v182 = v175 + (v179 & v171 | v166 & (v179 | v171));
  v179 = __ROR4__(v179, 2);
  v183 = v164 + v182 + __ROL4__(v181, 5) - 1894007588;
  v184 = v171 & (v181 | v179);
  v185 = v181 & v179;
  v181 = __ROR4__(v181, 2);
  v186 = v166 + v180 + (v185 | v184) + __ROL4__(v183, 5) - 1894007588;
  v187 = __ROL4__(v133 ^ v159 ^ v173 ^ v292, 1);
  v188 = v187 + (v183 & v181 | v179 & (v183 | v181));
  v282[3] = v187;
  v183 = __ROR4__(v183, 2);
  v189 = v171 + v188 + __ROL4__(v186, 5) - 1894007588;
  v293 = __ROL4__(v133 ^ v159 ^ v173 ^ v292, 1);
  v190 = v181 & (v183 | v186);
  v191 = __ROL4__(v134 ^ v167 ^ v175 ^ v286, 1);
  v282[4] = v191;
  v192 = v186;
  v186 = __ROR4__(v186, 2);
  v193 = __ROL4__(v134 ^ v146 ^ v169 ^ v187, 1);
  v282[6] = v193;
  v287 = __ROL4__(v134 ^ v167 ^ v175 ^ v286, 1);
  v194 = v179 + v191 + (v183 & v192 | v190) + __ROL4__(v189, 5) - 1894007588;
  v195 = __ROL4__(v133 ^ v141 ^ v168 ^ v180, 1);
  v282[5] = v195;
  v196 = v189 & v186 | v183 & (v189 | v186);
  v189 = __ROR4__(v189, 2);
  v197 = __ROL4__(v133 ^ v141 ^ v168 ^ v180, 1);
  v198 = __ROL4__(v194, 5) + v195 + v196 - 1894007588 + v181;
  v199 = v186 & (v194 | v189);
  v200 = v194 & v189;
  v194 = __ROR4__(v194, 2);
  v201 = v183 - 1894007588 + v193 + (v200 | v199) + __ROL4__(v198, 5);
  v202 = __ROL4__(v141 ^ v147 ^ v177 ^ v287, 1);
  v282[7] = v202;
  v203 = v195 ^ v146 ^ v154 ^ v178;
  v204 = v159;
  v205 = v198 & v194 | v189 & (v198 | v194);
  v198 = __ROR4__(v198, 2);
  v203 = __ROL4__(v203, 1);
  v282[8] = v203;
  v206 = v186 + v202 + v205 - 1894007588 + __ROL4__(v201, 5);
  v207 = v201 & v198;
  v208 = v186 + v202 + v205 - 1894007588 + __ROL4__(v201, 5);
  v209 = __ROL4__(v141 ^ v147 ^ v177 ^ v287, 1);
  v210 = v203;
  v211 = v194 & (v201 | v198);
  v201 = __ROR4__(v201, 2);
  v212 = __ROL4__(v193 ^ v147 ^ v159 ^ v175, 1);
  v282[9] = v212;
  v213 = v189 + v203 + (v207 | v211) + __ROL4__(v208, 5) - 1894007588;
  v214 = __ROL4__(v202 ^ v154 ^ v167 ^ v180, 1);
  v282[10] = v214;
  v215 = v194 + v212 + (v201 & v206 | v198 & (v201 | v206));
  v206 = __ROR4__(v206, 2);
  v216 = v215 + __ROL4__(v213, 5) - 1894007588;
  v217 = v213 & v206;
  v218 = v201 & (v213 | v206);
  v213 = __ROR4__(v213, 2);
  v219 = v214 + (v217 | v218);
  v220 = v216 & v213;
  v221 = __ROL4__(v203 ^ v204 ^ v168 ^ v293, 1);
  v222 = v198 + v219 + __ROL4__(v216, 5) - 1894007588;
  v223 = __ROL4__(v212 ^ v167 ^ v169 ^ v287, 1);
  v224 = v206 & (v216 | v213);
  v282[11] = v221;
  v216 = __ROR4__(v216, 2);
  v282[12] = v223;
  v225 = (v220 | v224) - 1894007588;
  v226 = __ROR4__(v222, 2);
  v227 = v206 - 899497514 + v223 + (v222 ^ v216 ^ v213);
  v228 = v201 + v221 + v225 + __ROL4__(v222, 5);
  v229 = v221;
  v230 = __ROL4__(v212 ^ v167 ^ v169 ^ v287, 1);
  v231 = __ROL4__(v197 ^ v214 ^ v168 ^ v177, 1);
  v282[13] = v231;
  v232 = __ROL4__(v193 ^ v221 ^ v169 ^ v178, 1);
  v233 = v227 + __ROL4__(v228, 5);
  v282[14] = v232;
  v234 = v213 + v231 + (v228 ^ v226 ^ v216) + __ROL4__(v233, 5) - 899497514;
  v228 = __ROR4__(v228, 2);
  v235 = v216 + v232 + (v228 ^ v226 ^ v233) + __ROL4__(v234, 5) - 899497514;
  v233 = __ROR4__(v233, 2);
  v236 = __ROL4__(v202 ^ v223 ^ v177 ^ v175, 1);
  v282[15] = v236;
  v237 = v234 ^ v233;
  v238 = __ROL4__(v202 ^ v223 ^ v177 ^ v175, 1);
  v234 = __ROR4__(v234, 2);
  v239 = __ROL4__(v203 ^ v231 ^ v178 ^ v180, 1);
  v240 = v226 + v236 + (v228 ^ v237) + __ROL4__(v235, 5) - 899497514;
  v241 = __ROL4__(v212 ^ v232 ^ v175 ^ v293, 1);
  *v282 = v239;
  v242 = __ROL4__(v214 ^ v236 ^ v180 ^ v287, 1);
  v243 = v228 + v239 + (v235 ^ v234 ^ v233);
  v235 = __ROR4__(v235, 2);
  v244 = v243 + __ROL4__(v240, 5) - 899497514;
  v282[1] = v241;
  v294 = __ROL4__(v197 ^ v221 ^ v239 ^ v293, 1);
  v245 = v241 + (v240 ^ v235 ^ v234);
  v240 = __ROR4__(v240, 2);
  v246 = v233 + v245 + __ROL4__(v244, 5) - 899497514;
  v282[2] = v242;
  v247 = v234 + v242 + (v244 ^ v240 ^ v235);
  v244 = __ROR4__(v244, 2);
  v248 = v247 + __ROL4__(v246, 5) - 899497514;
  v282[3] = v294;
  v249 = v246;
  v246 = __ROR4__(v246, 2);
  v250 = v235 + v294 + (v244 ^ v240 ^ v249) + __ROL4__(v248, 5) - 899497514;
  v251 = __ROL4__(v193 ^ v223 ^ v241 ^ v287, 1);
  v282[4] = v251;
  v288 = __ROL4__(v193 ^ v223 ^ v241 ^ v287, 1);
  v252 = v244 ^ v248 ^ v246;
  v248 = __ROR4__(v248, 2);
  v253 = __ROL4__(v250, 5) + v251 - 899497514 + v252 + v240;
  v254 = __ROL4__(v197 ^ v202 ^ v231 ^ v242, 1);
  v282[5] = v254;
  v255 = v244 + v254 + (v250 ^ v248 ^ v246) - 899497514;
  v250 = __ROR4__(v250, 2);
  v256 = __ROL4__(v193 ^ v210 ^ v232 ^ v294, 1);
  v257 = v255 + __ROL4__(v253, 5);
  v282[6] = v256;
  v258 = __ROL4__(v209 ^ v212 ^ v238 ^ v288, 1);
  v282[7] = v258;
  v259 = v246 - 899497514 + v256 + (v253 ^ v250 ^ v248) + __ROL4__(v257, 5);
  v253 = __ROR4__(v253, 2);
  v260 = __ROL4__(v259, 5) + v258 + (v257 ^ v253 ^ v250) - 899497514 + v248;
  v257 = __ROR4__(v257, 2);
  v261 = __ROL4__(v254 ^ v210 ^ v214 ^ v239, 1);
  v282[8] = v261;
  v262 = v259;
  v259 = __ROR4__(v259, 2);
  v263 = __ROL4__(v258 ^ v214 ^ v230 ^ v242, 1);
  v264 = v250 - 899497514 + v261 + (v257 ^ v253 ^ v262) + __ROL4__(v260, 5);
  v265 = __ROL4__(v256 ^ v212 ^ v229 ^ v241, 1);
  v282[9] = v265;
  v266 = v253 - 899497514 + v265 + (v257 ^ v260 ^ v259) + __ROL4__(v264, 5);
  v260 = __ROR4__(v260, 2);
  v282[10] = v263;
  v267 = v263 + (v264 ^ v260 ^ v259);
  v264 = __ROR4__(v264, 2);
  v268 = v257 - 899497514 + v267 + __ROL4__(v266, 5);
  v269 = __ROL4__(v261 ^ v229 ^ v231 ^ v294, 1);
  v282[11] = v269;
  v289 = __ROL4__(v230 ^ v232 ^ v265 ^ v288, 1);
  v270 = v259 + v269 + (v266 ^ v264 ^ v260);
  v266 = __ROR4__(v266, 2);
  v271 = v270 + __ROL4__(v268, 5) - 899497514;
  v282[12] = v289;
  v272 = v289 + (v268 ^ v266 ^ v264);
  v268 = __ROR4__(v268, 2);
  v273 = v260 + v272 + __ROL4__(v271, 5) - 899497514;
  v274 = __ROL4__(v254 ^ v231 ^ v238 ^ v263, 1);
  v282[13] = v274;
  v275 = __ROL4__(v256 ^ v232 ^ v269 ^ v239, 1);
  v282[14] = v275;
  v276 = v264 + v274 + (v268 ^ v266 ^ v271) - 899497514 + __ROL4__(v273, 5);
  v271 = __ROR4__(v271, 2);
  v277 = __ROL4__(v289 ^ v258 ^ v238 ^ v241, 1);
  v282[15] = v277;
  v278 = v275 + (v268 ^ v273 ^ v271);
  v273 = __ROR4__(v273, 2);
  v279 = v266 + v278 + __ROL4__(v276, 5) - 899497514;
  result = v268 + __ROL4__(v279, 5) - 899497514 + v277 + (v276 ^ v273 ^ (unsigned int)v271);
  v281 = v283;
  *v281 += result;
  v281[1] += v279;
  v281[2] += __ROR4__(v276, 2);
  v281[3] += v273;
  v281[4] += v271;
  return result;
}

//----- (0000000140010634) ----------------------------------------------------
void *__fastcall sub_140010634(_DWORD *a1, char *a2, unsigned int a3)
{
  unsigned int v3; // edi
  char *v4; // r15
  _DWORD *v5; // rbx
  _DWORD *v6; // rbp
  unsigned int v7; // er9
  unsigned int v8; // ecx
  unsigned int v9; // er9
  unsigned int v10; // esi
  unsigned int i; // er14

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a1[23] )
    v6 = a1 + 24;
  else
    v6 = 0i64;
  v7 = a1[5];
  v8 = a1[5] + 8 * a3;
  v9 = (v7 >> 3) & 0x3F;
  v5[5] = v8;
  if ( v8 < 8 * a3 )
    ++v5[6];
  v5[6] += a3 >> 29;
  if ( v9 + a3 <= 0x3F )
  {
    v10 = 0;
  }
  else
  {
    v10 = 64 - v9;
    memcpy((char *)v5 + v9 + 28, a2, 64 - v9);
    sub_14000F198(v5, v5 + 7, v6);
    for ( i = v10 + 63; i < v3; i += 64 )
    {
      sub_14000F198(v5, &v4[v10], v6);
      v10 += 64;
    }
    v9 = 0;
  }
  return memcpy((char *)v5 + v9 + 28, &v4[v10], v3 - v10);
}

//----- (0000000140010740) ----------------------------------------------------
_DWORD *sub_140010740()
{
  _DWORD *v0; // rax
  _DWORD *v1; // rbx

  v0 = HeapAlloc(hHeap, 0, 0x9Cui64);
  v1 = v0;
  *v0 = 128;
  sub_14001093C(v0 + 17);
  return v1;
}

//----- (0000000140010778) ----------------------------------------------------
signed __int64 sub_140010778()
{
  char *v0; // rax

  v0 = sub_1400115E0(1);
  if ( v0 )
  {
    *((_QWORD *)v0 + 1) = sub_140010740;
    *((_QWORD *)v0 + 2) = sub_1400107C4;
    *((_QWORD *)v0 + 3) = sub_14001071C;
    *((_QWORD *)v0 + 4) = sub_14001072C;
  }
  return 1i64;
}
// 14001071C: using guessed type __int64 __fastcall sub_14001071C();
// 14001072C: using guessed type __int64 __fastcall sub_14001072C();
// 1400107C4: using guessed type __int64 __fastcall sub_1400107C4();

//----- (0000000140010860) ----------------------------------------------------
void *__fastcall sub_140010860(__int64 a1, _DWORD *a2)
{
  __int64 v2; // rdi
  _DWORD *v3; // rbx
  __int64 v4; // rsi
  signed __int64 v5; // r10
  unsigned int v6; // er9
  char *v7; // rdx
  __int64 v8; // r8
  unsigned int v9; // ecx
  unsigned int v10; // er8
  _BYTE *v11; // rdx
  signed __int64 v12; // r8
  char v13; // al
  char v15; // [rsp+38h] [rbp+10h]
  char v16; // [rsp+3Ah] [rbp+12h]

  v2 = 0i64;
  v3 = a2;
  v4 = a1;
  v5 = 2i64;
  v6 = 0;
  v7 = &v16;
  do
  {
    v8 = v6++;
    *(v7 - 2) = v3[v8 + 4];
    *(v7 - 1) = BYTE1(v3[v8 + 4]);
    *v7 = BYTE2(v3[v8 + 4]);
    v7 += 4;
    *(v7 - 3) = HIBYTE(v3[v8 + 4]);
    --v5;
  }
  while ( v5 );
  v9 = (v3[4] >> 3) & 0x3F;
  v10 = 120 - v9;
  if ( v9 < 0x38 )
    v10 = 56 - v9;
  sub_1400111CC(v3, (__int64)&unk_14001F140, v10);
  sub_1400111CC(v3, (__int64)&v15, 8u);
  v11 = (_BYTE *)(v4 + 2);
  v12 = 4i64;
  do
  {
    *(v11 - 2) = v3[v2];
    *(v11 - 1) = BYTE1(v3[v2]);
    *v11 = BYTE2(v3[v2]);
    v13 = HIBYTE(v3[v2]);
    v2 = (unsigned int)(v2 + 1);
    v11[1] = v13;
    v11 += 4;
    --v12;
  }
  while ( v12 );
  return memset(v3, 0, 0x58ui64);
}

//----- (000000014001093C) ----------------------------------------------------
void __fastcall sub_14001093C(_DWORD *a1)
{
  a1[5] = 0;
  a1[4] = 0;
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
}

//----- (0000000140010960) ----------------------------------------------------
__int64 __fastcall sub_140010960(_DWORD *a1, __int64 a2)
{
  int v2; // edi
  int v3; // er10
  int v4; // er11
  int v5; // ebx
  __int64 v6; // r8
  unsigned __int8 *v7; // rdx
  signed __int64 v8; // r9
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  int v12; // er8
  int v13; // er9
  int v14; // er10
  int v15; // er11
  int v16; // edx
  int v17; // er8
  int v18; // er9
  int v19; // er10
  int v20; // edx
  int v21; // edi
  int v22; // eax
  int v23; // er9
  int v24; // ecx
  int v25; // er11
  int v26; // ebx
  int v27; // er8
  int v28; // er10
  int v29; // er9
  int v30; // er11
  int v31; // er8
  int v32; // edx
  int v33; // er10
  int v34; // er9
  int v35; // er11
  int v36; // er8
  int v37; // edx
  int v38; // er10
  int v39; // er9
  int v40; // er11
  int v41; // ebx
  int v42; // edx
  int v43; // er10
  int v44; // er8
  int v45; // er9
  int v46; // er10
  int v47; // edx
  int v48; // er8
  int v49; // er9
  int v50; // er10
  int v51; // er11
  int v52; // edx
  int v53; // er8
  int v54; // er9
  int v55; // er10
  int v56; // er11
  int v57; // er8
  int v58; // edx
  int v59; // er9
  int v60; // ecx
  int v61; // er10
  int v62; // er8
  int v63; // edx
  int v64; // er9
  int v65; // ecx
  int v66; // er10
  int v67; // er8
  int v68; // edx
  int v69; // er9
  int v70; // ecx
  int v71; // er10
  int v72; // ebx
  int v73; // er11
  int v74; // er8
  int v75; // er9
  int v76; // edx
  int v77; // ecx
  int v78; // ebx
  int v79; // er8
  _DWORD *v80; // r9
  int v81; // er8
  int v82; // edx
  int v83; // ecx
  int v84; // ecx
  __int64 result; // rax
  int v86; // [rsp+0h] [rbp-40h]
  int v87; // [rsp+4h] [rbp-3Ch]
  int v88; // [rsp+8h] [rbp-38h]
  int v89; // [rsp+Ch] [rbp-34h]
  int v90; // [rsp+10h] [rbp-30h]
  int v91; // [rsp+14h] [rbp-2Ch]
  int v92; // [rsp+18h] [rbp-28h]
  int v93; // [rsp+1Ch] [rbp-24h]
  int v94; // [rsp+20h] [rbp-20h]
  int v95; // [rsp+24h] [rbp-1Ch]
  int v96; // [rsp+28h] [rbp-18h]
  int v97; // [rsp+2Ch] [rbp-14h]
  int v98; // [rsp+30h] [rbp-10h]
  int v99; // [rsp+34h] [rbp-Ch]
  int v100; // [rsp+38h] [rbp-8h]
  int v101; // [rsp+3Ch] [rbp-4h]
  _DWORD *v102; // [rsp+80h] [rbp+40h]
  int v103; // [rsp+90h] [rbp+50h]

  v102 = a1;
  v2 = *a1;
  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  v6 = 0i64;
  v103 = *a1;
  v7 = (unsigned __int8 *)(a2 + 2);
  v8 = 16i64;
  do
  {
    v9 = *v7;
    v10 = v7[1];
    v7 += 4;
    *(&v86 + v6) = *(v7 - 6) | ((*(v7 - 5) | ((v9 | (v10 << 8)) << 8)) << 8);
    v6 = (unsigned int)(v6 + 1);
    --v8;
  }
  while ( v8 );
  v11 = v3 + __ROL4__(v86 + (v3 & v4 | v5 & ~v3) + v2 - 680876936, 7);
  v12 = v11
      + __ROL4__(
          v87 + (v11 & v3 | v4 & ~(v3 + __ROL4__(v86 + (v3 & v4 | v5 & ~v3) + v2 - 680876936, 7))) + v5 - 389564586,
          12);
  v13 = v12 + __ROR4__(v88 + (v11 & v12 | v3 & ~v12) + v4 + 606105819, 15);
  v14 = v13 + __ROR4__(v89 + (v13 & v12 | v11 & ~v13) + v3 - 1044525330, 10);
  v15 = v14 + __ROL4__(v90 + (v14 & v13 | v12 & ~v14) + v11 - 176418897, 7);
  v16 = v15 + __ROL4__(v91 + (v15 & v14 | v13 & ~v15) + v12 + 1200080426, 12);
  v17 = v16 + __ROR4__(v92 + (v15 & v16 | v14 & ~v16) + v13 - 1473231341, 15);
  v18 = v17
      + __ROR4__(
          v93
        + (v17 & v16 | v15 & ~(v16 + __ROR4__(v92 + (v15 & v16 | v14 & ~v16) + v13 - 1473231341, 15)))
        + v14
        - 45705983,
          10);
  v19 = v18 + __ROL4__(v15 + v94 + (v18 & v17 | v16 & ~v18) + 1770035416, 7);
  v20 = v19
      + __ROL4__(
          v95
        + (v19 & v18 | v17 & ~(v18 + __ROL4__(v15 + v94 + (v18 & v17 | v16 & ~v18) + 1770035416, 7)))
        - 1958414417
        + v16,
          12);
  v21 = v20 + __ROR4__(v17 + v96 + (v19 & v20 | v18 & ~v20) - 42063, 15);
  v22 = v20 + __ROR4__(v17 + v96 + (v19 & v20 | v18 & ~v20) - 42063, 15);
  v23 = v21
      + __ROR4__(
          v97
        + (v21 & v20 | v19 & ~(v20 + __ROR4__(v17 + v96 + (v19 & v20 | v18 & ~v20) - 42063, 15)))
        - 1990404162
        + v18,
          10);
  v24 = v23 & v22 | v20 & ~v23;
  v25 = v23 + __ROL4__(v98 + v24 + v19 + 1804603682, 7);
  v26 = v25
      + __ROL4__(v99 + (v25 & v23 | v21 & ~(v23 + __ROL4__(v98 + v24 + v19 + 1804603682, 7))) + v20 - 40341101, 12);
  v27 = ~(v25
        + __ROL4__(v99 + (v25 & v23 | v21 & ~(v23 + __ROL4__(v98 + v24 + v19 + 1804603682, 7))) + v20 - 40341101, 12));
  v28 = v26 + __ROR4__(v100 + (v25 & v26 | v23 & v27) + v21 - 1502002290, 15);
  v29 = v28 + __ROR4__(v101 + (v28 & v26 | v25 & ~v28) + 1236535329 + v23, 10);
  v30 = v29 + __ROL4__(v87 + (v29 & v26 | v28 & v27) - 165796510 + v25, 5);
  v31 = v30 + __ROL4__(v26 + v92 + (v29 & ~v28 | v30 & v28) - 1069501632, 9);
  v32 = v31 + __ROL4__(v97 + (v29 & v31 | v30 & ~v29) + v28 + 643717713, 14);
  v33 = v32 + __ROR4__(v86 + (v30 & v32 | v31 & ~v30) + v29 - 373897302, 12);
  v34 = v33 + __ROL4__(v91 + (v33 & v31 | v32 & ~v31) + v30 - 701558691, 5);
  v35 = v34 + __ROL4__(v96 + (v34 & v32 | v33 & ~v32) + v31 + 38016083, 9);
  v36 = v35 + __ROL4__(v101 + (v33 & v35 | v34 & ~v33) + v32 - 660478335, 14);
  v37 = v36 + __ROR4__(v90 + (v34 & v36 | v35 & ~v34) + v33 - 405537848, 12);
  v38 = v37 + __ROL4__(v95 + (v37 & v35 | v36 & ~v35) + v34 + 568446438, 5);
  v39 = v38 + __ROL4__(v100 + (v38 & v36 | v37 & ~v36) + v35 - 1019803690, 9);
  v40 = v39 + __ROL4__(v36 + v89 + (v37 & v39 | v38 & ~v37) - 187363961, 14);
  v41 = v40 + __ROR4__(v94 + (v38 & v40 | v39 & ~v38) + v37 + 1163531501, 12);
  v42 = v41 + __ROL4__(v99 + (v41 & v39 | v40 & ~v39) + v38 - 1444681467, 5);
  v43 = ~(v41 + __ROL4__(v99 + (v41 & v39 | v40 & ~v39) + v38 - 1444681467, 5));
  v44 = v42 + __ROL4__(v88 + (v42 & v40 | v41 & ~v40) + v39 - 51403784, 9);
  v45 = v44 + __ROL4__(v93 + (v41 & v44 | v42 & ~v41) + v40 + 1735328473, 14);
  v46 = v45
      + __ROR4__(
          v41
        + v98
        + (v42 & (v44 + __ROL4__(v93 + (v41 & v44 | v42 & ~v41) + v40 + 1735328473, 14)) | v44 & v43)
        - 1926607734,
          12);
  v47 = v46 + __ROL4__(v91 + (v46 ^ v45 ^ v44) - 378558 + v42, 4);
  v48 = v47 + __ROL4__(v94 + (v47 ^ v46 ^ v45) - 2022574463 + v44, 11);
  v49 = v48 + __ROL4__(v97 + (v47 ^ v46 ^ v48) + 1839030562 + v45, 16);
  v50 = v49 + __ROR4__(v100 + (v47 ^ v49 ^ v48) - 35309556 + v46, 9);
  v51 = v50 + __ROL4__(v87 + (v50 ^ v49 ^ v48) + v47 - 1530992060, 4);
  v52 = v51 + __ROL4__(v90 + (v51 ^ v50 ^ v49) + v48 + 1272893353, 11);
  v53 = v52
      + __ROL4__(
          v93 + (v51 ^ v50 ^ (v51 + __ROL4__(v90 + (v51 ^ v50 ^ v49) + v48 + 1272893353, 11))) + v49 - 155497632,
          16);
  v54 = v53 + __ROR4__(v96 + (v51 ^ v53 ^ v52) + v50 - 1094730640, 9);
  v55 = v54 + __ROL4__(v99 + (v54 ^ v53 ^ v52) + v51 + 681279174, 4);
  v56 = v55 + __ROL4__(v86 + (v55 ^ v54 ^ v53) + v52 - 358537222, 11);
  v57 = v56 + __ROL4__(v89 + (v55 ^ v54 ^ v56) - 722521979 + v53, 16);
  v58 = v57 + __ROR4__(v92 + (v55 ^ v57 ^ v56) + v54 + 76029189, 9);
  v59 = v58 + __ROL4__(v95 + (v58 ^ v57 ^ v56) + v55 - 640364487, 4);
  v60 = v59 + __ROL4__(v56 + v98 + (v59 ^ v58 ^ v57) - 421815835, 11);
  v61 = v60 + __ROL4__(v101 + (v59 ^ v58 ^ v60) + v57 + 530742520, 16);
  v62 = v61 + __ROR4__(v88 + (v59 ^ v61 ^ v60) + v58 - 995338651, 9);
  v63 = v62 + __ROL4__(v86 + (v61 ^ (v62 | ~v60)) + v59 - 198630844, 6);
  v64 = v63 + __ROL4__(v93 + (v62 ^ (v63 | ~v61)) + v60 + 1126891415, 10);
  v65 = v64 + __ROL4__(v100 + (v63 ^ (v64 | ~v62)) + v61 - 1416354905, 15);
  v66 = v65 + __ROR4__(v91 + (v64 ^ (v65 | ~v63)) + v62 - 57434055, 11);
  v67 = v66 + __ROL4__(v98 + (v65 ^ (v66 | ~v64)) + v63 + 1700485571, 6);
  v68 = v67 + __ROL4__(v89 + (v66 ^ (v67 | ~v65)) + v64 - 1894986606, 10);
  v69 = v68 + __ROL4__(v96 + (v67 ^ (v68 | ~v66)) + v65 - 1051523, 15);
  v70 = v69 + __ROR4__(v87 + (v68 ^ (v69 | ~v67)) + v66 - 2054922799, 11);
  v71 = v70 + __ROL4__(v94 + (v69 ^ (v70 | ~v68)) + v67 + 1873313359, 6);
  v72 = v70 + 1309151649;
  v73 = v71 + __ROL4__(v101 + (v70 ^ (v71 | ~v69)) + v68 - 30611744, 10);
  v74 = ~(v71 + __ROL4__(v101 + (v70 ^ (v71 | ~v69)) + v68 - 30611744, 10));
  v75 = v73 + __ROL4__(v92 + (v71 ^ (v73 | ~v70)) - 1560198380 + v69, 15);
  v76 = ~v75;
  v77 = v75 + 718787259;
  v78 = v75 + __ROR4__(v99 + (v73 ^ (v75 | ~v71)) + v72, 11);
  v79 = v75 ^ (v78 | v74);
  v80 = v102;
  v81 = v78 + __ROL4__(v71 + v90 + v79 - 145523070, 6);
  v82 = v81 + __ROL4__(v73 + v97 + (v78 ^ (v81 | v76)) - 1120210379, 10);
  v83 = v88 + (v81 ^ (v82 | ~v78)) + v77;
  *v102 = v81 + v103;
  v84 = v82 + __ROL4__(v83, 15);
  v80[2] += v84;
  result = (unsigned int)(v84 + v102[1] + __ROR4__(v95 + (v82 ^ (v84 | ~v81)) + v78 - 343485551, 11));
  v80[3] += v82;
  v102[1] = result;
  return result;
}

//----- (00000001400111CC) ----------------------------------------------------
char __fastcall sub_1400111CC(_DWORD *a1, __int64 a2, unsigned int a3)
{
  _DWORD *v3; // rdi
  unsigned int v4; // esi
  unsigned int v5; // er9
  __int64 v6; // rbp
  unsigned int v7; // ecx
  unsigned int v8; // eax
  unsigned int v9; // ebx
  __int64 v10; // r8
  __int64 v11; // rdx
  _BYTE *v12; // rcx
  __int64 v13; // rdx
  unsigned int v14; // esi
  unsigned __int64 v15; // r8
  _BYTE *v16; // rdx
  __int64 v17; // rcx
  unsigned __int64 v18; // r8

  v3 = a1;
  v4 = a3;
  v5 = a1[4] + 8 * a3;
  v6 = a2;
  v7 = (a1[4] >> 3) & 0x3F;
  v3[4] = v5;
  if ( v5 < 8 * a3 )
    ++v3[5];
  v8 = a3 >> 29;
  v9 = 64 - v7;
  v3[5] += a3 >> 29;
  if ( a3 < 64 - v7 )
  {
    v9 = 0;
  }
  else
  {
    if ( 64 != v7 )
    {
      v10 = v9;
      v11 = a2 - v7;
      v12 = (char *)v3 + v7 + 24;
      v13 = v11 - (_QWORD)v3;
      do
      {
        *v12 = v12[v13 - 24];
        ++v12;
        --v10;
      }
      while ( v10 );
    }
    sub_140010960(v3, (__int64)(v3 + 6));
    while ( 1 )
    {
      LOBYTE(v8) = v9 + 63;
      if ( v9 + 63 >= v4 )
        break;
      sub_140010960(v3, v6 + v9);
      v9 += 64;
    }
    v7 = 0;
  }
  v14 = v4 - v9;
  if ( v14 )
  {
    v15 = v9 - (unsigned __int64)v7;
    v16 = (char *)v3 + v7 + 24;
    v17 = v14;
    v18 = v6 + v15 - (_QWORD)v3;
    do
    {
      LOBYTE(v8) = v16[v18 - 24];
      *v16++ = v8;
      --v17;
    }
    while ( v17 );
  }
  return v8;
}

//----- (00000001400112CC) ----------------------------------------------------
void *__fastcall sub_1400112CC(void *a1, int a2, unsigned int a3)
{
  void *result; // rax

  if ( a3 )
    result = memset(a1, a2, a3);
  return result;
}

//----- (00000001400112F0) ----------------------------------------------------
void sub_1400112F0()
{
  sub_140011300();
}

//----- (0000000140011300) ----------------------------------------------------
void sub_140011300()
{
  JUMPOUT(loc_140011307);
}

//----- (00000001400113C0) ----------------------------------------------------
void sub_1400113C0()
{
  JUMPOUT(loc_1400113C7);
}

//----- (00000001400114E0) ----------------------------------------------------
__int64 __fastcall sub_1400114E0(__int64 a1, unsigned int a2, int a3, int a4)
{
  return sub_140011500(a1, a2, a3, 0, a4);
}

//----- (0000000140011500) ----------------------------------------------------
__int64 __fastcall sub_140011500(__int64 a1, unsigned int a2, int a3, unsigned int a4, int a5)
{
  __int64 v5; // r14
  unsigned int v6; // esi
  unsigned int v7; // ebp
  _DWORD *v8; // rbx
  _DWORD *v9; // rax
  _DWORD *v10; // rdi
  __int64 v11; // rax
  __int64 result; // rax

  v5 = a1;
  v6 = a4;
  v7 = a2;
  v8 = 0i64;
  v9 = sub_140011590(a3);
  v10 = v9;
  if ( v9 )
  {
    v11 = (*((__int64 (__fastcall **)(_QWORD, signed __int64))v9 + 1))(v6, 1i64);
    v8 = (_DWORD *)v11;
    if ( v11 )
    {
      (*((void (__fastcall **)(__int64, __int64, _QWORD))v10 + 2))(v11, v5, v7);
      (*((void (__fastcall **)(_DWORD *))v10 + 3))(v8);
    }
  }
  result = sub_140011650(v8, a5);
  if ( v8 )
    result = (*((__int64 (__fastcall **)(_DWORD *))v10 + 4))(v8);
  return result;
}

//----- (0000000140011590) ----------------------------------------------------
_DWORD *__fastcall sub_140011590(int a1)
{
  _DWORD *result; // rax
  int v2; // er9
  __int64 v3; // r8
  _DWORD *v4; // rcx
  _DWORD *v5; // rdx
  bool v6; // zf

  result = 0i64;
  v2 = a1;
  if ( a1 == -1 )
  {
    if ( dword_1400206C0 )
      result = dword_1400206D0;
  }
  else
  {
    v3 = (unsigned int)dword_1400206C0;
    if ( dword_1400206C0 > 0 )
    {
      v4 = dword_1400206D0;
      v5 = dword_1400206D0;
      do
      {
        v6 = *v4 == v2;
        v4 += 10;
        if ( v6 )
          result = v5;
        v5 += 10;
        --v3;
      }
      while ( v3 );
    }
  }
  return result;
}
// 1400206C0: using guessed type int dword_1400206C0;

//----- (00000001400115E0) ----------------------------------------------------
char *__fastcall sub_1400115E0(int a1)
{
  char *v1; // rax
  int v2; // er10
  int v3; // edx
  bool v4; // zf
  _DWORD *v5; // rcx
  char *v6; // r8
  __int64 v7; // r9
  __int64 v9; // rax
  int v10; // edx

  v1 = 0i64;
  v2 = a1;
  if ( a1 == -1 )
  {
    v3 = dword_1400206C0;
    v4 = dword_1400206C0 == 0;
  }
  else
  {
    v3 = dword_1400206C0;
    if ( dword_1400206C0 <= 0 )
      goto LABEL_11;
    v5 = dword_1400206D0;
    v6 = (char *)dword_1400206D0;
    v7 = (unsigned int)dword_1400206C0;
    do
    {
      v4 = *v5 == v2;
      v5 += 10;
      if ( v4 )
        v1 = v6;
      v6 += 40;
      --v7;
    }
    while ( v7 );
    v4 = v1 == 0i64;
  }
  if ( !v4 )
    return 0i64;
LABEL_11:
  v9 = v3;
  v10 = v3 + 1;
  dword_1400206C0 = v10;
  dword_1400206D0[10 * v9] = v2;
  return (char *)&dword_1400206D0[10 * (v10 - 1)];
}
// 1400206C0: using guessed type int dword_1400206C0;

//----- (0000000140011650) ----------------------------------------------------
__int64 __fastcall sub_140011650(_DWORD *a1, int a2)
{
  _DWORD *v2; // rdi
  int v3; // esi
  __int64 result; // rax
  __int64 v5; // r9
  _WORD *v6; // rdx
  unsigned __int8 *v7; // r8
  unsigned __int64 v8; // rcx

  v2 = a1;
  v3 = 0;
  if ( a1 )
    v3 = *a1 / 8;
  result = sub_140012E40(2 * v3, a2);
  v5 = v3;
  v6 = (_WORD *)result;
  if ( v3 <= 0 )
  {
    *(_WORD *)result = 0;
  }
  else
  {
    v7 = (unsigned __int8 *)(v2 + 1);
    do
    {
      v8 = *v7;
      v6 += 2;
      ++v7;
      *(v6 - 2) = a0123456789abcd[v8 >> 4];
      result = (unsigned int)a0123456789abcd[*(v7 - 1) & 0xF];
      *(v6 - 1) = a0123456789abcd[*(v7 - 1) & 0xF];
      --v5;
    }
    while ( v5 );
    *v6 = 0;
  }
  return result;
}

//----- (00000001400116F8) ----------------------------------------------------
int __fastcall sub_1400116F8(LPVOID lpMem)
{
  _QWORD *v1; // rbx
  char *v2; // rdi
  __int64 (__fastcall *v3)(char *); // rdx
  int result; // eax

  v1 = (_QWORD *)qword_1400210D0;
  v2 = (char *)lpMem;
  while ( v1 )
  {
    v3 = (__int64 (__fastcall *)(char *))v1[4];
    if ( v3 )
      result = v3(&v2[v1[2]]);
    v1 = (_QWORD *)*v1;
  }
  if ( v2 )
    result = HeapFree(hHeap, 0, v2);
  return result;
}
// 1400210D0: using guessed type __int64 qword_1400210D0;

//----- (000000014001174C) ----------------------------------------------------
BOOL sub_14001174C()
{
  BOOL result; // eax

  if ( !dword_14001F016 )
  {
    if ( dwBytes )
      result = TlsFree(dword_1400210E0);
  }
  return result;
}
// 14001F016: using guessed type int dword_14001F016;

//----- (0000000140011774) ----------------------------------------------------
BOOL sub_140011774()
{
  BOOL result; // eax

  if ( dwBytes )
    result = TlsFree(dword_1400210E0);
  return result;
}

//----- (0000000140011794) ----------------------------------------------------
char *__fastcall sub_140011794(__int64 a1)
{
  __int64 v1; // rsi
  char *v2; // rdi
  _QWORD *i; // rbx
  void (__fastcall *v4)(char *); // rdx

  v1 = a1;
  v2 = (char *)TlsGetValue(dword_1400210E0);
  if ( !v2 )
  {
    v2 = (char *)HeapAlloc(hHeap, 8u, dwBytes);
    TlsSetValue(dword_1400210E0, v2);
    for ( i = (_QWORD *)qword_1400210D0; i; i = (_QWORD *)*i )
    {
      v4 = (void (__fastcall *)(char *))i[3];
      if ( v4 )
        v4(&v2[i[2]]);
    }
    sub_140017434((__int64)sub_1400116F8, (__int64)v2);
  }
  return &v2[v1];
}
// 1400210D0: using guessed type __int64 qword_1400210D0;

//----- (000000014001182C) ----------------------------------------------------
SIZE_T __fastcall sub_14001182C(int a1, void (__fastcall *a2)(char *), __int64 a3)
{
  int v3; // ebx
  __int64 v4; // rbp
  void (__fastcall *v5)(char *); // rdi
  int v6; // ecx
  SIZE_T v7; // rcx
  void *v8; // rax
  SIZE_T v9; // rsi
  void *v10; // rax
  char *v11; // rbx
  _QWORD *v12; // rax

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v6 = a1 & 7;
  if ( v6 )
    v3 += 8 - v6;
  v7 = dwBytes;
  if ( !dwBytes )
  {
    dword_1400210E0 = TlsAlloc();
    v8 = HeapAlloc(hHeap, 8u, v3);
    TlsSetValue(dword_1400210E0, v8);
    v7 = dwBytes;
  }
  v9 = v7;
  dwBytes = v3 + v7;
  v10 = TlsGetValue(dword_1400210E0);
  v11 = (char *)HeapReAlloc(hHeap, 8u, v10, dwBytes);
  TlsSetValue(dword_1400210E0, v11);
  if ( v5 || v4 )
  {
    v12 = (_QWORD *)sub_140012400((__int64)&qword_1400210D0, 40);
    *v12 = v9;
    v12[1] = v5;
    v12[2] = v4;
    if ( v5 )
      v5(&v11[v9]);
  }
  return v9;
}
// 1400210D0: using guessed type __int64 qword_1400210D0;

//----- (000000014001192C) ----------------------------------------------------
void __fastcall sub_14001192C(signed int *a1, __int64 a2)
{
  signed int *v2; // rbx
  __int64 v3; // rdi
  void *v4; // rcx

  v2 = a1;
  v3 = a2;
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 14));
  if ( v3 < 0 || v3 >= *((_QWORD *)v2 + 1) )
  {
    sub_1400123B8((__int64 **)v2 + 3, v3);
  }
  else
  {
    v4 = *(void **)(*((_QWORD *)v2 + 2) + 8 * v3);
    if ( v4 )
      memset(v4, 0, *v2);
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(v2 + 14));
}

//----- (0000000140011998) ----------------------------------------------------
signed __int64 __fastcall sub_140011998(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rdi
  signed __int64 v3; // rbx

  v2 = a1;
  v3 = (signed __int64)a2;
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 56));
  if ( v3 >= 0 && v3 < *(_QWORD *)(v2 + 8) )
    v3 = *(_QWORD *)(*(_QWORD *)(v2 + 16) + 8 * v3);
  LeaveCriticalSection((LPCRITICAL_SECTION)(v2 + 56));
  if ( v3 )
    v3 &= -(signed __int64)(*(_QWORD *)v3 != 0i64);
  return v3;
}

//----- (00000001400119F8) ----------------------------------------------------
signed __int64 __fastcall sub_1400119F8(signed int *a1, __int64 a2)
{
  struct _RTL_CRITICAL_SECTION *v2; // rsi
  signed int *v3; // rbx
  __int64 v4; // rdi
  signed __int64 v5; // rbx
  void *v6; // r8
  __int64 v7; // r9
  void (__fastcall *v8)(__int64); // rax

  v2 = (struct _RTL_CRITICAL_SECTION *)(a1 + 14);
  v3 = a1;
  v4 = a2;
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 14));
  if ( v4 == -1 )
  {
    v5 = sub_140012400((__int64)(v3 + 6), *v3 + 16);
  }
  else
  {
    if ( v4 >= *((_QWORD *)v3 + 1) )
    {
      v6 = (void *)*((_QWORD *)v3 + 2);
      v7 = v4 + v3[1];
      *((_QWORD *)v3 + 1) = v7;
      *((_QWORD *)v3 + 2) = HeapReAlloc(hHeap, 8u, v6, 8 * v7);
    }
    if ( *(_QWORD *)(*((_QWORD *)v3 + 2) + 8 * v4) )
    {
      v8 = (void (__fastcall *)(__int64))*((_QWORD *)v3 + 4);
      if ( v8 )
        v8(v4);
    }
    else
    {
      *(_QWORD *)(*((_QWORD *)v3 + 2) + 8 * v4) = HeapAlloc(hHeap, 8u, *v3);
    }
    v5 = *(_QWORD *)(*((_QWORD *)v3 + 2) + 8 * v4);
  }
  LeaveCriticalSection(v2);
  return v5;
}

//----- (0000000140011AC0) ----------------------------------------------------
_QWORD *__fastcall sub_140011AC0(int a1, int a2, __int64 a3)
{
  __int64 v3; // rsi
  int v4; // ebx
  __int64 v5; // rdi
  _QWORD *v6; // rax
  _QWORD *v7; // r14

  v3 = a2;
  v4 = a1;
  v5 = a3;
  v6 = HeapAlloc(hHeap, 8u, 0x60ui64);
  v6[3] = 0i64;
  *(_DWORD *)v6 = v4;
  v6[4] = v5;
  *((_DWORD *)v6 + 1) = v3;
  v6[1] = v3;
  v7 = v6;
  v6[2] = HeapAlloc(hHeap, 8u, 8 * v3);
  InitializeCriticalSection((LPCRITICAL_SECTION)(v7 + 7));
  return v7;
}

//----- (0000000140011B48) ----------------------------------------------------
_QWORD *__fastcall sub_140011B48(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rdi
  signed __int64 v3; // rsi
  _QWORD *v4; // rbx
  _QWORD *v5; // rax
  signed __int64 v6; // rdx

  v2 = a1;
  v3 = (signed __int64)a2;
  v4 = 0i64;
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 56));
  if ( v3 < 0 || v3 >= *(_QWORD *)(v2 + 8) )
  {
    v5 = *(_QWORD **)(v2 + 24);
    while ( v5 )
    {
      v6 = (signed __int64)(v5 + 2);
      v5 = (_QWORD *)*v5;
      if ( v6 == v3 )
        v4 = (_QWORD *)v3;
    }
  }
  else
  {
    v4 = *(_QWORD **)(*(_QWORD *)(v2 + 16) + 8 * v3);
    if ( v4 && !*v4 )
      v4 = 0i64;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(v2 + 56));
  return v4;
}

//----- (0000000140011BCC) ----------------------------------------------------
signed __int64 __fastcall sub_140011BCC(__int64 *a1)
{
  _QWORD *v1; // rsi
  __int64 *v2; // rdi
  _DWORD *v3; // rbx
  int v4; // ecx
  __int64 v5; // rdx
  __int64 v6; // rax
  __int64 v7; // rax
  signed int v8; // ebp
  signed __int64 v9; // rax
  _DWORD *v10; // rax
  _DWORD *v11; // rax
  bool v12; // zf
  bool v13; // sf
  unsigned __int8 v14; // of
  __int64 v15; // rax
  __int64 v16; // rax

  v1 = 0i64;
  v2 = a1;
  if ( *((_DWORD *)a1 + 12) )
    EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 7));
  v3 = (_DWORD *)v2[1];
  if ( v3 )
  {
    v4 = v3[8];
    if ( v4 <= 0 )
    {
      v5 = (signed int)v3[7];
      v1 = (_QWORD *)((char *)v3 + v5 * v2[4] + 40);
      v3[7] = v5 + 1;
    }
    else
    {
      v1 = (_QWORD *)*((_QWORD *)v3 + 2);
      *((_QWORD *)v3 + 2) = *v1;
      v3[8] = v4 - 1;
    }
    if ( !v3[8] && v3[7] >= v3[6] )
    {
      if ( *(_QWORD *)v3 )
        *(_QWORD *)(*(_QWORD *)v3 + 8i64) = *((_QWORD *)v3 + 1);
      v6 = *(_QWORD *)v3;
      if ( v3 == (_DWORD *)v2[1] )
        v2[1] = v6;
      else
        **((_QWORD **)v3 + 1) = v6;
      v7 = *v2;
      *((_QWORD *)v3 + 1) = 0i64;
      *(_QWORD *)v3 = v7;
      *v2 = (__int64)v3;
      if ( *(_QWORD *)v3 )
        *(_QWORD *)(*(_QWORD *)v3 + 8i64) = v3;
    }
  }
  else
  {
    v8 = *((_DWORD *)v2 + 10);
    v9 = (v2[3] >> 4) & 0xFFFFFFF0i64;
    if ( (signed int)v9 >= v8 )
    {
      v8 = (v2[3] >> 4) & 0xFFFFFFF0;
      if ( (signed int)v9 > *((_DWORD *)v2 + 11) )
        v8 = *((_DWORD *)v2 + 11);
    }
    v10 = HeapAlloc(hHeap, 0, v2[4] * v8 + 40);
    v3 = v10;
    if ( v10 )
    {
      v10[6] = v8;
    }
    else
    {
      v11 = HeapAlloc(hHeap, 0, v2[4] + 40);
      v3 = v11;
      if ( !v11 )
        goto LABEL_29;
      v11[6] = 1;
    }
    v2[3] += (signed int)v3[6];
    v3[8] = 0;
    *((_QWORD *)v3 + 2) = 0i64;
    v14 = __OFSUB__(v3[6], 1);
    v12 = v3[6] == 1;
    v13 = v3[6] - 1 < 0;
    v3[7] = 1;
    if ( (unsigned __int8)(v13 ^ v14) | v12 )
    {
      v16 = *v2;
      *((_QWORD *)v3 + 1) = 0i64;
      *(_QWORD *)v3 = v16;
      *v2 = (__int64)v3;
    }
    else
    {
      v15 = v2[1];
      *((_QWORD *)v3 + 1) = 0i64;
      *(_QWORD *)v3 = v15;
      v2[1] = (__int64)v3;
    }
    if ( *(_QWORD *)v3 )
      *(_QWORD *)(*(_QWORD *)v3 + 8i64) = v3;
    v1 = v3 + 10;
  }
LABEL_29:
  if ( *((_DWORD *)v2 + 12) )
    LeaveCriticalSection((LPCRITICAL_SECTION)(v2 + 7));
  if ( !v1 )
    return 0i64;
  *v1 = v3;
  return (signed __int64)(v1 + 1);
}

//----- (0000000140011D7C) ----------------------------------------------------
void *__fastcall sub_140011D7C(__int64 *a1)
{
  __int64 *v1; // rdi
  void *v2; // rax
  void *v3; // rbx

  v1 = a1;
  v2 = (void *)sub_140011BCC(a1);
  v3 = v2;
  if ( v2 )
    memset(v2, 0, *((_DWORD *)v1 + 8) - 8);
  return v3;
}

//----- (0000000140011DB8) ----------------------------------------------------
void __fastcall sub_140011DB8(__int64 a1)
{
  __int64 v1; // rdi
  _QWORD *v2; // r8
  _QWORD *v3; // rbx
  _QWORD *v4; // r8
  _QWORD *v5; // rbx

  v1 = a1;
  if ( *(_DWORD *)(a1 + 48) )
    EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 56));
  v2 = *(_QWORD **)(v1 + 8);
  if ( v2 )
  {
    do
    {
      v3 = (_QWORD *)*v2;
      HeapFree(hHeap, 0, v2);
      v2 = v3;
    }
    while ( v3 );
  }
  v4 = *(_QWORD **)v1;
  if ( *(_QWORD *)v1 )
  {
    do
    {
      v5 = (_QWORD *)*v4;
      HeapFree(hHeap, 0, v4);
      v4 = v5;
    }
    while ( v5 );
  }
  *(_QWORD *)v1 = 0i64;
  *(_QWORD *)(v1 + 8) = 0i64;
  *(_QWORD *)(v1 + 24) = 0i64;
  if ( *(_DWORD *)(v1 + 48) )
    LeaveCriticalSection((LPCRITICAL_SECTION)(v1 + 56));
}

//----- (0000000140011E44) ----------------------------------------------------
void __fastcall sub_140011E44(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  __int64 *v4; // r8
  int v5; // eax
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax

  v2 = a2;
  v3 = a1;
  if ( *(_DWORD *)(a1 + 48) )
    EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 56));
  v4 = *(__int64 **)(v2 - 8);
  *(_QWORD *)(v2 - 8) = v4[2];
  v5 = *((_DWORD *)v4 + 7);
  ++*((_DWORD *)v4 + 8);
  v4[2] = v2 - 8;
  if ( *((_DWORD *)v4 + 8) == v5 )
  {
    v6 = *v4;
    if ( *((_DWORD *)v4 + 6) == 1 )
    {
      if ( v6 )
        *(_QWORD *)(v6 + 8) = v4[1];
      v7 = *v4;
      if ( v4 == *(__int64 **)v3 )
      {
        *(_QWORD *)v3 = v7;
LABEL_14:
        *(_QWORD *)(v3 + 24) -= *((signed int *)v4 + 6);
        HeapFree(hHeap, 0, v4);
        goto LABEL_24;
      }
    }
    else
    {
      if ( v6 )
        *(_QWORD *)(v6 + 8) = v4[1];
      v7 = *v4;
      if ( v4 == *(__int64 **)(v3 + 8) )
      {
        *(_QWORD *)(v3 + 8) = v7;
        goto LABEL_14;
      }
    }
    *(_QWORD *)v4[1] = v7;
    goto LABEL_14;
  }
  if ( *((_DWORD *)v4 + 8) == 1 && v5 >= *((_DWORD *)v4 + 6) )
  {
    if ( *v4 )
      *(_QWORD *)(*v4 + 8) = v4[1];
    v8 = *v4;
    if ( v4 == *(__int64 **)v3 )
      *(_QWORD *)v3 = v8;
    else
      *(_QWORD *)v4[1] = v8;
    v9 = *(_QWORD *)(v3 + 8);
    v4[1] = 0i64;
    *v4 = v9;
    *(_QWORD *)(v3 + 8) = v4;
    if ( *v4 )
      *(_QWORD *)(*v4 + 8) = v4;
  }
LABEL_24:
  if ( *(_DWORD *)(v3 + 48) )
    LeaveCriticalSection((LPCRITICAL_SECTION)(v3 + 56));
}

//----- (0000000140011F4C) ----------------------------------------------------
char *__fastcall sub_140011F4C(__int64 a1, unsigned int a2, unsigned int a3, int a4)
{
  char *v4; // rbx
  int v5; // ebp
  unsigned int v6; // edi
  signed __int64 v7; // rsi
  unsigned int v8; // ecx
  __int64 i; // rax
  _QWORD *v10; // rdi
  __int64 v11; // rax
  __int64 v12; // rax
  char *v13; // rax
  unsigned int v15; // [rsp+48h] [rbp+10h]
  unsigned int v16; // [rsp+50h] [rbp+18h]

  v16 = a3;
  v15 = a2;
  v4 = 0i64;
  v5 = a4;
  v6 = a4 & 3;
  v7 = a1 + 8;
  v8 = ((_BYTE)a1 + 8) & 7;
  if ( v8 )
    v7 += 8i64 - v8;
  if ( a4 & 4 )
  {
    sub_140012208((volatile signed __int32 *)&unk_1400210E8, (void (*)(void))sub_140012180);
    EnterCriticalSection(&stru_1400210F8);
    for ( i = qword_1400210F0; i; i = *(_QWORD *)i )
    {
      if ( *(_QWORD *)(i + 24) == v7 && *(_DWORD *)(i + 32) == v5 )
      {
        v4 = *(char **)(i + 16);
        ++*(_DWORD *)(i + 36);
        if ( v4 )
          goto LABEL_15;
        break;
      }
    }
    v10 = HeapAlloc(hHeap, 0, 0x28ui64);
    if ( v10 )
    {
      v11 = sub_140011F4C(v7 - 8, v15, v16, v5 & 0xFFFFFFFB);
      v4 = (char *)v11;
      if ( v11 )
      {
        *(_QWORD *)(v11 + 16) = v10;
        v10[1] = 0i64;
        v10[2] = v11;
        v12 = qword_1400210F0;
        v10[3] = v7;
        *((_DWORD *)v10 + 8) = v5;
        *((_DWORD *)v10 + 9) = 1;
        *v10 = v12;
        if ( v12 )
          *(_QWORD *)(v12 + 8) = v10;
        qword_1400210F0 = (__int64)v10;
      }
    }
LABEL_15:
    LeaveCriticalSection(&stru_1400210F8);
  }
  else
  {
    v13 = (char *)HeapAlloc(hHeap, 0, 0x60ui64);
    v4 = v13;
    if ( v13 )
    {
      *(_QWORD *)v13 = 0i64;
      *((_QWORD *)v13 + 1) = 0i64;
      *((_QWORD *)v13 + 2) = 0i64;
      *((_QWORD *)v13 + 4) = v7;
      *((_DWORD *)v13 + 10) = v15;
      *((_DWORD *)v13 + 11) = v16;
      if ( v6 <= 1 )
      {
        *((_DWORD *)v13 + 12) = 1;
        InitializeCriticalSection((LPCRITICAL_SECTION)(v13 + 56));
      }
      else
      {
        *((_DWORD *)v13 + 12) = 0;
      }
    }
  }
  return v4;
}
// 1400210F0: using guessed type __int64 qword_1400210F0;

//----- (00000001400120B8) ----------------------------------------------------
void __fastcall sub_1400120B8(__int64 a1)
{
  _QWORD *v1; // rdi
  __int64 v2; // rbx
  _QWORD *v3; // rcx

  v1 = *(_QWORD **)(a1 + 16);
  v2 = a1;
  if ( v1 )
  {
    EnterCriticalSection(&stru_1400210F8);
    if ( --*(_DWORD *)(*(_QWORD *)(v2 + 16) + 36i64) <= 0 )
    {
      *(_QWORD *)(v2 + 16) = 0i64;
      sub_1400120B8(v2);
      if ( *v1 )
        *(_QWORD *)(*v1 + 8i64) = v1[1];
      v3 = (_QWORD *)v1[1];
      if ( v3 )
        *v3 = *v1;
      if ( (_QWORD *)qword_1400210F0 == v1 )
        qword_1400210F0 = *v1;
      HeapFree(hHeap, 0, v1);
    }
    LeaveCriticalSection(&stru_1400210F8);
  }
  else
  {
    sub_140011DB8(a1);
    if ( *(_DWORD *)(v2 + 48) )
      DeleteCriticalSection((LPCRITICAL_SECTION)(v2 + 56));
    HeapFree(hHeap, 0, (LPVOID)v2);
  }
}
// 1400210F0: using guessed type __int64 qword_1400210F0;

//----- (0000000140012180) ----------------------------------------------------
void sub_140012180()
{
  InitializeCriticalSection(&stru_1400210F8);
  qword_1400210F0 = 0i64;
}
// 1400210F0: using guessed type __int64 qword_1400210F0;

//----- (00000001400121A0) ----------------------------------------------------
void __fastcall sub_1400121A0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // [rsp+30h] [rbp+8h]

  v1 = a1;
  if ( *(_QWORD *)(a1 + 32) )
  {
    sub_140012398(a1);
    while ( sub_14001232C(v1, &v2) )
      (*(void (__fastcall **)(__int64))(v1 + 32))(v2);
  }
}

//----- (00000001400121D8) ----------------------------------------------------
signed __int64 __fastcall sub_1400121D8(__int64 a1, void (*a2)(void), _QWORD *a3)
{
  _QWORD *v3; // rbx

  v3 = a3;
  a2();
  *v3 = 4i64;
  return 1i64;
}

//----- (0000000140012208) ----------------------------------------------------
void __fastcall sub_140012208(volatile signed __int32 *a1, void (*a2)(void))
{
  volatile signed __int32 *v2; // rdi
  void (*v3)(void); // rsi
  signed int v4; // ebp
  HMODULE v5; // rax
  HMODULE v6; // rbx
  FARPROC v7; // rax
  signed __int32 v8; // eax
  char v9; // [rsp+50h] [rbp+18h]

  v2 = a1;
  v3 = a2;
  v4 = 0;
  v5 = LoadLibraryW((LPCWSTR)"K");
  v6 = v5;
  if ( !v5 )
    goto LABEL_14;
  v7 = GetProcAddress(v5, "InitOnceExecuteOnce");
  if ( v7 )
  {
    ((void (__fastcall *)(volatile signed __int32 *, signed __int64 (__fastcall *)(__int64, void (*)(void), _QWORD *), void (*)(void), char *))v7)(
      v2,
      sub_1400121D8,
      v3,
      &v9);
    v4 = 1;
  }
  FreeLibrary(v6);
  if ( !v4 )
  {
LABEL_14:
    v8 = _InterlockedCompareExchange(v2, 1, 0);
    if ( v8 )
    {
      if ( v8 == 1 )
      {
        while ( *v2 != 2 )
          Sleep(0);
      }
    }
    else
    {
      v3();
      _InterlockedExchange(v2, 2);
    }
  }
}

//----- (00000001400122B4) ----------------------------------------------------
void __fastcall sub_1400122B4(_QWORD *a1, int a2, int a3, __int64 a4)
{
  int v4; // ebp
  _QWORD *v5; // rbx
  __int64 v6; // rdi
  int v7; // esi

  v4 = a2;
  v5 = a1;
  v6 = a4;
  v7 = a3;
  sub_140012208((volatile signed __int32 *)&unk_140021120, (void (*)(void))sub_1400121F8);
  EnterCriticalSection(&stru_140021128);
  if ( !*v5 )
    *v5 = sub_140011AC0(v4, v7, v6);
  LeaveCriticalSection(&stru_140021128);
}
// 1400121F8: using guessed type __int64 __fastcall sub_1400121F8();

//----- (000000014001232C) ----------------------------------------------------
signed __int64 __fastcall sub_14001232C(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // r9
  signed __int64 v3; // rbx
  __int64 v4; // r8
  __int64 v5; // rax
  _QWORD *v6; // rdx
  __int64 v7; // rax

  v2 = a2;
  v3 = 0i64;
  do
  {
    v4 = *(_QWORD *)(a1 + 40);
    if ( v4 < 0 || v4 >= *(_QWORD *)(a1 + 8) )
      break;
    v5 = *(_QWORD *)(a1 + 16);
    v6 = *(_QWORD **)(v5 + 8 * v4);
    if ( v6 && *v6 )
    {
      v3 = *(_QWORD *)(v5 + 8 * v4);
      *v2 = v4;
    }
    ++*(_QWORD *)(a1 + 40);
  }
  while ( !v3 );
  if ( !v3 )
  {
    v7 = *(_QWORD *)(a1 + 24);
    if ( !v7 || (v3 = v7 + 16, *v2 = v7 + 16, v7 == -16) )
      LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 56));
  }
  return v3;
}

//----- (0000000140012398) ----------------------------------------------------
void __fastcall sub_140012398(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1;
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 56));
  *(_QWORD *)(v1 + 40) = 0i64;
}

//----- (00000001400123B8) ----------------------------------------------------
BOOL __fastcall sub_1400123B8(__int64 **a1, __int64 a2)
{
  __int64 *v2; // rdx
  __int64 *v3; // rax

  v2 = (__int64 *)(a2 - 16);
  v3 = (__int64 *)*v2;
  if ( *a1 == v2 )
  {
    *a1 = v3;
    if ( *v2 )
      *(_QWORD *)(*v2 + 8) = 0i64;
  }
  else
  {
    *(_QWORD *)v2[1] = v3;
    if ( *v2 )
      *(_QWORD *)(*v2 + 8) = v2[1];
  }
  return HeapFree(hHeap, 0, v2);
}

//----- (0000000140012400) ----------------------------------------------------
signed __int64 __fastcall sub_140012400(__int64 a1, int a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rax

  v2 = a1;
  v3 = HeapAlloc(hHeap, 8u, a2);
  if ( v3 )
  {
    if ( *(_QWORD *)v2 )
    {
      *(_QWORD *)(*(_QWORD *)v2 + 8i64) = v3;
      *v3 = *(_QWORD *)v2;
    }
    *(_QWORD *)v2 = v3;
  }
  return (signed __int64)(v3 + 2);
}

//----- (0000000140012444) ----------------------------------------------------
signed __int64 __fastcall sub_140012444(_QWORD *a1, __int64 a2)
{
  signed __int64 v2; // rdx

  v2 = a2 - 16;
  while ( 1 )
  {
    if ( !a1 )
      return 0i64;
    if ( a1 == (_QWORD *)v2 )
      break;
    a1 = (_QWORD *)*a1;
  }
  return v2 + 16;
}

//----- (0000000140012460) ----------------------------------------------------
__int64 (__fastcall *sub_140012460())()
{
  __int64 (__fastcall *result)(); // rax

  qword_140021160 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_14001249C;
  qword_140021158 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_140012578;
  qword_140021178 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_1400126D0;
  result = sub_140012658;
  qword_140021190 = (__int64 (__fastcall *)(_QWORD))sub_140012658;
  return result;
}
// 140012658: using guessed type __int64 __fastcall sub_140012658();
// 140021158: using guessed type __int64 (__fastcall *qword_140021158)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140021160: using guessed type __int64 (__fastcall *qword_140021160)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140021178: using guessed type __int64 (__fastcall *qword_140021178)(_QWORD, _QWORD, _QWORD);
// 140021190: using guessed type __int64 (__fastcall *qword_140021190)(_QWORD);

//----- (000000014001249C) ----------------------------------------------------
signed __int64 __fastcall sub_14001249C(__int64 a1, signed __int64 a2, int a3, signed __int64 *a4, __int64 *a5)
{
  __int64 v5; // r14
  int v6; // edi
  signed __int64 *v7; // r12
  int v8; // er13
  signed __int64 v9; // rsi
  signed __int64 v10; // rbx
  _QWORD *v11; // rax
  __int64 v12; // rax

  v5 = a1;
  v6 = 0;
  v7 = a4;
  v8 = a3;
  v9 = a2;
  v10 = 0i64;
  sub_140012660(*a5);
  if ( v9 > 0 )
  {
    v11 = HeapAlloc(hHeap, 0, v9 * v5 + 48);
    v10 = (signed __int64)v11;
    if ( v11 )
    {
      v10 = (signed __int64)(v11 + 6);
      v11[1] = v5;
      v11[4] = v9;
      *((_DWORD *)v11 + 10) = v8;
      v11[2] = v7;
      v11[3] = a5;
      *(_DWORD *)v11 = 1;
      memset(v11 + 6, 0, v9 * v5);
      *a5 = v10;
      if ( sub_140016C40(v7) )
      {
        if ( v9 > 0 )
        {
          v12 = 0i64;
          do
          {
            sub_14001717C(v10 + v5 * v12, v7);
            v12 = ++v6;
          }
          while ( v6 < v9 );
        }
      }
    }
  }
  return v10;
}

//----- (0000000140012578) ----------------------------------------------------
signed __int64 __fastcall sub_140012578(signed __int64 a1, __int64 a2, int a3, signed __int64 *a4, __int64 *a5)
{
  signed __int64 v5; // r10
  signed __int64 *v6; // r14
  int v7; // er15
  __int64 v8; // r12
  signed __int64 v9; // rbx
  signed int v10; // edi
  signed __int64 v11; // rbp
  signed __int64 *v12; // r9
  signed int v13; // er8
  signed __int64 v14; // rsi
  signed int v15; // edx
  __int64 *v16; // rcx
  __int64 v18; // [rsp+68h] [rbp+10h]

  v18 = a2;
  v5 = 0i64;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  v10 = 0;
  v11 = 1i64;
  if ( a1 <= 0 )
    goto LABEL_14;
  v12 = a5 + 1;
  v13 = 1;
  do
  {
    v14 = 1i64;
    if ( *v12 <= 0 )
      v10 = 1;
    v15 = v13;
    v11 *= *v12;
    if ( v13 < v9 )
    {
      v16 = &a5[v13 + 1];
      do
      {
        v14 *= *v16;
        ++v15;
        ++v16;
      }
      while ( v15 < v9 );
    }
    ++v13;
    *v12 = v14;
    ++v12;
  }
  while ( v13 - 1 < v9 );
  v8 = v18;
  if ( !v10 )
  {
LABEL_14:
    v5 = sub_14001249C(v8, v11, v7, v6, a5);
    *(_DWORD *)(v5 - 48) = v9;
  }
  return v5;
}

//----- (0000000140012660) ----------------------------------------------------
BOOL __fastcall sub_140012660(__int64 a1)
{
  __int64 v1; // rbx
  int v2; // esi
  __int64 v3; // rdi
  BOOL result; // eax

  if ( a1 )
  {
    v1 = a1;
    if ( *(_QWORD *)(a1 - 32) )
    {
      v2 = 0;
      v3 = a1;
      if ( *(_QWORD *)(a1 - 16) > 0i64 )
      {
        do
        {
          sub_140017030(v3, *(signed __int64 **)(v1 - 32));
          v3 += *(_QWORD *)(v1 - 40);
          ++v2;
        }
        while ( (signed __int64)v2 < *(_QWORD *)(v1 - 16) );
      }
    }
    **(_QWORD **)(v1 - 24) = 0i64;
    result = HeapFree(hHeap, 0, (LPVOID)(v1 - 48));
  }
  return result;
}

//----- (00000001400126D0) ----------------------------------------------------
__int64 __fastcall sub_1400126D0(void *Src, __int64 a2, int a3)
{
  signed __int64 v3; // rsi
  char *v4; // rbx
  __int64 v5; // rbp
  signed __int64 v6; // rdi
  __int64 v7; // rax
  char *v8; // rdi
  char *v9; // rbp

  v3 = 0i64;
  v4 = (char *)Src;
  if ( Src )
  {
    if ( a2 )
    {
      v5 = *((signed int *)Src - 12);
      v6 = a2 - 48;
      if ( (_DWORD)v5 == *(_DWORD *)(a2 - 48) )
      {
        if ( a3 )
        {
          v6 = sub_14001249C(
                 *((_QWORD *)Src - 5),
                 *((_QWORD *)Src - 2),
                 *((_DWORD *)Src - 2),
                 *((signed __int64 **)Src - 4),
                 *(__int64 **)(v6 + 24))
             - 48;
          *(_DWORD *)v6 = v5;
        }
        if ( (signed int)v5 > 1 )
          memcpy((void *)(*(_QWORD *)(v6 + 24) + 8i64), (const void *)(*((_QWORD *)v4 - 3) + 8i64), 8 * v5);
        v7 = *((_QWORD *)v4 - 2);
        if ( v7 == *(_QWORD *)(v6 + 32) )
        {
          if ( *((_QWORD *)v4 - 4) )
          {
            v8 = (char *)(v6 + 48);
            v9 = v4;
            if ( v7 > 0 )
            {
              do
              {
                sub_140016CA8(v8, *((_QWORD *)v4 - 5), *((int **)v4 - 4), v9);
                v9 += *((_QWORD *)v4 - 5);
                v8 += *((_QWORD *)v4 - 5);
                LODWORD(v3) = v3 + 1;
              }
              while ( (signed __int64)(signed int)v3 < *((_QWORD *)v4 - 2) );
            }
          }
          else
          {
            memcpy((void *)(v6 + 48), v4, v7 * *((_QWORD *)v4 - 5));
          }
          v3 = 1i64;
        }
      }
    }
  }
  return v3;
}

//----- (00000001400127D0) ----------------------------------------------------
BOOL sub_1400127D0()
{
  qword_1400213A0 = HeapCreate(0, 0x1000ui64, 0i64);
  dwTlsIndex = TlsAlloc();
  return sub_140013360();
}

//----- (0000000140012810) ----------------------------------------------------
BOOL sub_140012810()
{
  HeapDestroy(qword_1400213A0);
  return TlsFree(dwTlsIndex);
}

//----- (0000000140012840) ----------------------------------------------------
signed __int64 __fastcall sub_140012840(LPVOID *a1, const wchar_t *a2)
{
  LPVOID v2; // rax
  size_t v4; // [rsp+20h] [rbp-18h]
  LPVOID *v5; // [rsp+40h] [rbp+8h]
  wchar_t *Str; // [rsp+48h] [rbp+10h]

  Str = (wchar_t *)a2;
  v5 = a1;
  v4 = 0i64;
  if ( a2 )
  {
    v4 = wcslen(a2);
    if ( *v5 )
      v2 = HeapReAlloc(qword_1400213A0, 0, *v5, 2 * v4 + 10);
    else
      v2 = HeapAlloc(qword_1400213A0, 0, 2 * v4 + 10);
    *v5 = v2;
    sub_140012F90(*v5, Str, v4);
  }
  else if ( *a1 )
  {
    HeapFree(qword_1400213A0, 0, *a1);
    *v5 = 0i64;
  }
  return 2 * v4 + 2;
}

//----- (0000000140012930) ----------------------------------------------------
__int64 sub_140012930()
{
  DWORD dwErrCode; // ST20_4
  __int64 v1; // ST30_8

  dwErrCode = GetLastError();
  v1 = *((_QWORD *)TlsGetValue(dwTlsIndex) + 2);
  SetLastError(dwErrCode);
  return v1;
}

//----- (0000000140012980) ----------------------------------------------------
__int64 __fastcall sub_140012980(LPVOID *a1, int a2)
{
  LPVOID v2; // rax
  __int64 result; // rax
  int v4; // [rsp+20h] [rbp-18h]
  _DWORD *v5; // [rsp+28h] [rbp-10h]
  LPVOID *v6; // [rsp+40h] [rbp+8h]
  int v7; // [rsp+48h] [rbp+10h]

  v7 = a2;
  v6 = a1;
  v5 = TlsGetValue(dwTlsIndex);
  v4 = v5[4] - v7;
  if ( *v6 )
    v2 = HeapReAlloc(qword_1400213A0, 0, *v6, v4 + 10i64);
  else
    v2 = HeapAlloc(qword_1400213A0, 0, v4 + 10i64);
  *v6 = v2;
  sub_140012F90(*v6, (_DWORD *)(*(_QWORD *)v5 + v7), v4 / 2ui64);
  result = v7;
  *((_QWORD *)v5 + 2) = v7;
  return result;
}

//----- (0000000140012A60) ----------------------------------------------------
void __fastcall sub_140012A60(LPVOID *a1, const wchar_t *a2)
{
  int v2; // ST20_4
  LPVOID *v3; // [rsp+40h] [rbp+8h]
  wchar_t *Str; // [rsp+48h] [rbp+10h]

  Str = (wchar_t *)a2;
  v3 = a1;
  if ( a2 )
  {
    v2 = wcslen(a2);
    *v3 = HeapAlloc(qword_1400213A0, 0, 2i64 * (v2 + 5));
    sub_140012F90(*v3, Str, v2);
  }
}

//----- (0000000140012AD0) ----------------------------------------------------
BOOL __fastcall sub_140012AD0(void *a1)
{
  BOOL result; // eax

  if ( a1 )
    result = HeapFree(qword_1400213A0, 0, a1);
  return result;
}

//----- (0000000140012B00) ----------------------------------------------------
BOOL __fastcall sub_140012B00(LPVOID *a1)
{
  LPVOID *lpMem; // ST20_8

  lpMem = a1;
  HeapFree(qword_1400213A0, 0, *a1);
  return HeapFree(qword_1400213A0, 0, lpMem);
}

//----- (0000000140012B50) ----------------------------------------------------
void *sub_140012B50()
{
  LPVOID v0; // rax
  void *result; // rax
  LPVOID v2; // rax

  if ( dwTlsIndex == -1 )
  {
    sub_1400127D0();
    v0 = TlsGetValue(dwTlsIndex);
    result = sub_140017434((__int64)sub_140012B00, (__int64)v0);
  }
  else
  {
    result = TlsGetValue(dwTlsIndex);
    if ( !result )
    {
      sub_140013360();
      v2 = TlsGetValue(dwTlsIndex);
      result = sub_140017434((__int64)sub_140012B00, (__int64)v2);
    }
  }
  return result;
}

//----- (0000000140012BC0) ----------------------------------------------------
__int64 __fastcall sub_140012BC0(const wchar_t *a1)
{
  __int64 result; // rax
  int v2; // [rsp+20h] [rbp-18h]
  _DWORD *v3; // [rsp+28h] [rbp-10h]
  wchar_t *Str; // [rsp+40h] [rbp+8h]

  Str = (wchar_t *)a1;
  v2 = 0;
  if ( a1 )
    v2 = wcslen(a1);
  v3 = (_DWORD *)sub_140012E40(v2, -1);
  if ( Str )
    return sub_140012F90(v3, Str, v2);
  result = v2;
  *((_WORD *)v3 + v2) = 0;
  return result;
}

//----- (0000000140012C30) ----------------------------------------------------
_BOOL8 __fastcall sub_140012C30(wchar_t *a1, wchar_t *a2)
{
  wchar_t *Str1; // [rsp+30h] [rbp+8h]
  wchar_t *Str2; // [rsp+38h] [rbp+10h]

  Str2 = a2;
  Str1 = a1;
  if ( !a1 )
    Str1 = (wchar_t *)&unk_140021150;
  if ( !a2 )
    Str2 = (wchar_t *)&unk_140021154;
  return wcscmp(Str1, Str2) == 0;
}

//----- (0000000140012C90) ----------------------------------------------------
signed __int64 sub_140012C90()
{
  _QWORD *v0; // rax
  _QWORD *v1; // ST20_8
  signed __int64 result; // rax

  v0 = TlsGetValue(dwTlsIndex);
  v1 = v0;
  result = v0[2] + 2i64;
  v1[2] = result;
  return result;
}

//----- (0000000140012CC0) ----------------------------------------------------
__int64 __fastcall sub_140012CC0(int a1)
{
  _QWORD *v1; // rax
  int v3; // [rsp+40h] [rbp+8h]

  v3 = a1;
  v1 = TlsGetValue(dwTlsIndex);
  v1[2] = v3;
  return v1[2] + *v1;
}

//----- (0000000140012D10) ----------------------------------------------------
__int64 sub_140012D10()
{
  return *(_QWORD *)TlsGetValue(dwTlsIndex);
}

//----- (0000000140012D40) ----------------------------------------------------
__int64 sub_140012D40()
{
  return *(_QWORD *)TlsGetValue(dwTlsIndex);
}

//----- (0000000140012D70) ----------------------------------------------------
__int64 sub_140012D70()
{
  _QWORD *v0; // rcx

  v0 = TlsGetValue(dwTlsIndex);
  return v0[2] + *v0;
}

//----- (0000000140012DA0) ----------------------------------------------------
signed __int64 __fastcall sub_140012DA0(unsigned __int64 a1)
{
  signed __int64 result; // rax
  _QWORD *v2; // [rsp+20h] [rbp-18h]
  unsigned __int64 v3; // [rsp+40h] [rbp+8h]

  v3 = a1;
  v2 = TlsGetValue(dwTlsIndex);
  if ( v3 < *v2 || v3 > v2[2] + *v2 )
    result = 0i64;
  else
    result = v3 - *v2 + 1;
  return result;
}

//----- (0000000140012E10) ----------------------------------------------------
__int64 __fastcall sub_140012E10(int a1)
{
  return *(_QWORD *)TlsGetValue(dwTlsIndex) + a1;
}

//----- (0000000140012E40) ----------------------------------------------------
__int64 __fastcall sub_140012E40(int a1, int a2)
{
  __int64 v2; // ST30_8
  int v4; // [rsp+20h] [rbp-28h]
  _DWORD *v5; // [rsp+28h] [rbp-20h]
  int v6; // [rsp+50h] [rbp+8h]
  int v7; // [rsp+58h] [rbp+10h]

  v7 = a2;
  v6 = a1;
  v5 = TlsGetValue(dwTlsIndex);
  if ( v7 == -1 )
    v7 = v5[4];
  v4 = v5[4] + 2 * v6;
  if ( v4 >= *((_QWORD *)v5 + 1) - 4i64 )
  {
    *((_QWORD *)v5 + 1) = v4 + 0x4000;
    *(_QWORD *)v5 = HeapReAlloc(qword_1400213A0, 0, *(LPVOID *)v5, *((_QWORD *)v5 + 1) + 10i64);
  }
  v2 = *(_QWORD *)v5 + v7;
  *((_QWORD *)v5 + 2) = v7 + 2i64 * v6;
  return v2;
}

//----- (0000000140012F20) ----------------------------------------------------
__int64 __fastcall sub_140012F20(int a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // ST20_8
  __int64 result; // rax
  int v4; // [rsp+40h] [rbp+8h]

  v4 = a1;
  v1 = TlsGetValue(dwTlsIndex);
  v2 = v1;
  v1[2] = v4;
  result = v4;
  *(_WORD *)(*v2 + v4) = 0;
  return result;
}

//----- (0000000140012F60) ----------------------------------------------------
signed __int64 __fastcall sub_140012F60(int a1)
{
  return *(_QWORD *)TlsGetValue(dwTlsIndex) + a1 - 1i64;
}

//----- (0000000140012F90) ----------------------------------------------------
__int64 __fastcall sub_140012F90(_DWORD *a1, _DWORD *a2, int a3)
{
  __int64 result; // rax
  _DWORD *v4; // [rsp+20h] [rbp+8h]
  _DWORD *v5; // [rsp+28h] [rbp+10h]
  int v6; // [rsp+30h] [rbp+18h]

  v6 = a3;
  v5 = a2;
  v4 = a1;
  while ( v6 > 0 )
  {
    *v4 = *v5;
    ++v4;
    ++v5;
    v6 -= 2;
  }
  result = 0i64;
  *((_WORD *)a1 + a3) = 0;
  return result;
}

//----- (0000000140013010) ----------------------------------------------------
__int64 __fastcall sub_140013010(int a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // ST20_8
  __int64 result; // rax
  int v4; // [rsp+40h] [rbp+8h]

  v4 = a1;
  v1 = TlsGetValue(dwTlsIndex);
  v2 = v1;
  result = v1[2] - 2 * v4;
  v2[2] = result;
  return result;
}

//----- (0000000140013050) ----------------------------------------------------
_BYTE *__fastcall sub_140013050(char *a1, __int64 a2)
{
  char v3; // [rsp+0h] [rbp-28h]
  __int64 v4; // [rsp+8h] [rbp-20h]
  char *v5; // [rsp+30h] [rbp+8h]

  v5 = a1;
  v4 = 0i64;
  while ( *v5 && v4 < a2 )
  {
    v3 = *v5;
    if ( *v5 & 0x80 )
    {
      if ( (v3 & 0xE0) == 192 )
      {
        if ( (*++v5 & 0xC0) == 128 )
        {
          ++v5;
          ++v4;
        }
      }
      else if ( (v3 & 0xF0) == 224 && v5[1] )
      {
        if ( (v5[1] & 0xC0) != 128 || (v5[2] & 0xC0) != 128 )
        {
          if ( (v5[1] & 0xC0) == 128 )
            v5 += 2;
          else
            ++v5;
        }
        else
        {
          v5 += 3;
          ++v4;
        }
      }
      else if ( (v3 & 0xF8) == 240 && v5[1] && v5[2] )
      {
        if ( (v5[1] & 0xC0) != 128 || (v5[2] & 0xC0) != 128 || (v5[3] & 0xC0) != 128 )
        {
          if ( (v5[1] & 0xC0) != 128 || (v5[2] & 0xC0) != 128 )
          {
            if ( (v5[1] & 0xC0) == 128 )
              v5 += 2;
            else
              ++v5;
          }
          else
          {
            v5 += 3;
          }
        }
        else
        {
          v5 += 4;
          ++v4;
        }
      }
      else
      {
        ++v5;
      }
    }
    else
    {
      ++v5;
      ++v4;
    }
  }
  return (_BYTE *)(v5 - a1);
}

//----- (0000000140013360) ----------------------------------------------------
BOOL sub_140013360()
{
  _QWORD *lpTlsValue; // ST20_8

  lpTlsValue = HeapAlloc(qword_1400213A0, 0, 0x18ui64);
  *lpTlsValue = HeapAlloc(qword_1400213A0, 0, 0x10ui64);
  lpTlsValue[1] = 16i64;
  lpTlsValue[2] = 0i64;
  return TlsSetValue(dwTlsIndex, lpTlsValue);
}

//----- (0000000140013430) ----------------------------------------------------
signed __int64 __fastcall sub_140013430(__int64 a1, int *a2, __int64 a3, int a4)
{
  int v4; // eax
  int *v5; // rdi
  signed __int64 result; // rax
  unsigned int v7; // ebx
  __int64 v8; // [rsp+20h] [rbp-68h]
  int v9; // [rsp+28h] [rbp-60h]
  __int64 v10; // [rsp+30h] [rbp-58h]
  int v11; // [rsp+38h] [rbp-50h]
  int v12; // [rsp+3Ch] [rbp-4Ch]
  __int64 v13; // [rsp+50h] [rbp-38h]
  __int64 v14; // [rsp+58h] [rbp-30h]

  v4 = *a2;
  v5 = a2;
  v8 = a3;
  v11 = v4;
  v10 = a1;
  v9 = a4;
  v13 = 0i64;
  v14 = 0i64;
  result = sub_140015100(&v8, "1.2.8", 88);
  if ( !(_DWORD)result )
  {
    v7 = sub_140013530((unsigned __int8 **)&v8, 4);
    if ( v7 == 1 )
    {
      *v5 = v12;
      result = sub_140014F20(&v8);
    }
    else
    {
      sub_140014F20(&v8);
      if ( v7 != 2 && (v7 != -5 || v9) )
        result = v7;
      else
        result = 4294967293i64;
    }
  }
  return result;
}

//----- (0000000140013530) ----------------------------------------------------
signed __int64 __fastcall sub_140013530(unsigned __int8 **a1, int a2)
{
  unsigned __int8 **v2; // rdi
  int *v3; // r12
  unsigned int v4; // er11
  __int64 v5; // rax
  unsigned __int8 *v6; // r9
  unsigned int v7; // esi
  unsigned __int8 *v8; // r14
  unsigned int v9; // er15
  unsigned int v10; // ebx
  int v11; // er10
  _DWORD *v12; // rdx
  unsigned int *v13; // r8
  unsigned int v14; // edx
  char v15; // cl
  int v16; // eax
  __int64 v17; // rax
  unsigned int v18; // eax
  unsigned int v19; // ecx
  unsigned int v20; // eax
  char v21; // cl
  int v22; // eax
  _DWORD *v23; // rcx
  char v24; // cl
  int v25; // eax
  __int64 v26; // rax
  char v27; // cl
  int v28; // eax
  __int64 v29; // rcx
  char v30; // cl
  int v31; // eax
  __int64 v32; // rax
  __int64 v33; // rax
  unsigned int v34; // ecx
  unsigned int v35; // edi
  __int64 v36; // rax
  __int64 v37; // r9
  unsigned int v38; // edx
  unsigned int v39; // ecx
  unsigned int v40; // ecx
  unsigned int v41; // edi
  __int64 v42; // rax
  int v43; // er13
  __int64 v44; // rax
  __int64 v45; // rdx
  __int64 v46; // rcx
  __int64 v47; // rax
  unsigned int v48; // edi
  __int64 v49; // rax
  int v50; // er13
  __int64 v51; // rax
  __int64 v52; // rdx
  __int64 v53; // rcx
  __int64 v54; // rax
  char v55; // cl
  int v56; // eax
  __int64 v57; // rcx
  unsigned int v58; // eax
  char v59; // cl
  int v60; // eax
  int v61; // eax
  unsigned int v62; // eax
  int v63; // ecx
  char v64; // cl
  int v65; // eax
  char v66; // al
  unsigned int v67; // er15
  int v68; // ebx
  int v69; // ecx
  int v70; // ecx
  char v71; // cl
  int v72; // eax
  unsigned int v73; // er13
  char v74; // cl
  int v75; // eax
  char v76; // cl
  unsigned int v77; // er15
  char v78; // dl
  unsigned int v79; // ecx
  int v80; // eax
  unsigned int v81; // edx
  char v82; // cl
  int v83; // eax
  __int16 v84; // cx
  unsigned int v85; // eax
  unsigned int v86; // er10
  int i; // eax
  char v88; // cl
  unsigned int j; // edx
  char v90; // cl
  int v91; // eax
  char v92; // dl
  __int16 v93; // r8
  int v94; // edx
  char v95; // cl
  int v96; // eax
  signed int v97; // eax
  unsigned int v98; // er15
  char v99; // cl
  int v100; // eax
  unsigned int v101; // er15
  unsigned int *v102; // ST20_8
  __int64 v103; // r8
  const char *v104; // rax
  __int64 v105; // r8
  __int64 v106; // rax
  unsigned int v107; // er13
  bool v108; // zf
  __int64 v109; // r11
  signed int v110; // eax
  unsigned int v111; // eax
  char v112; // cl
  unsigned int v113; // er10
  char v114; // dl
  unsigned int v115; // edx
  char v116; // cl
  int v117; // eax
  int v118; // eax
  unsigned int v119; // eax
  __int64 v120; // r11
  unsigned int v121; // eax
  char v122; // cl
  unsigned int v123; // er10
  char v124; // dl
  unsigned int v125; // edx
  char v126; // cl
  int v127; // eax
  int v128; // eax
  __int64 v129; // rcx
  unsigned int v130; // ecx
  unsigned int v131; // eax
  __int64 v132; // rdx
  unsigned int v133; // eax
  char *v134; // rdx
  signed __int64 v135; // rdx
  char v136; // al
  char v137; // cl
  int v138; // eax
  unsigned int v139; // er10
  unsigned int v140; // ecx
  char *v141; // rdx
  unsigned int v142; // eax
  int v143; // ecx
  char v144; // cl
  int v145; // eax
  signed __int64 result; // rax
  int v147; // ebx
  unsigned int v148; // ebx
  int v149; // er10
  unsigned int v150; // ecx
  char *v151; // rdx
  unsigned int v152; // eax
  int v153; // edx
  signed int v154; // er9
  signed int v155; // er8
  __int16 v156; // [rsp+30h] [rbp-50h]
  char v157; // [rsp+32h] [rbp-4Eh]
  char v158; // [rsp+33h] [rbp-4Dh]
  int v159; // [rsp+34h] [rbp-4Ch]
  int v160; // [rsp+38h] [rbp-48h]
  int v161; // [rsp+3Ch] [rbp-44h]
  unsigned __int8 *v162; // [rsp+40h] [rbp-40h]
  __int64 v163; // [rsp+A0h] [rbp+20h]
  int v164; // [rsp+A8h] [rbp+28h]
  unsigned int v165; // [rsp+B0h] [rbp+30h]
  unsigned int v166; // [rsp+B8h] [rbp+38h]

  v164 = a2;
  v163 = (__int64)a1;
  v2 = a1;
  if ( !a1 )
    return 4294967294i64;
  v3 = (int *)a1[5];
  if ( !v3 || !a1[2] || !*a1 && *((_DWORD *)a1 + 2) )
    return 4294967294i64;
  if ( *v3 == 11 )
    *v3 = 12;
  v4 = *((_DWORD *)a1 + 6);
  v5 = (unsigned int)*v3;
  v6 = a1[2];
  v7 = *((_DWORD *)a1 + 2);
  v8 = *a1;
  v9 = v3[16];
  v10 = v3[17];
  v162 = a1[2];
  v166 = v4;
  v161 = v7;
  v11 = v4;
  v159 = v4;
  v165 = 0;
  while ( 2 )
  {
    v12 = v3 + 27;
    v13 = (unsigned int *)(v3 + 26);
    switch ( 0x40000000 )
    {
      case 0:
        v14 = v3[2];
        if ( !v14 )
        {
          *v3 = 12;
          goto LABEL_129;
        }
        for ( ; v10 < 0x10; v9 += v16 )
        {
          if ( !v7 )
            goto LABEL_316;
          v15 = v10;
          v10 += 8;
          v16 = *v8 << v15;
          --v7;
          ++v8;
        }
        if ( v14 & 2 && v9 == 35615 )
        {
          v3[6] = sub_1400155F0(0, 0i64, 0);
          v156 = -29921;
          v9 = 0;
          v10 = 0;
          v3[6] = sub_1400155F0(v3[6], (char *)&v156, 2u);
          *v3 = 1;
          goto LABEL_127;
        }
        v17 = *((_QWORD *)v3 + 4);
        v3[4] = 0;
        if ( v17 )
          *(_DWORD *)(v17 + 64) = -1;
        if ( v3[2] & 1
          && (v9 >> 8) + ((unsigned __int8)v9 << 8) == 31 * (((v9 >> 8) + ((unsigned __int8)v9 << 8)) / 0x1F) )
        {
          if ( (v9 & 0xF) != 8 )
            goto LABEL_23;
          v18 = v3[10];
          v9 >>= 4;
          v10 -= 4;
          v19 = (v9 & 0xF) + 8;
          if ( v18 )
          {
            if ( v19 > v18 )
            {
              v2[4] = "invalid window size";
              *v3 = 29;
              goto LABEL_129;
            }
          }
          else
          {
            v3[10] = v19;
          }
          v3[5] = 1 << v19;
          v20 = sub_140015E90(0, 0i64, 0);
          v3[6] = v20;
          *((_DWORD *)v2 + 19) = v20;
          v10 = 0;
          *v3 = ~BYTE1(v9) & 2 | 9;
          v9 = 0;
          goto LABEL_127;
        }
        v2[4] = "incorrect header check";
        *v3 = 29;
        goto LABEL_129;
      case 1:
        if ( v10 >= 0x10 )
          goto LABEL_33;
        do
        {
          if ( !v7 )
          {
            v107 = v165;
            v69 = v164;
            goto LABEL_318;
          }
          v21 = v10;
          v10 += 8;
          v22 = *v8 << v21;
          --v7;
          ++v8;
          v9 += v22;
        }
        while ( v10 < 0x10 );
LABEL_33:
        v3[4] = v9;
        if ( (_BYTE)v9 != 8 )
        {
LABEL_23:
          v2[4] = "unknown compression method";
          *v3 = 29;
          goto LABEL_129;
        }
        if ( v9 & 0xE000 )
        {
          v2[4] = "unknown header flags set";
          *v3 = 29;
          goto LABEL_129;
        }
        v23 = (_DWORD *)*((_QWORD *)v3 + 4);
        if ( v23 )
          *v23 = 0;
        if ( v3[4] & 0x200 )
        {
          v156 = v9;
          v3[6] = sub_1400155F0(v3[6], (char *)&v156, 2u);
        }
        v9 = 0;
        v10 = 0;
        *v3 = 2;
        do
        {
LABEL_42:
          if ( !v7 )
            goto LABEL_316;
          v24 = v10;
          v10 += 8;
          v25 = *v8 << v24;
          --v7;
          ++v8;
          v9 += v25;
        }
        while ( v10 < 0x20 );
LABEL_44:
        v26 = *((_QWORD *)v3 + 4);
        if ( v26 )
          *(_DWORD *)(v26 + 4) = v9;
        if ( v3[4] & 0x200 )
        {
          v156 = v9;
          v158 = HIBYTE(v9);
          v157 = BYTE2(v9);
          v3[6] = sub_1400155F0(v3[6], (char *)&v156, 4u);
        }
        v9 = 0;
        v10 = 0;
        *v3 = 3;
        do
        {
LABEL_50:
          if ( !v7 )
            goto LABEL_316;
          v27 = v10;
          v10 += 8;
          v28 = *v8 << v27;
          --v7;
          ++v8;
          v9 += v28;
        }
        while ( v10 < 0x10 );
LABEL_52:
        v29 = *((_QWORD *)v3 + 4);
        if ( v29 )
        {
          *(_DWORD *)(v29 + 8) = (unsigned __int8)v9;
          *(_DWORD *)(*((_QWORD *)v3 + 4) + 12i64) = v9 >> 8;
        }
        if ( v3[4] & 0x200 )
        {
          v156 = v9;
          v3[6] = sub_1400155F0(v3[6], (char *)&v156, 2u);
        }
        v9 = 0;
        v10 = 0;
        *v3 = 4;
LABEL_57:
        if ( v3[4] & 0x400 )
        {
          if ( v10 < 0x10 )
          {
            while ( v7 )
            {
              v30 = v10;
              v10 += 8;
              v31 = *v8 << v30;
              --v7;
              ++v8;
              v9 += v31;
              if ( v10 >= 0x10 )
                goto LABEL_61;
            }
            goto LABEL_316;
          }
LABEL_61:
          v32 = *((_QWORD *)v3 + 4);
          v3[18] = v9;
          if ( v32 )
            *(_DWORD *)(v32 + 24) = v9;
          if ( v3[4] & 0x200 )
          {
            v156 = v9;
            v3[6] = sub_1400155F0(v3[6], (char *)&v156, 2u);
          }
          v9 = 0;
          v10 = 0;
        }
        else
        {
          v33 = *((_QWORD *)v3 + 4);
          if ( v33 )
            *(_QWORD *)(v33 + 16) = 0i64;
        }
        *v3 = 5;
LABEL_69:
        if ( v3[4] & 0x400 )
        {
          v34 = v3[18];
          v35 = v3[18];
          if ( v34 > v7 )
            v35 = v7;
          if ( v35 )
          {
            v36 = *((_QWORD *)v3 + 4);
            if ( v36 )
            {
              v37 = *(_QWORD *)(v36 + 16);
              if ( v37 )
              {
                v38 = *(_DWORD *)(v36 + 24) - v34;
                v39 = *(_DWORD *)(v36 + 28);
                if ( v35 + v38 <= v39 )
                  v40 = v35;
                else
                  v40 = v39 - v38;
                memcpy((void *)(v37 + v38), v8, v40);
              }
            }
            if ( v3[4] & 0x200 )
              v3[6] = sub_1400155F0(v3[6], (char *)v8, v35);
            v7 -= v35;
            v8 += v35;
            v3[18] -= v35;
          }
          if ( v3[18] )
            goto LABEL_316;
        }
        v3[18] = 0;
        *v3 = 6;
LABEL_84:
        if ( v3[4] & 0x800 )
        {
          if ( !v7 )
            goto LABEL_316;
          v41 = 0;
          do
          {
            v42 = v41++;
            v43 = v8[v42];
            v44 = *((_QWORD *)v3 + 4);
            if ( v44 )
            {
              v45 = *(_QWORD *)(v44 + 32);
              if ( v45 )
              {
                v46 = (unsigned int)v3[18];
                if ( (unsigned int)v46 < *(_DWORD *)(v44 + 40) )
                {
                  *(_BYTE *)(v46 + v45) = v43;
                  ++v3[18];
                }
              }
            }
          }
          while ( v43 && v41 < v7 );
          if ( v3[4] & 0x200 )
            v3[6] = sub_1400155F0(v3[6], (char *)v8, v41);
          v7 -= v41;
          v8 += v41;
          if ( v43 )
            goto LABEL_316;
        }
        else
        {
          v47 = *((_QWORD *)v3 + 4);
          if ( v47 )
            *(_QWORD *)(v47 + 32) = 0i64;
        }
        v3[18] = 0;
        *v3 = 7;
LABEL_100:
        if ( v3[4] & 0x1000 )
        {
          if ( !v7 )
            goto LABEL_316;
          v48 = 0;
          do
          {
            v49 = v48++;
            v50 = v8[v49];
            v51 = *((_QWORD *)v3 + 4);
            if ( v51 )
            {
              v52 = *(_QWORD *)(v51 + 48);
              if ( v52 )
              {
                v53 = (unsigned int)v3[18];
                if ( (unsigned int)v53 < *(_DWORD *)(v51 + 56) )
                {
                  *(_BYTE *)(v53 + v52) = v50;
                  ++v3[18];
                }
              }
            }
          }
          while ( v50 && v48 < v7 );
          if ( v3[4] & 0x200 )
            v3[6] = sub_1400155F0(v3[6], (char *)v8, v48);
          v7 -= v48;
          v8 += v48;
          if ( v50 )
            goto LABEL_316;
        }
        else
        {
          v54 = *((_QWORD *)v3 + 4);
          if ( v54 )
            *(_QWORD *)(v54 + 48) = 0i64;
        }
        v2 = (unsigned __int8 **)v163;
        v6 = v162;
        v4 = v166;
        *v3 = 8;
LABEL_116:
        if ( v3[4] & 0x200 )
        {
          if ( v10 < 0x10 )
          {
            while ( v7 )
            {
              v55 = v10;
              v10 += 8;
              v56 = *v8 << v55;
              --v7;
              ++v8;
              v9 += v56;
              if ( v10 >= 0x10 )
                goto LABEL_120;
            }
            goto LABEL_316;
          }
LABEL_120:
          if ( v9 != *((unsigned __int16 *)v3 + 12) )
          {
            v2[4] = "header crc mismatch";
            *v3 = 29;
            goto LABEL_129;
          }
          v9 = 0;
          v10 = 0;
        }
        v57 = *((_QWORD *)v3 + 4);
        if ( v57 )
        {
          *(_DWORD *)(v57 + 60) = (v3[4] >> 9) & 1;
          *(_DWORD *)(*((_QWORD *)v3 + 4) + 64i64) = 1;
        }
        v58 = sub_1400155F0(0, 0i64, 0);
        v3[6] = v58;
        *((_DWORD *)v2 + 19) = v58;
LABEL_126:
        *v3 = 11;
LABEL_127:
        v4 = v166;
LABEL_128:
        v6 = v162;
LABEL_129:
        if ( (unsigned int)*v3 <= 0x1E )
        {
          v11 = v159;
          continue;
        }
        return 4294967294i64;
      case 2:
        if ( v10 < 0x20 )
          goto LABEL_42;
        goto LABEL_44;
      case 3:
        if ( v10 < 0x10 )
          goto LABEL_50;
        goto LABEL_52;
      case 4:
        goto LABEL_57;
      case 5:
        goto LABEL_69;
      case 6:
        goto LABEL_84;
      case 7:
        goto LABEL_100;
      case 8:
        goto LABEL_116;
      case 9:
        if ( v10 >= 0x20 )
          goto LABEL_134;
        do
        {
          if ( !v7 )
            goto LABEL_316;
          v59 = v10;
          v10 += 8;
          v60 = *v8 << v59;
          --v7;
          ++v8;
          v9 += v60;
        }
        while ( v10 < 0x20 );
LABEL_134:
        v10 = 0;
        v61 = (v9 >> 24) + (((v9 << 16) + (v9 & 0xFF00)) << 8) + ((v9 >> 8) & 0xFF00);
        v9 = 0;
        v3[6] = v61;
        *((_DWORD *)v2 + 19) = v61;
        *v3 = 10;
LABEL_135:
        if ( !v3[3] )
        {
          v2[2] = v6;
          *((_DWORD *)v2 + 6) = v4;
          *v2 = v8;
          *((_DWORD *)v2 + 2) = v7;
          result = 2i64;
          v3[16] = v9;
          v3[17] = v10;
          return result;
        }
        v62 = sub_140015E90(0, 0i64, 0);
        v6 = v162;
        v4 = v166;
        v3[6] = v62;
        *((_DWORD *)v2 + 19) = v62;
        v13 = (unsigned int *)(v3 + 26);
        *v3 = 11;
        v12 = v3 + 27;
LABEL_137:
        if ( (unsigned int)(v164 - 5) <= 1 )
          goto LABEL_316;
LABEL_138:
        if ( v3[1] )
        {
          *v3 = 26;
          v63 = v10 & 7;
          v9 >>= v63;
          v10 -= v63;
          goto LABEL_129;
        }
        for ( ; v10 < 3; v9 += v65 )
        {
          if ( !v7 )
            goto LABEL_316;
          v64 = v10;
          v10 += 8;
          v65 = *v8 << v64;
          --v7;
          ++v8;
        }
        v66 = v9;
        v67 = v9 >> 1;
        v68 = v10 - 1;
        v3[1] = v66 & 1;
        if ( !(v67 & 3) )
        {
          *v3 = 13;
          goto LABEL_152;
        }
        if ( (v67 & 3) != 1 )
        {
          if ( (v67 & 3) == 2 )
          {
            v9 = v67 >> 2;
            *v3 = 16;
            v10 = v68 - 2;
            goto LABEL_129;
          }
          if ( (v67 & 3) == 3 )
          {
            v9 = v67 >> 2;
            v10 = v68 - 2;
            v2[4] = "invalid block type";
            *v3 = 29;
            goto LABEL_129;
          }
          goto LABEL_152;
        }
        v69 = v164;
        *v13 = 9;
        *((_QWORD *)v3 + 11) = "`\a";
        *v12 = 5;
        *v3 = 19;
        *((_QWORD *)v3 + 12) = &unk_14001A6C0;
        if ( v164 != 6 )
        {
LABEL_152:
          v9 = v67 >> 2;
          v10 = v68 - 2;
          goto LABEL_129;
        }
        v9 = v67 >> 2;
        v10 = v68 - 2;
LABEL_317:
        v107 = v165;
LABEL_318:
        *(_QWORD *)(v163 + 16) = v162;
        *(_QWORD *)v163 = v8;
        *(_DWORD *)(v163 + 24) = v166;
        *(_DWORD *)(v163 + 8) = v7;
        v108 = v3[11] == 0;
        v3[17] = v10;
        v147 = v159;
        v3[16] = v9;
        if ( v108 && (v147 == *(_DWORD *)(v163 + 24) || *v3 >= 29 || *v3 >= 26 && v69 == 4)
          || !(unsigned int)sub_1400154F0(v163, *(_QWORD *)(v163 + 16), v147 - *(_DWORD *)(v163 + 24)) )
        {
          v148 = v147 - *(_DWORD *)(v163 + 24);
          v149 = v161 - *(_DWORD *)(v163 + 8);
          *(_DWORD *)(v163 + 28) += v148;
          *(_DWORD *)(v163 + 12) += v149;
          v3[7] += v148;
          v108 = v3[2] == 0;
          v161 = v149;
          if ( !v108 && v148 )
          {
            v150 = v3[6];
            v151 = (char *)(*(_QWORD *)(v163 + 16) - v148);
            if ( v3[4] )
              v152 = sub_1400155F0(v150, v151, v148);
            else
              v152 = sub_140015E90(v150, (unsigned __int8 *)v151, v148);
            v149 = v161;
            v3[6] = v152;
            *(_DWORD *)(v163 + 76) = v152;
          }
          v153 = *v3;
          if ( *v3 == 19 || v153 == 14 )
          {
            v155 = 256;
            v154 = 0;
          }
          else
          {
            v154 = 0;
            v155 = 0;
          }
          if ( v153 == 11 )
            v154 = 128;
          *(_DWORD *)(v163 + 72) = v3[17] + v155 + (v3[1] != 0 ? 0x40 : 0) + v154;
          if ( (!v149 && !v148 || v164 == 4) && !v107 )
            v107 = -5;
          result = v107;
        }
        else
        {
          *v3 = 30;
LABEL_325:
          result = 4294967292i64;
        }
        return result;
      case 10:
        goto LABEL_135;
      case 11:
        goto LABEL_137;
      case 12:
        goto LABEL_138;
      case 13:
        v70 = v10 & 7;
        v10 -= v70;
        v9 >>= v70;
        if ( v10 >= 0x20 )
          goto LABEL_156;
        do
        {
          if ( !v7 )
            goto LABEL_316;
          v71 = v10;
          v10 += 8;
          v72 = *v8 << v71;
          --v7;
          ++v8;
          v9 += v72;
        }
        while ( v10 < 0x20 );
LABEL_156:
        if ( (unsigned __int16)v9 != ~v9 >> 16 )
        {
          v2[4] = "invalid stored block lengths";
          *v3 = 29;
          goto LABEL_129;
        }
        v3[18] = (unsigned __int16)v9;
        v69 = v164;
        v9 = 0;
        v10 = 0;
        *v3 = 14;
        if ( v164 == 6 )
          goto LABEL_317;
LABEL_159:
        *v3 = 15;
LABEL_160:
        v73 = v3[18];
        if ( v73 )
        {
          if ( v73 > v7 )
            v73 = v7;
          if ( v73 > v4 )
            v73 = v4;
          if ( !v73 )
            goto LABEL_316;
          memcpy(v6, v8, v73);
          v4 = v166 - v73;
          v8 += v73;
          v6 = &v162[v73];
          v2 = (unsigned __int8 **)v163;
          v7 -= v73;
          v3[18] -= v73;
          v166 -= v73;
          v162 = v6;
        }
        else
        {
          *v3 = 11;
        }
        goto LABEL_129;
      case 14:
        goto LABEL_159;
      case 15:
        goto LABEL_160;
      case 16:
        if ( v10 >= 0xE )
          goto LABEL_171;
        do
        {
          if ( !v7 )
            goto LABEL_316;
          v74 = v10;
          v10 += 8;
          v75 = *v8 << v74;
          --v7;
          ++v8;
          v9 += v75;
        }
        while ( v10 < 0xE );
LABEL_171:
        v76 = v9;
        v77 = v9 >> 5;
        v10 -= 14;
        v78 = v77;
        v77 >>= 5;
        v79 = (v76 & 0x1F) + 257;
        v80 = v77 & 0xF;
        v81 = (v78 & 0x1F) + 1;
        v9 = v77 >> 4;
        v3[29] = v79;
        v3[30] = v81;
        v3[28] = v80 + 4;
        if ( v79 > 0x11E || v81 > 0x1E )
        {
          v2[4] = "too many length or distance symbols";
          *v3 = 29;
          goto LABEL_129;
        }
        v3[31] = 0;
        *v3 = 17;
LABEL_174:
        while ( v3[31] < (unsigned int)v3[28] )
        {
          for ( ; v10 < 3; v9 += v83 )
          {
            if ( !v7 )
              goto LABEL_316;
            v82 = v10;
            v10 += 8;
            v83 = *v8 << v82;
            --v7;
            ++v8;
          }
          v10 -= 3;
          v84 = v9 & 7;
          v9 >>= 3;
          *((_WORD *)v3 + (unsigned __int16)word_14001A740[v3[31]++] + 68) = v84;
        }
        for ( ; (unsigned int)v3[31] < 0x13; ++v3[31] )
          *((_WORD *)v3 + (unsigned __int16)word_14001A740[v3[31]] + 68) = 0;
        *((_QWORD *)v3 + 16) = v3 + 338;
        *((_QWORD *)v3 + 11) = v3 + 338;
        *v13 = 7;
        v85 = sub_140016240(
                0,
                (unsigned __int16 *)v3 + 68,
                19i64,
                (_QWORD *)v3 + 16,
                (unsigned int *)v3 + 26,
                (char *)v3 + 776);
        v4 = v166;
        v165 = v85;
        if ( v85 )
        {
          v2[4] = "invalid code lengths set";
          *v3 = 29;
          goto LABEL_128;
        }
        v3[31] = 0;
        *v3 = 18;
        v13 = (unsigned int *)(v3 + 26);
LABEL_185:
        v86 = v3[31];
        if ( v86 >= v3[29] + v3[30] )
          goto LABEL_212;
        do
        {
          v160 = *(_DWORD *)(*((_QWORD *)v3 + 11) + 4i64 * (v9 & ((1 << *v13) - 1)));
          for ( i = v160; BYTE1(i) > v10; i = v160 )
          {
            if ( !v7 )
              goto LABEL_316;
            v88 = v10;
            v10 += 8;
            --v7;
            v9 += *v8++ << v88;
            v160 = *(_DWORD *)(*((_QWORD *)v3 + 11) + 4i64 * (v9 & ((1 << *v13) - 1)));
          }
          if ( HIWORD(i) >= 0x10u )
          {
            if ( HIWORD(i) == 16 )
            {
              for ( j = BYTE1(i) + 2; v10 < j; v9 += v91 )
              {
                if ( !v7 )
                  goto LABEL_316;
                v90 = v10;
                v10 += 8;
                v91 = *v8 << v90;
                --v7;
                ++v8;
              }
              v9 >>= SBYTE1(v160);
              v10 -= BYTE1(v160);
              if ( !v86 )
              {
LABEL_215:
                v2[4] = "invalid bit length repeat";
                *v3 = 29;
                goto LABEL_128;
              }
              v92 = v9;
              v9 >>= 2;
              v93 = *((_WORD *)v3 + v86 - 1 + 68);
              v94 = (v92 & 3) + 3;
              v10 -= 2;
            }
            else
            {
              if ( HIWORD(v160) == 17 )
              {
                for ( ; v10 < (unsigned int)BYTE1(v160) + 3; v9 += v96 )
                {
                  if ( !v7 )
                    goto LABEL_316;
                  v95 = v10;
                  v10 += 8;
                  v96 = *v8 << v95;
                  --v7;
                  ++v8;
                }
                v97 = -3;
                v98 = v9 >> SBYTE1(v160);
                v94 = (v98 & 7) + 3;
                v9 = v98 >> 3;
              }
              else
              {
                for ( ; v10 < (unsigned int)BYTE1(v160) + 7; v9 += v100 )
                {
                  if ( !v7 )
                    goto LABEL_316;
                  v99 = v10;
                  v10 += 8;
                  v100 = *v8 << v99;
                  --v7;
                  ++v8;
                }
                v97 = -7;
                v101 = v9 >> SBYTE1(v160);
                v94 = (v101 & 0x7F) + 11;
                v9 = v101 >> 7;
              }
              v93 = 0;
              v10 += v97 - BYTE1(v160);
            }
            if ( v86 + v94 > v3[29] + v3[30] )
              goto LABEL_215;
            for ( ; v94; --v94 )
              *((_WORD *)v3 + (unsigned int)v3[31]++ + 68) = v93;
            v13 = (unsigned int *)(v3 + 26);
          }
          else
          {
            *((_WORD *)v3 + v86 + 68) = HIWORD(i);
            v9 >>= SBYTE1(i);
            v10 -= BYTE1(i);
            ++v3[31];
          }
          v86 = v3[31];
        }
        while ( v86 < v3[29] + v3[30] );
LABEL_212:
        if ( *v3 == 29 )
          goto LABEL_128;
        if ( !*((_WORD *)v3 + 324) )
        {
          v2[4] = "invalid code -- missing end-of-block";
          *v3 = 29;
          goto LABEL_128;
        }
        *v13 = 9;
        v102 = v13;
        v103 = (unsigned int)v3[29];
        *((_QWORD *)v3 + 16) = v3 + 338;
        *((_QWORD *)v3 + 11) = v3 + 338;
        v165 = sub_140016240(1, (unsigned __int16 *)v3 + 68, v103, (_QWORD *)v3 + 16, v102, (char *)v3 + 776);
        if ( v165 )
        {
          v104 = "invalid literal/lengths set";
LABEL_218:
          v2 = (unsigned __int8 **)v163;
          *(_QWORD *)(v163 + 32) = v104;
          *v3 = 29;
          goto LABEL_127;
        }
        v105 = (unsigned int)v3[30];
        *((_QWORD *)v3 + 12) = *((_QWORD *)v3 + 16);
        v106 = (unsigned int)v3[29];
        v3[27] = 6;
        v107 = sub_140016240(
                 2,
                 (unsigned __int16 *)v3 + v106 + 68,
                 v105,
                 (_QWORD *)v3 + 16,
                 (unsigned int *)v3 + 27,
                 (char *)v3 + 776);
        v165 = v107;
        if ( v107 )
        {
          v104 = "invalid distances set";
          goto LABEL_218;
        }
        v69 = v164;
        *v3 = 19;
        if ( v164 == 6 )
          goto LABEL_318;
        v2 = (unsigned __int8 **)v163;
        v6 = v162;
        v11 = v159;
        v4 = v166;
        v13 = (unsigned int *)(v3 + 26);
LABEL_223:
        *v3 = 20;
LABEL_224:
        if ( v7 >= 6 && v4 >= 0x102 )
        {
          v2[2] = v6;
          *((_DWORD *)v2 + 6) = v4;
          *v2 = v8;
          *((_DWORD *)v2 + 2) = v7;
          v3[16] = v9;
          v3[17] = v10;
          sub_1400166A0((__int64 *)v2, v11);
          v108 = *v3 == 11;
          v6 = v2[2];
          v4 = *((_DWORD *)v2 + 6);
          v8 = *v2;
          v7 = *((_DWORD *)v2 + 2);
          v9 = v3[16];
          v10 = v3[17];
          v162 = v2[2];
          v166 = v4;
          if ( v108 )
            v3[1783] = -1;
          goto LABEL_129;
        }
        v109 = *((_QWORD *)v3 + 11);
        v110 = 1 << *v13;
        v3[1783] = 0;
        v111 = *(_DWORD *)(v109 + 4i64 * (v9 & (v110 - 1)));
        if ( BYTE1(v111) > v10 )
        {
          do
          {
            if ( !v7 )
              goto LABEL_316;
            v112 = v10;
            v10 += 8;
            --v7;
            v9 += *v8++ << v112;
            v111 = *(_DWORD *)(*((_QWORD *)v3 + 11) + 4i64 * (v9 & ((1 << *v13) - 1)));
          }
          while ( (unsigned __int8)(*(_WORD *)(*((_QWORD *)v3 + 11) + 4i64 * (v9 & ((1 << *v13) - 1))) >> 8) > v10 );
        }
        if ( (_BYTE)v111 && !(v111 & 0xF0) )
        {
          v160 = v111;
          v113 = v111 >> 8;
          v114 = v111;
          v111 = *(_DWORD *)(v109 + 4i64 * ((v111 >> 16) + ((v9 & ((1 << (BYTE1(v111) + v111)) - 1)) >> SBYTE1(v111))));
          if ( (unsigned __int8)v113 + (unsigned int)BYTE1(v111) > v10 )
          {
            do
            {
              if ( !v7 )
                goto LABEL_316;
              v9 += *v8 << v10;
              v10 += 8;
              --v7;
              ++v8;
              v111 = *(_DWORD *)(*((_QWORD *)v3 + 11)
                               + 4i64 * (HIWORD(v160) + ((v9 & ((1 << (BYTE1(v160) + v114)) - 1)) >> SBYTE1(v160))));
            }
            while ( BYTE1(v160)
                  + (unsigned int)(unsigned __int8)(*(_WORD *)(*((_QWORD *)v3 + 11)
                                                             + 4i64
                                                             * (HIWORD(v160)
                                                              + ((v9 & ((1 << (BYTE1(v160) + v114)) - 1)) >> SBYTE1(v160)))) >> 8) > v10 );
          }
          v9 >>= SBYTE1(v160);
          v10 -= BYTE1(v160);
          v3[1783] = BYTE1(v160);
        }
        v3[1783] += BYTE1(v111);
        v9 >>= SBYTE1(v111);
        v10 -= BYTE1(v111);
        v3[18] = v111 >> 16;
        if ( !(_BYTE)v111 )
        {
          *v3 = 25;
          goto LABEL_127;
        }
        if ( v111 & 0x20 )
        {
          v3[1783] = -1;
          goto LABEL_126;
        }
        if ( v111 & 0x40 )
        {
          v2[4] = "invalid literal/length code";
          *v3 = 29;
          goto LABEL_127;
        }
        *v3 = 21;
        v3[20] = v111 & 0xF;
LABEL_244:
        v115 = v3[20];
        if ( v115 )
        {
          for ( ; v10 < v115; v9 += v117 )
          {
            if ( !v7 )
              goto LABEL_316;
            v116 = v10;
            v10 += 8;
            v117 = *v8 << v116;
            --v7;
            ++v8;
          }
          v10 -= v115;
          v118 = v9 & ((1 << v115) - 1);
          v9 >>= v115;
          v3[18] += v118;
          v3[1783] += v115;
        }
        v119 = v3[18];
        *v3 = 22;
        v12 = v3 + 27;
        v3[1784] = v119;
LABEL_250:
        v120 = *((_QWORD *)v3 + 12);
        v121 = *(_DWORD *)(v120 + 4i64 * (v9 & ((1 << *v12) - 1)));
        if ( (unsigned __int8)(*(_WORD *)(v120 + 4i64 * (v9 & ((1 << *v12) - 1))) >> 8) > v10 )
        {
          do
          {
            if ( !v7 )
              goto LABEL_316;
            v122 = v10;
            v10 += 8;
            --v7;
            v9 += *v8++ << v122;
            v121 = *(_DWORD *)(*((_QWORD *)v3 + 12) + 4i64 * (v9 & ((1 << *v12) - 1)));
          }
          while ( (unsigned __int8)(*(_WORD *)(*((_QWORD *)v3 + 12) + 4i64 * (v9 & ((1 << *v12) - 1))) >> 8) > v10 );
        }
        if ( !(v121 & 0xF0) )
        {
          v160 = v121;
          v123 = v121 >> 8;
          v124 = v121;
          v121 = *(_DWORD *)(v120 + 4i64 * ((v121 >> 16) + ((v9 & ((1 << (BYTE1(v121) + v121)) - 1)) >> SBYTE1(v121))));
          if ( (unsigned __int8)v123 + (unsigned int)BYTE1(v121) > v10 )
          {
            do
            {
              if ( !v7 )
                goto LABEL_316;
              v9 += *v8 << v10;
              v10 += 8;
              --v7;
              ++v8;
              v121 = *(_DWORD *)(*((_QWORD *)v3 + 12)
                               + 4i64 * (HIWORD(v160) + ((v9 & ((1 << (BYTE1(v160) + v124)) - 1)) >> SBYTE1(v160))));
            }
            while ( BYTE1(v160)
                  + (unsigned int)(unsigned __int8)(*(_WORD *)(*((_QWORD *)v3 + 12)
                                                             + 4i64
                                                             * (HIWORD(v160)
                                                              + ((v9 & ((1 << (BYTE1(v160) + v124)) - 1)) >> SBYTE1(v160)))) >> 8) > v10 );
          }
          v9 >>= SBYTE1(v160);
          v10 -= BYTE1(v160);
          v3[1783] += BYTE1(v160);
        }
        v6 = v162;
        v4 = v166;
        v3[1783] += BYTE1(v121);
        v9 >>= SBYTE1(v121);
        v10 -= BYTE1(v121);
        if ( v121 & 0x40 )
        {
          v2[4] = "invalid distance code";
          *v3 = 29;
          goto LABEL_129;
        }
        v11 = v159;
        *v3 = 23;
        v3[19] = v121 >> 16;
        v3[20] = v121 & 0xF;
LABEL_261:
        v125 = v3[20];
        if ( v125 )
        {
          for ( ; v10 < v125; v9 += v127 )
          {
            if ( !v7 )
              goto LABEL_316;
            v126 = v10;
            v10 += 8;
            v127 = *v8 << v126;
            --v7;
            ++v8;
          }
          v10 -= v125;
          v128 = v9 & ((1 << v125) - 1);
          v9 >>= v125;
          v3[19] += v128;
          v3[1783] += v125;
        }
        *v3 = 24;
LABEL_267:
        if ( !v4 )
        {
LABEL_316:
          v69 = v164;
          goto LABEL_317;
        }
        v129 = (unsigned int)v3[19];
        if ( (unsigned int)v129 <= v11 - v4 )
        {
          v133 = v3[18];
          v134 = (char *)&v6[-v129];
        }
        else
        {
          v130 = v129 - (v11 - v4);
          if ( v130 > v3[12] && v3[1782] )
          {
            v2[4] = "invalid distance too far back";
            *v3 = 29;
            goto LABEL_129;
          }
          v131 = v3[13];
          if ( v130 <= v131 )
          {
            v132 = v131 - v130;
          }
          else
          {
            v130 -= v131;
            v132 = v3[11] - v130;
          }
          v133 = v3[18];
          v134 = (char *)(*((_QWORD *)v3 + 7) + v132);
          if ( v130 <= v133 )
            goto LABEL_279;
        }
        v130 = v133;
LABEL_279:
        if ( v130 > v4 )
          v130 = v4;
        v4 -= v130;
        v135 = v134 - (char *)v6;
        v166 = v4;
        v3[18] = v133 - v130;
        do
        {
          v136 = (v6++)[v135];
          *(v6 - 1) = v136;
          --v130;
        }
        while ( v130 );
        v162 = v6;
        if ( !v3[18] )
          *v3 = 20;
        goto LABEL_129;
      case 17:
        goto LABEL_174;
      case 18:
        goto LABEL_185;
      case 19:
        goto LABEL_223;
      case 20:
        goto LABEL_224;
      case 21:
        goto LABEL_244;
      case 22:
        goto LABEL_250;
      case 23:
        goto LABEL_261;
      case 24:
        goto LABEL_267;
      case 25:
        if ( !v4 )
          goto LABEL_316;
        ++v6;
        --v4;
        *(v6 - 1) = *((_BYTE *)v3 + 72);
        v166 = v4;
        v162 = v6;
        *v3 = 20;
        goto LABEL_129;
      case 26:
        if ( !v3[2] )
          goto LABEL_301;
        if ( v10 >= 0x20 )
          goto LABEL_291;
        do
        {
          if ( !v7 )
            goto LABEL_316;
          v137 = v10;
          v10 += 8;
          v138 = *v8 << v137;
          --v7;
          ++v8;
          v9 += v138;
        }
        while ( v10 < 0x20 );
LABEL_291:
        v139 = v11 - v4;
        *((_DWORD *)v2 + 7) += v139;
        v3[7] += v139;
        if ( v139 )
        {
          v140 = v3[6];
          v141 = (char *)&v6[-v139];
          if ( v3[4] )
            v142 = sub_1400155F0(v140, v141, v139);
          else
            v142 = sub_140015E90(v140, (unsigned __int8 *)v141, v139);
          v6 = v162;
          v4 = v166;
          v3[6] = v142;
          *((_DWORD *)v2 + 19) = v142;
        }
        v108 = v3[4] == 0;
        v159 = v4;
        v143 = v9;
        if ( v108 )
          v143 = (v9 >> 24) + ((v9 >> 8) & 0xFF00) + (((v9 << 16) + (v9 & 0xFF00)) << 8);
        if ( v143 != v3[6] )
        {
          v2[4] = "incorrect data check";
          *v3 = 29;
          goto LABEL_129;
        }
        v9 = 0;
        v10 = 0;
LABEL_301:
        *v3 = 27;
LABEL_302:
        if ( !v3[2] || !v3[4] )
          goto LABEL_312;
        for ( ; v10 < 0x20; v9 += v145 )
        {
          if ( !v7 )
            goto LABEL_316;
          v144 = v10;
          v10 += 8;
          v145 = *v8 << v144;
          --v7;
          ++v8;
        }
        if ( v9 != v3[7] )
        {
          v2[4] = "incorrect length check";
          *v3 = 29;
          goto LABEL_129;
        }
        v9 = 0;
        v10 = 0;
LABEL_312:
        *v3 = 28;
LABEL_313:
        v69 = v164;
        v107 = 1;
        goto LABEL_318;
      case 27:
        goto LABEL_302;
      case 28:
        goto LABEL_313;
      case 29:
        v69 = v164;
        v107 = -3;
        goto LABEL_318;
      case 30:
        goto LABEL_325;
      default:
        return 4294967294i64;
    }
  }
}

//----- (0000000140014CE0) ----------------------------------------------------
signed __int64 __fastcall sub_140014CE0(__int64 a1, _QWORD *a2)
{
  if ( a1 && a2 && a2[5] && a2[6] && a2[7] )
    JUMPOUT(loc_140014D29);
  return 4294967294i64;
}

//----- (0000000140014F20) ----------------------------------------------------
signed __int64 __fastcall sub_140014F20(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rax
  void (__fastcall *v3)(_QWORD); // r8

  v1 = a1;
  if ( !a1 )
    return 4294967294i64;
  v2 = a1[5];
  if ( !v2 )
    return 4294967294i64;
  v3 = (void (__fastcall *)(_QWORD))a1[7];
  if ( !v3 )
    return 4294967294i64;
  if ( *(_QWORD *)(v2 + 56) )
    v3(a1[8]);
  ((void (__fastcall *)(_QWORD, _QWORD))v1[7])(v1[8], v1[5]);
  v1[5] = 0i64;
  return 0i64;
}

//----- (0000000140014F80) ----------------------------------------------------
signed __int64 __fastcall sub_140014F80(__int64 a1, char *a2, _DWORD *a3)
{
  _DWORD *v3; // rdi
  char *v4; // rsi
  __int64 v5; // rbx
  int v6; // eax

  v3 = a3;
  v4 = a2;
  if ( !a1 )
    return 4294967294i64;
  v5 = *(_QWORD *)(a1 + 40);
  if ( !v5 )
    return 4294967294i64;
  v6 = *(_DWORD *)(v5 + 48);
  if ( v6 && a2 )
  {
    memcpy(
      a2,
      (const void *)(*(_QWORD *)(v5 + 56) + *(unsigned int *)(v5 + 52)),
      (unsigned int)(v6 - *(_DWORD *)(v5 + 52)));
    memcpy(
      &v4[*(unsigned int *)(v5 + 48) - (unsigned __int64)*(unsigned int *)(v5 + 52)],
      *(const void **)(v5 + 56),
      *(unsigned int *)(v5 + 52));
  }
  if ( v3 )
    *v3 = *(_DWORD *)(v5 + 48);
  return 0i64;
}

//----- (0000000140015010) ----------------------------------------------------
signed __int64 __fastcall sub_140015010(_QWORD *a1, signed int a2, _BYTE *a3, int a4)
{
  signed int v4; // esi
  __int64 v5; // rbx
  __int64 v7; // rax
  __int64 v8; // rdi
  unsigned int v9; // esi

  v4 = a2;
  v5 = (__int64)a1;
  if ( !a3 || *a3 != 49 || a4 != 88 )
    return 4294967290i64;
  if ( !a1 )
    return 4294967294i64;
  a1[4] = 0i64;
  if ( !a1[6] )
  {
    a1[8] = 0i64;
    a1[6] = sub_140016B80;
  }
  if ( !a1[7] )
    a1[7] = sub_140016B90;
  v7 = ((__int64 (__fastcall *)(_QWORD, signed __int64, signed __int64))a1[6])(a1[8], 1i64, 7144i64);
  v8 = v7;
  if ( !v7 )
    return 4294967292i64;
  *(_QWORD *)(v5 + 40) = v7;
  *(_QWORD *)(v7 + 56) = 0i64;
  v9 = sub_140015110(v5, v4);
  if ( v9 )
  {
    (*(void (__fastcall **)(_QWORD, __int64))(v5 + 56))(*(_QWORD *)(v5 + 64), v8);
    *(_QWORD *)(v5 + 40) = 0i64;
  }
  return v9;
}
// 140016B90: using guessed type __int64 __fastcall sub_140016B90();

//----- (0000000140015100) ----------------------------------------------------
signed __int64 __fastcall sub_140015100(_QWORD *a1, _BYTE *a2, int a3)
{
  return sub_140015010(a1, 15, a2, a3);
}

//----- (0000000140015110) ----------------------------------------------------
signed __int64 __fastcall sub_140015110(__int64 a1, signed int a2)
{
  int v2; // ebx
  __int64 v3; // rdi
  __int64 v4; // rsi
  int v5; // ebp
  __int64 v6; // rax

  v2 = a2;
  v3 = a1;
  if ( !a1 )
    return 4294967294i64;
  v4 = *(_QWORD *)(a1 + 40);
  if ( !v4 )
    return 4294967294i64;
  if ( a2 >= 0 )
  {
    v5 = (a2 >> 4) + 1;
    if ( a2 < 48 )
      v2 = a2 & 0xF;
  }
  else
  {
    v5 = 0;
    v2 = -a2;
  }
  if ( v2 && (unsigned int)(v2 - 8) > 7 )
    return 4294967294i64;
  if ( *(_QWORD *)(v4 + 56) )
  {
    if ( *(_DWORD *)(v4 + 40) != v2 )
    {
      (*(void (__fastcall **)(_QWORD))(a1 + 56))(*(_QWORD *)(a1 + 64));
      *(_QWORD *)(v4 + 56) = 0i64;
    }
  }
  *(_DWORD *)(v4 + 8) = v5;
  *(_DWORD *)(v4 + 40) = v2;
  v6 = *(_QWORD *)(v3 + 40);
  if ( !v6 )
    return 4294967294i64;
  *(_QWORD *)(v6 + 44) = 0i64;
  *(_DWORD *)(v6 + 52) = 0;
  return sub_1400151E0(v3);
}

//----- (00000001400151E0) ----------------------------------------------------
signed __int64 __fastcall sub_1400151E0(__int64 a1)
{
  __int64 v1; // rdx
  int v2; // eax
  signed __int64 result; // rax

  if ( !a1 )
    return 4294967294i64;
  v1 = *(_QWORD *)(a1 + 40);
  if ( !v1 )
    return 4294967294i64;
  *(_DWORD *)(v1 + 28) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_QWORD *)(a1 + 32) = 0i64;
  v2 = *(_DWORD *)(v1 + 8);
  if ( v2 )
    *(_DWORD *)(a1 + 76) = *(_DWORD *)(v1 + 8) & 1;
  *(_QWORD *)v1 = 0i64;
  *(_DWORD *)(v1 + 12) = 0;
  *(_QWORD *)(v1 + 128) = v1 + 1352;
  *(_QWORD *)(v1 + 96) = v1 + 1352;
  *(_QWORD *)(v1 + 88) = v1 + 1352;
  result = 0i64;
  *(_DWORD *)(v1 + 20) = 0x8000;
  *(_QWORD *)(v1 + 32) = 0i64;
  *(_QWORD *)(v1 + 64) = 0i64;
  *(_DWORD *)(v1 + 7128) = 1;
  *(_DWORD *)(v1 + 7132) = -1;
  return result;
}

//----- (0000000140015260) ----------------------------------------------------
signed __int64 __fastcall sub_140015260(__int64 a1, unsigned __int8 *a2, unsigned int a3)
{
  __int64 v3; // rsi
  unsigned __int8 *v4; // rbp
  __int64 v5; // rdi
  _DWORD *v6; // rbx
  signed __int64 result; // rax
  unsigned int v8; // eax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( !a1 )
    return 4294967294i64;
  v6 = *(_DWORD **)(a1 + 40);
  if ( !v6 )
    return 4294967294i64;
  if ( v6[2] )
  {
    if ( *v6 != 10 )
      return 4294967294i64;
  }
  else if ( *v6 != 10 )
  {
    goto LABEL_10;
  }
  v8 = sub_140015E90(0, 0i64, 0);
  if ( (unsigned int)sub_140015E90(v8, v4, v3) != v6[6] )
    return 4294967293i64;
LABEL_10:
  if ( (unsigned int)sub_1400154F0(v5, (__int64)&v4[v3], v3) )
  {
    *v6 = 30;
    result = 4294967292i64;
  }
  else
  {
    v6[3] = 1;
    result = 0i64;
  }
  return result;
}

//----- (0000000140015310) ----------------------------------------------------
signed __int64 __fastcall sub_140015310(__int64 a1)
{
  __int64 v1; // rsi
  _DWORD *v2; // rdi
  signed __int64 result; // rax
  int v4; // edx
  unsigned int v5; // er9
  int v6; // ecx
  unsigned int v7; // edx
  unsigned int v8; // er8
  __int64 v9; // rcx
  unsigned int v10; // ecx
  unsigned int v11; // edx
  char *v12; // r10
  int v13; // er8
  signed int v14; // eax
  unsigned int v15; // eax
  int v16; // ebp
  __int64 v17; // rax
  int v18; // ebx
  char v19[8]; // [rsp+40h] [rbp+8h]

  v1 = a1;
  if ( !a1 )
    return 4294967294i64;
  v2 = *(_DWORD **)(a1 + 40);
  if ( !v2 )
    return 4294967294i64;
  if ( !*(_DWORD *)(a1 + 8) && v2[17] < 8u )
    return 4294967291i64;
  if ( *v2 != 31 )
  {
    v4 = v2[17];
    *v2 = 31;
    v5 = 0;
    v6 = v4 & 7;
    v2[16] <<= v6;
    v7 = v4 - v6;
    v2[17] = v7;
    if ( v7 >= 8 )
    {
      v8 = v2[16];
      do
      {
        v9 = v5;
        v8 >>= 8;
        v7 -= 8;
        ++v5;
        v19[v9] = *((_BYTE *)v2 + 64);
        v2[16] = v8;
      }
      while ( v7 >= 8 );
      v2[17] = v7;
    }
    v2[31] = 0;
    v10 = 0;
    v11 = 0;
    if ( v5 )
    {
      v12 = v19;
      do
      {
        if ( v10 >= 4 )
          break;
        v13 = (unsigned __int8)*v12;
        v14 = 255;
        if ( v10 < 2 )
          v14 = 0;
        if ( v13 == v14 )
          ++v10;
        else
          v10 = (_BYTE)v13 ? 0 : 4 - v10;
        ++v11;
        ++v12;
      }
      while ( v11 < v5 );
    }
    v2[31] = v10;
  }
  v15 = sub_140015480(v2 + 31, *(unsigned __int8 **)v1, *(_DWORD *)(v1 + 8));
  *(_DWORD *)(v1 + 12) += v15;
  *(_DWORD *)(v1 + 8) -= v15;
  v16 = *(_DWORD *)(v1 + 12);
  *(_QWORD *)v1 += v15;
  if ( v2[31] != 4 )
    return 4294967293i64;
  v17 = *(_QWORD *)(v1 + 40);
  v18 = *(_DWORD *)(v1 + 28);
  if ( v17 )
  {
    *(_QWORD *)(v17 + 44) = 0i64;
    *(_DWORD *)(v17 + 52) = 0;
    sub_1400151E0(v1);
  }
  *(_DWORD *)(v1 + 12) = v16;
  *(_DWORD *)(v1 + 28) = v18;
  result = 0i64;
  *v2 = 11;
  return result;
}
// 140015310: using guessed type char arg_0[8];

//----- (0000000140015480) ----------------------------------------------------
__int64 __fastcall sub_140015480(unsigned int *a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v3; // eax
  unsigned int v4; // er11
  unsigned int *v5; // r10
  unsigned int v6; // er9
  int v7; // er8
  signed int v8; // ecx
  __int64 result; // rax

  v3 = *a1;
  v4 = a3;
  v5 = a1;
  v6 = 0;
  if ( a3 )
  {
    do
    {
      if ( v3 >= 4 )
        break;
      v7 = *a2;
      v8 = 255;
      if ( v3 < 2 )
        v8 = 0;
      if ( v7 == v8 )
        ++v3;
      else
        v3 = (_BYTE)v7 ? 0 : 4 - v3;
      ++v6;
      ++a2;
    }
    while ( v6 < v4 );
    *v5 = v3;
    result = v6;
  }
  else
  {
    *a1 = v3;
    result = 0i64;
  }
  return result;
}

//----- (00000001400154F0) ----------------------------------------------------
signed __int64 __fastcall sub_1400154F0(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // rbx
  __int64 v4; // rbp
  __int64 v5; // rsi
  __int64 v6; // rax
  int v8; // ecx
  __int64 v9; // rdi
  int v10; // eax
  unsigned int v11; // edi
  unsigned int v12; // ebp
  int v13; // eax
  unsigned int v14; // eax

  v3 = *(_QWORD *)(a1 + 40);
  v4 = a3;
  v5 = a2;
  if ( !*(_QWORD *)(v3 + 56) )
  {
    v6 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, signed __int64))(a1 + 48))(
           *(_QWORD *)(a1 + 64),
           (unsigned int)(1 << *(_DWORD *)(v3 + 40)),
           1i64);
    *(_QWORD *)(v3 + 56) = v6;
    if ( !v6 )
      return 1i64;
  }
  if ( !*(_DWORD *)(v3 + 44) )
  {
    v8 = *(_DWORD *)(v3 + 40);
    *(_QWORD *)(v3 + 48) = 0i64;
    *(_DWORD *)(v3 + 44) = 1 << v8;
  }
  v9 = *(unsigned int *)(v3 + 44);
  if ( (unsigned int)v4 < (unsigned int)v9 )
  {
    v11 = v9 - *(_DWORD *)(v3 + 52);
    if ( v11 > (unsigned int)v4 )
      v11 = v4;
    memcpy((void *)(*(_QWORD *)(v3 + 56) + *(unsigned int *)(v3 + 52)), (const void *)(v5 - v4), v11);
    v12 = v4 - v11;
    if ( v12 )
    {
      memcpy(*(void **)(v3 + 56), (const void *)(v5 - v12), v12);
      v10 = *(_DWORD *)(v3 + 44);
      *(_DWORD *)(v3 + 52) = v12;
    }
    else
    {
      *(_DWORD *)(v3 + 52) += v11;
      v13 = *(_DWORD *)(v3 + 52);
      if ( v13 == *(_DWORD *)(v3 + 44) )
        v13 = 0;
      *(_DWORD *)(v3 + 52) = v13;
      v14 = *(_DWORD *)(v3 + 48);
      if ( v14 >= *(_DWORD *)(v3 + 44) )
        return 0i64;
      v10 = v11 + v14;
    }
  }
  else
  {
    memcpy(*(void **)(v3 + 56), (const void *)(v5 - v9), (unsigned int)v9);
    v10 = *(_DWORD *)(v3 + 44);
    *(_DWORD *)(v3 + 52) = 0;
  }
  *(_DWORD *)(v3 + 48) = v10;
  return 0i64;
}

//----- (00000001400155F0) ----------------------------------------------------
__int64 __fastcall sub_1400155F0(int a1, char *a2, unsigned int a3)
{
  __int64 result; // rax

  if ( a2 )
    result = sub_140015B30(a1, a2, a3);
  else
    result = 0i64;
  return result;
}

//----- (0000000140015600) ----------------------------------------------------
__int64 __fastcall sub_140015600(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v3; // er10
  unsigned __int8 *v4; // r8
  unsigned int i; // eax
  __int64 v6; // rcx
  signed __int64 v7; // r11
  unsigned __int64 v8; // r9
  unsigned int v9; // eax
  unsigned __int8 *j; // r11
  __int64 v11; // rcx

  v3 = a3;
  v4 = a2;
  for ( i = ~((a1 >> 24) + ((a1 >> 8) & 0xFF00) + (((a1 << 16) + (a1 & 0xFF00)) << 8)); v3; --v3 )
  {
    if ( !((unsigned __int8)v4 & 3) )
      break;
    v6 = *v4++;
    i = (i << 8) ^ dword_14001A980[(v6 ^ ((unsigned __int64)i >> 24)) + 1024];
  }
  v7 = (signed __int64)(v4 - 4);
  if ( v3 >= 0x20 )
    JUMPOUT(loc_140015677);
  if ( v3 >= 4 )
  {
    v8 = (unsigned __int64)v3 >> 2;
    do
    {
      v9 = *(_DWORD *)(v7 + 4) ^ i;
      v7 += 4i64;
      v3 -= 4;
      i = dword_14001A980[(unsigned __int8)v9 + 1024] ^ dword_14001A980[((unsigned __int64)v9 >> 24) + 1792] ^ dword_14001A980[BYTE1(v9) + 1280] ^ dword_14001A980[BYTE2(v9) + 1536];
      --v8;
    }
    while ( v8 );
  }
  for ( j = (unsigned __int8 *)(v7 + 4); v3; --v3 )
  {
    v11 = *j++;
    i = (i << 8) ^ dword_14001A980[(v11 ^ ((unsigned __int64)i >> 24)) + 1024];
  }
  return ((~i >> 8) & 0xFF00) + (((~i << 16) + (~(_WORD)i & 0xFF00)) << 8) + (~i >> 24);
}

//----- (0000000140015990) ----------------------------------------------------
__int64 __fastcall sub_140015990(unsigned int a1, int a2, __int64 a3)
{
  __int64 v3; // r10
  int v4; // er11
  unsigned int v5; // er9
  int v6; // ecx
  signed __int64 v7; // rax
  signed __int64 v8; // r8
  unsigned int v9; // eax
  int v10; // edx
  int *i; // rcx
  signed __int64 v12; // r8
  unsigned int v13; // eax
  int v14; // edx
  int *j; // rcx
  signed __int64 v16; // r8
  unsigned int v17; // eax
  int v18; // edx
  int *k; // rcx
  unsigned int v20; // ecx
  int *l; // rax
  __int64 v22; // r10
  signed __int64 v23; // r8
  unsigned int v24; // eax
  int v25; // edx
  int *m; // rcx
  unsigned int v27; // ecx
  int *n; // rax
  int v30[32]; // [rsp+0h] [rbp-108h]
  int v31[34]; // [rsp+80h] [rbp-88h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a3 > 0 )
  {
    v6 = 1;
    v30[0] = -306674912;
    v7 = 1i64;
    do
    {
      v30[v7++] = v6;
      v6 *= 2;
    }
    while ( v7 < 32 );
    v8 = 0i64;
    do
    {
      v9 = v30[v8];
      v10 = 0;
      for ( i = v30; v9; v9 >>= 1 )
      {
        if ( v9 & 1 )
          v10 ^= *i;
        ++i;
      }
      v31[v8] = v10;
      ++v8;
    }
    while ( v8 < 32 );
    v12 = 0i64;
    do
    {
      v13 = v31[v12];
      v14 = 0;
      for ( j = v31; v13; v13 >>= 1 )
      {
        if ( v13 & 1 )
          v14 ^= *j;
        ++j;
      }
      v30[v12] = v14;
      ++v12;
    }
    while ( v12 < 32 );
    do
    {
      v16 = 0i64;
      do
      {
        v17 = v30[v16];
        v18 = 0;
        for ( k = v30; v17; v17 >>= 1 )
        {
          if ( v17 & 1 )
            v18 ^= *k;
          ++k;
        }
        v31[v16] = v18;
        ++v16;
      }
      while ( v16 < 32 );
      if ( v3 & 1 )
      {
        v20 = 0;
        for ( l = v31; v5; v5 >>= 1 )
        {
          if ( v5 & 1 )
            v20 ^= *l;
          ++l;
        }
        v5 = v20;
      }
      v22 = v3 >> 1;
      if ( !v22 )
        break;
      v23 = 0i64;
      do
      {
        v24 = v31[v23];
        v25 = 0;
        for ( m = v31; v24; v24 >>= 1 )
        {
          if ( v24 & 1 )
            v25 ^= *m;
          ++m;
        }
        v30[v23] = v25;
        ++v23;
      }
      while ( v23 < 32 );
      if ( v22 & 1 )
      {
        v27 = 0;
        for ( n = v30; v5; v5 >>= 1 )
        {
          if ( v5 & 1 )
            v27 ^= *n;
          ++n;
        }
        v5 = v27;
      }
      v3 = v22 >> 1;
    }
    while ( v3 );
    v5 ^= v4;
  }
  return v5;
}
// 140015990: using guessed type int var_108[32];
// 140015990: using guessed type int var_88[34];

//----- (0000000140015B30) ----------------------------------------------------
__int64 __fastcall sub_140015B30(int a1, char *a2, unsigned int a3)
{
  unsigned int v3; // er11
  char *v4; // r10
  unsigned int i; // ecx
  char v6; // dl
  unsigned __int64 v7; // rbx
  unsigned int v8; // ecx
  unsigned int v9; // er8
  unsigned int v10; // er8
  unsigned int v11; // er8
  unsigned int v12; // er8
  unsigned int v13; // er8
  unsigned int v14; // er8
  unsigned int v15; // er8
  unsigned __int64 v16; // r9
  unsigned int v17; // ecx
  char v18; // dl

  v3 = a3;
  v4 = a2;
  for ( i = ~a1; v3; --v3 )
  {
    if ( !((unsigned __int8)v4 & 3) )
      break;
    v6 = *v4++;
    i = (i >> 8) ^ dword_14001A980[(unsigned __int8)(i ^ v6)];
  }
  if ( v3 >= 0x20 )
  {
    v7 = (unsigned __int64)v3 >> 5;
    do
    {
      v8 = *(_DWORD *)v4 ^ i;
      v9 = *((_DWORD *)v4 + 1) ^ dword_14001A980[(unsigned __int8)v8 + 768] ^ dword_14001A980[(unsigned __int64)v8 >> 24] ^ dword_14001A980[BYTE1(v8) + 512] ^ dword_14001A980[BYTE2(v8) + 256];
      v10 = *((_DWORD *)v4 + 2) ^ dword_14001A980[(unsigned __int8)v9 + 768] ^ dword_14001A980[(unsigned __int64)v9 >> 24] ^ dword_14001A980[((unsigned __int16)(*((_WORD *)v4 + 2) ^ LOWORD(dword_14001A980[(unsigned __int8)v8 + 768]) ^ LOWORD(dword_14001A980[(unsigned __int64)v8 >> 24]) ^ LOWORD(dword_14001A980[BYTE1(v8) + 512]) ^ LOWORD(dword_14001A980[BYTE2(v8) + 256])) >> 8) + 512] ^ dword_14001A980[BYTE2(v9) + 256];
      v11 = *((_DWORD *)v4 + 3) ^ dword_14001A980[(unsigned __int8)v10 + 768] ^ dword_14001A980[(unsigned __int64)v10 >> 24] ^ dword_14001A980[BYTE1(v10) + 512] ^ dword_14001A980[BYTE2(v10) + 256];
      v12 = *((_DWORD *)v4 + 4) ^ dword_14001A980[(unsigned __int8)v11 + 768] ^ dword_14001A980[(unsigned __int64)v11 >> 24] ^ dword_14001A980[BYTE1(v11) + 512] ^ dword_14001A980[BYTE2(v11) + 256];
      v13 = *((_DWORD *)v4 + 5) ^ dword_14001A980[(unsigned __int8)v12 + 768] ^ dword_14001A980[(unsigned __int64)v12 >> 24] ^ dword_14001A980[BYTE1(v12) + 512] ^ dword_14001A980[BYTE2(v12) + 256];
      v4 += 32;
      v3 -= 32;
      v14 = *((_DWORD *)v4 - 2) ^ dword_14001A980[(unsigned __int8)v13 + 768] ^ dword_14001A980[(unsigned __int64)v13 >> 24] ^ dword_14001A980[BYTE1(v13) + 512] ^ dword_14001A980[BYTE2(v13) + 256];
      v15 = *((_DWORD *)v4 - 1) ^ dword_14001A980[(unsigned __int8)v14 + 768] ^ dword_14001A980[(unsigned __int64)v14 >> 24] ^ dword_14001A980[BYTE1(v14) + 512] ^ dword_14001A980[BYTE2(v14) + 256];
      i = dword_14001A980[(unsigned __int8)v15 + 768] ^ dword_14001A980[(unsigned __int64)v15 >> 24] ^ dword_14001A980[BYTE1(v15) + 512] ^ dword_14001A980[BYTE2(v15) + 256];
      --v7;
    }
    while ( v7 );
  }
  if ( v3 >= 4 )
  {
    v16 = (unsigned __int64)v3 >> 2;
    do
    {
      v17 = *(_DWORD *)v4 ^ i;
      v4 += 4;
      v3 -= 4;
      i = dword_14001A980[(unsigned __int8)v17 + 768] ^ dword_14001A980[(unsigned __int64)v17 >> 24] ^ dword_14001A980[BYTE1(v17) + 512] ^ dword_14001A980[BYTE2(v17) + 256];
      --v16;
    }
    while ( v16 );
  }
  for ( ; v3; --v3 )
  {
    v18 = *v4++;
    i = (i >> 8) ^ dword_14001A980[(unsigned __int8)(i ^ v18)];
  }
  return ~i;
}

//----- (0000000140015E90) ----------------------------------------------------
signed __int64 __fastcall sub_140015E90(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v3; // er9
  unsigned __int8 *v4; // r10
  unsigned int v5; // er9
  int v7; // eax
  __int64 v8; // r11
  signed int v9; // edx
  int v10; // eax
  int v11; // ecx
  int v12; // er9
  int v13; // ecx
  int v14; // er9
  int v15; // ecx
  int v16; // er9
  int v17; // ecx
  int v18; // er9
  int v19; // ecx
  int v20; // er9
  int v21; // ecx
  int v22; // er9
  int v23; // ecx
  int v24; // er9
  int v25; // ecx
  int v26; // er9
  int v27; // ecx
  int v28; // er9
  int v29; // ecx
  int v30; // er9
  int v31; // ecx
  int v32; // er9
  int v33; // ecx
  int v34; // er9
  int v35; // ecx
  int v36; // er9
  int v37; // ecx
  int v38; // er9
  int v39; // ecx
  int v40; // er9
  unsigned __int64 v41; // rdx
  int v42; // eax
  int v43; // ecx
  int v44; // er9
  int v45; // ecx
  int v46; // er9
  int v47; // ecx
  int v48; // er9
  int v49; // ecx
  int v50; // er9
  int v51; // ecx
  int v52; // er9
  int v53; // ecx
  int v54; // er9
  int v55; // ecx
  int v56; // er9
  int v57; // ecx
  int v58; // er9
  int v59; // ecx
  int v60; // er9
  int v61; // ecx
  int v62; // er9
  int v63; // ecx
  int v64; // er9
  int v65; // ecx
  int v66; // er9
  int v67; // ecx
  int v68; // er9
  int v69; // ecx
  int v70; // er9
  int v71; // ecx
  int v72; // er9
  int v73; // eax

  v3 = a1;
  v4 = a2;
  a1 = (unsigned __int16)a1;
  v5 = v3 >> 16;
  if ( a3 == 1 )
  {
    a1 += *a2;
    if ( a1 >= 0xFFF1 )
      a1 -= 65521;
    v5 += a1;
    if ( v5 >= 0xFFF1 )
      return a1 | ((v5 - 65521) << 16);
    return a1 | (v5 << 16);
  }
  if ( !a2 )
    return 1i64;
  if ( a3 >= 0x10 )
  {
    if ( a3 >= 0x15B0 )
    {
      v8 = a3 / 0x15B0;
      do
      {
        a3 -= 5552;
        v9 = 347;
        do
        {
          v10 = *v4;
          v4 += 16;
          v11 = v10 + a1;
          v12 = v11 + v5;
          v13 = *(v4 - 15) + v11;
          v14 = v13 + v12;
          v15 = *(v4 - 14) + v13;
          v16 = v15 + v14;
          v17 = *(v4 - 13) + v15;
          v18 = v17 + v16;
          v19 = *(v4 - 12) + v17;
          v20 = v19 + v18;
          v21 = *(v4 - 11) + v19;
          v22 = v21 + v20;
          v23 = *(v4 - 10) + v21;
          v24 = v23 + v22;
          v25 = *(v4 - 9) + v23;
          v26 = v25 + v24;
          v27 = *(v4 - 8) + v25;
          v28 = v27 + v26;
          v29 = *(v4 - 7) + v27;
          v30 = v29 + v28;
          v31 = *(v4 - 6) + v29;
          v32 = v31 + v30;
          v33 = *(v4 - 5) + v31;
          v34 = v33 + v32;
          v35 = *(v4 - 4) + v33;
          v36 = v35 + v34;
          v37 = *(v4 - 3) + v35;
          v38 = v37 + v36;
          v39 = *(v4 - 2) + v37;
          v40 = v39 + v38;
          a1 = *(v4 - 1) + v39;
          v5 = a1 + v40;
          --v9;
        }
        while ( v9 );
        a1 %= 0xFFF1u;
        v5 %= 0xFFF1u;
        --v8;
      }
      while ( v8 );
    }
    if ( a3 )
    {
      if ( a3 >= 0x10 )
      {
        v41 = (unsigned __int64)a3 >> 4;
        do
        {
          v42 = *v4;
          a3 -= 16;
          v4 += 16;
          v43 = v42 + a1;
          v44 = v43 + v5;
          v45 = *(v4 - 15) + v43;
          v46 = v45 + v44;
          v47 = *(v4 - 14) + v45;
          v48 = v47 + v46;
          v49 = *(v4 - 13) + v47;
          v50 = v49 + v48;
          v51 = *(v4 - 12) + v49;
          v52 = v51 + v50;
          v53 = *(v4 - 11) + v51;
          v54 = v53 + v52;
          v55 = *(v4 - 10) + v53;
          v56 = v55 + v54;
          v57 = *(v4 - 9) + v55;
          v58 = v57 + v56;
          v59 = *(v4 - 8) + v57;
          v60 = v59 + v58;
          v61 = *(v4 - 7) + v59;
          v62 = v61 + v60;
          v63 = *(v4 - 6) + v61;
          v64 = v63 + v62;
          v65 = *(v4 - 5) + v63;
          v66 = v65 + v64;
          v67 = *(v4 - 4) + v65;
          v68 = v67 + v66;
          v69 = *(v4 - 3) + v67;
          v70 = v69 + v68;
          v71 = *(v4 - 2) + v69;
          v72 = v71 + v70;
          a1 = *(v4 - 1) + v71;
          v5 = a1 + v72;
          --v41;
        }
        while ( v41 );
      }
      for ( ; a3; --a3 )
      {
        v73 = *v4++;
        a1 += v73;
        v5 += a1;
      }
      a1 %= 0xFFF1u;
      v5 %= 0xFFF1u;
    }
    return a1 | (v5 << 16);
  }
  for ( ; a3; --a3 )
  {
    v7 = *v4++;
    a1 += v7;
    v5 += a1;
  }
  if ( a1 >= 0xFFF1 )
    a1 -= 65521;
  return a1 | ((v5 + 15 * (v5 / 0xFFF1)) << 16);
}

//----- (0000000140016170) ----------------------------------------------------
signed __int64 __fastcall sub_140016170(unsigned int a1, unsigned int a2, __int64 a3)
{
  unsigned int v3; // ebx
  unsigned __int64 v5; // rdx
  unsigned int v6; // er9
  int v7; // er10
  unsigned int v8; // eax

  v3 = a2;
  if ( a3 < 0 )
    return 0xFFFFFFFFi64;
  v5 = (signed __int64)(a3 + ((unsigned __int128)(a3 * (signed __int128)-9221260491235007769i64) >> 64)) >> 15;
  v6 = (unsigned __int16)a1 + (unsigned __int16)v3 + 65520;
  v7 = a3 - 65521 * ((v5 >> 63) + v5);
  v8 = v7 * (unsigned __int16)a1
     + (v3 >> 16)
     + (a1 >> 16)
     - 65521 * (v7 * (unsigned int)(unsigned __int16)a1 / 0xFFF1)
     - v7
     + 65521;
  if ( v6 >= 0xFFF1 )
  {
    v6 -= 65521;
    if ( v6 >= 0xFFF1 )
      v6 -= 65521;
  }
  if ( v8 >= 0x1FFE2 )
    v8 -= 131042;
  if ( v8 >= 0xFFF1 )
    v8 -= 65521;
  return v6 | (v8 << 16);
}

//----- (0000000140016240) ----------------------------------------------------
signed __int64 __fastcall sub_140016240(int a1, unsigned __int16 *a2, __int64 a3, _QWORD *a4, unsigned int *a5, char *a6)
{
  int v6; // esi
  __int16 *v7; // rdi
  signed __int64 v8; // rcx
  _DWORD **v9; // r15
  unsigned int v10; // er11
  _WORD *v11; // rbx
  unsigned __int16 *v12; // rdi
  __int64 v13; // rax
  unsigned int v14; // er9
  int v15; // er14
  unsigned int v16; // er8
  unsigned int v18; // er10
  __int16 *v19; // rax
  int v20; // edi
  unsigned int v21; // edx
  __int64 v22; // rcx
  signed __int64 v23; // rdx
  __int16 v24; // ax
  unsigned int v25; // edi
  _WORD *v26; // rdx
  char *v27; // rdi
  signed int v28; // er12
  _DWORD *v29; // rbx
  signed __int64 v30; // rdx
  unsigned int v31; // er11
  __int64 v32; // rsi
  unsigned int v33; // er13
  bool v34; // cf
  bool v35; // zf
  __int64 v36; // rcx
  __int64 v37; // rcx
  signed __int64 v38; // rcx
  __int16 v39; // ax
  int v40; // edi
  signed int v41; // er8
  unsigned int i; // edx
  __int64 v43; // rbx
  char v44; // r8
  __int64 v45; // rdi
  signed int v46; // eax
  int v47; // eax
  bool v48; // cf
  bool v49; // zf
  int v50; // [rsp+0h] [rbp-80h]
  int v51; // [rsp+4h] [rbp-7Ch]
  unsigned int v52; // [rsp+8h] [rbp-78h]
  _DWORD *v53; // [rsp+10h] [rbp-70h]
  char *v54; // [rsp+18h] [rbp-68h]
  int v55; // [rsp+20h] [rbp-60h]
  char *v56; // [rsp+28h] [rbp-58h]
  __int16 v57; // [rsp+30h] [rbp-50h]
  __int16 v58[15]; // [rsp+32h] [rbp-4Eh]
  __int16 v59; // [rsp+50h] [rbp-30h]
  __int16 v60[19]; // [rsp+52h] [rbp-2Eh]
  int v61; // [rsp+C0h] [rbp+40h]
  unsigned __int16 *v62; // [rsp+C8h] [rbp+48h]
  int v63; // [rsp+D0h] [rbp+50h]
  __int64 v64; // [rsp+D0h] [rbp+50h]
  _QWORD *v65; // [rsp+D8h] [rbp+58h]

  v65 = a4;
  v62 = a2;
  v61 = a1;
  v6 = a1;
  v7 = &v57;
  v8 = 16i64;
  v9 = (_DWORD **)a4;
  v10 = a3;
  v11 = a2;
  while ( v8 )
  {
    *v7 = 0;
    ++v7;
    --v8;
  }
  if ( (_DWORD)a3 )
  {
    v12 = a2;
    a3 = (unsigned int)a3;
    do
    {
      v13 = *v12;
      ++v12;
      ++*(&v57 + v13);
      --a3;
    }
    while ( a3 );
  }
  v14 = 15;
  v15 = -1;
  v16 = *a5;
  do
  {
    if ( *(&v57 + v14) )
      break;
    --v14;
  }
  while ( v14 >= 1 );
  if ( v16 > v14 )
    v16 = v14;
  if ( !v14 )
  {
    **v9 = 320;
    ++*v9;
    **v9 = 320;
    ++*v9;
    *a5 = 1;
    return 0i64;
  }
  v18 = 1;
  if ( v14 > 1 )
  {
    v19 = v58;
    do
    {
      if ( *v19 )
        break;
      ++v18;
      ++v19;
    }
    while ( v18 < v14 );
  }
  v20 = 1;
  if ( v16 < v18 )
    v16 = v18;
  v21 = 1;
  v52 = v16;
  do
  {
    v20 = 2 * v20 - (unsigned __int16)*(&v57 + v21);
    if ( v20 < 0 )
      return 0xFFFFFFFFi64;
    ++v21;
  }
  while ( v21 <= 0xF );
  if ( v20 > 0 && (!v6 || v14 != 1) )
    return 0xFFFFFFFFi64;
  v60[0] = 0;
  v22 = 0i64;
  v23 = 14i64;
  do
  {
    v24 = v58[v22];
    ++v22;
    v60[v22] = *(__int16 *)((char *)&v59 + v22 * 2) + v24;
    --v23;
  }
  while ( v23 );
  v25 = 0;
  if ( v10 )
  {
    v26 = v11;
    do
    {
      if ( *v26 )
        *(_WORD *)&a6[2 * (unsigned __int16)(*(&v59 + (unsigned __int16)*v26))++] = v25;
      ++v25;
      ++v26;
    }
    while ( v25 < v10 );
  }
  v27 = a6;
  if ( v6 )
  {
    if ( v6 == 1 )
    {
      v28 = 256;
      v54 = (char *)&unk_14001C9B0 - 514;
      v56 = (char *)&unk_14001C9F0 - 514;
    }
    else
    {
      v28 = -1;
      v54 = (char *)&unk_14001CA30;
      v56 = (char *)&unk_14001CA70;
    }
  }
  else
  {
    v56 = a6;
    v54 = a6;
    v28 = 19;
  }
  v29 = *v9;
  LOBYTE(v30) = 0;
  v31 = 0;
  v32 = (unsigned int)(1 << v16);
  v51 = 0;
  v53 = *v9;
  v50 = 0;
  v33 = 1 << v16;
  v55 = v32 - 1;
  if ( v61 == 1 )
  {
    v34 = (unsigned int)v32 < 0x354;
    v35 = (_DWORD)v32 == 852;
    goto LABEL_42;
  }
  if ( v61 == 2 )
  {
    v34 = (unsigned int)v32 < 0x250;
    v35 = (_DWORD)v32 == 592;
LABEL_42:
    if ( !v34 && !v35 )
      return 1i64;
  }
  LODWORD(v36) = 0;
  while ( 1 )
  {
    BYTE1(v63) = v18 - v30;
    v37 = *(unsigned __int16 *)&v27[2 * (unsigned int)v36];
    if ( (signed int)v37 >= v28 )
    {
      if ( (signed int)v37 <= v28 )
      {
        LOBYTE(v63) = 96;
        v39 = 0;
      }
      else
      {
        v38 = 2 * v37;
        LOBYTE(v63) = v56[v38];
        v39 = *(_WORD *)&v54[v38];
      }
      HIWORD(v63) = v39;
    }
    else
    {
      LOBYTE(v63) = 0;
      HIWORD(v63) = v37;
    }
    v40 = v32;
    v41 = 1 << (v18 - v30);
    LODWORD(v30) = v32 + (v31 >> v50);
    do
    {
      v30 = (unsigned int)(v30 - v41);
      v29[v30] = v63;
      v40 -= v41;
    }
    while ( v40 );
    for ( i = 1 << (v18 - 1); i & v31; i >>= 1 )
      ;
    if ( i )
      v31 = i + ((i - 1) & v31);
    else
      v31 = 0;
    v36 = (unsigned int)(v51 + 1);
    v35 = (*(&v57 + v18))-- == 1;
    ++v51;
    if ( !v35 )
    {
      v27 = a6;
      goto LABEL_62;
    }
    if ( v18 == v14 )
      break;
    v27 = a6;
    v18 = v62[*(unsigned __int16 *)&a6[2 * v36]];
    LODWORD(v36) = v51;
LABEL_62:
    LODWORD(v30) = v50;
    if ( v18 > v52 )
    {
      v43 = v31 & v55;
      if ( (_DWORD)v43 == v15 )
      {
        v29 = v53;
      }
      else
      {
        if ( !v50 )
          LODWORD(v30) = v52;
        v44 = v18 - v30;
        v53 += v32;
        v50 = v30;
        v45 = v18;
        v46 = 1 << (v18 - v30);
        if ( v18 < v14 )
        {
          do
          {
            v47 = v46 - (unsigned __int16)*(&v57 + v45);
            if ( v47 <= 0 )
              break;
            v45 = (unsigned int)(v45 + 1);
            ++v44;
            v46 = 2 * v47;
          }
          while ( (unsigned int)v45 < v14 );
        }
        v32 = (unsigned int)(1 << v44);
        v33 += v32;
        if ( v61 == 1 )
        {
          v48 = v33 < 0x354;
          v49 = v33 == 852;
        }
        else
        {
          if ( v61 != 2 )
            goto LABEL_74;
          v48 = v33 < 0x250;
          v49 = v33 == 592;
        }
        if ( !v48 && !v49 )
          return 1i64;
LABEL_74:
        v30 = 4 * v43;
        v15 = v31 & v55;
        v29 = v53;
        *(_BYTE *)(v30 + *v65) = v44;
        *(_BYTE *)(v30 + *v65 + 1) = v52;
        v27 = a6;
        *(_WORD *)(v30 + *v65 + 2) = ((signed __int64)v53 - *v65) >> 2;
        LOBYTE(v30) = v50;
        LODWORD(v36) = v51;
      }
    }
  }
  if ( v31 )
  {
    LOBYTE(v64) = 64;
    WORD1(v64) = 0;
    *(_WORD *)((char *)&v64 + 1) = (unsigned __int8)(v18 - v50);
    v29[v31] = v64;
  }
  *v65 += 4i64 * v33;
  *a5 = v52;
  return 0i64;
}
// 140016240: using guessed type __int16 var_4E[15];
// 140016240: using guessed type __int16 var_2E[19];

//----- (00000001400166A0) ----------------------------------------------------
signed __int64 __fastcall sub_1400166A0(__int64 *a1, int a2)
{
  __int64 v2; // r12
  int v3; // er13
  __int64 v4; // rsi
  __int64 v5; // r8
  int v6; // ecx
  __int64 v7; // r9
  __int64 v8; // rdi
  unsigned int v9; // er14
  unsigned int v10; // ebx
  unsigned int v11; // er11
  _BYTE *v12; // r8
  unsigned __int8 *v13; // rsi
  unsigned __int8 *v14; // r13
  _BYTE *v15; // r15
  int v16; // edx
  int v17; // eax
  unsigned int v18; // er10
  char v19; // dl
  unsigned int v20; // er10
  unsigned int v21; // edx
  int v22; // eax
  int v23; // eax
  int v24; // eax
  unsigned int v25; // edi
  char v26; // dl
  unsigned int v27; // edx
  unsigned int v28; // edi
  int v29; // eax
  int v30; // eax
  int v31; // eax
  int v32; // eax
  unsigned int v33; // edi
  int v34; // eax
  unsigned int v35; // ecx
  signed __int64 v36; // r9
  _BYTE *v37; // r9
  char v38; // al
  __int64 v39; // rax
  unsigned int v40; // ecx
  signed __int64 v41; // r9
  char v42; // al
  unsigned int v43; // ecx
  char v44; // al
  char v45; // al
  __int64 v46; // rcx
  char v47; // al
  _BYTE *v48; // rcx
  char v49; // al
  bool v50; // zf
  __int64 *v51; // rdx
  const char *v52; // rax
  unsigned __int8 *v53; // rsi
  int v54; // er11
  signed __int64 v55; // r15
  signed __int64 result; // rax
  __int64 v57; // [rsp+0h] [rbp-78h]
  __int64 v58; // [rsp+8h] [rbp-70h]
  int v59; // [rsp+10h] [rbp-68h]
  __int64 v60; // [rsp+18h] [rbp-60h]
  int i; // [rsp+20h] [rbp-58h]
  __int64 *v62; // [rsp+80h] [rbp+8h]
  int v63; // [rsp+88h] [rbp+10h]
  int v64; // [rsp+90h] [rbp+18h]
  unsigned int v65; // [rsp+98h] [rbp+20h]

  v62 = a1;
  v2 = a1[5];
  v3 = *((_DWORD *)a1 + 2);
  v4 = *a1;
  v5 = a1[2];
  v6 = *((_DWORD *)a1 + 6);
  v7 = *(_QWORD *)(v2 + 88);
  v8 = *(_QWORD *)(v2 + 96);
  v9 = *(_DWORD *)(v2 + 52);
  v10 = *(_DWORD *)(v2 + 64);
  v11 = *(_DWORD *)(v2 + 68);
  v12 = (_BYTE *)(v5 - 1);
  v13 = (unsigned __int8 *)(v4 - 1);
  v63 = *(_DWORD *)(v2 + 44);
  v59 = (_DWORD)v12 - (a2 - v6);
  v65 = *(_DWORD *)(v2 + 48);
  v60 = *(_QWORD *)(v2 + 56);
  v14 = &v13[v3 - 5];
  v15 = &v12[v6 - 257];
  v58 = *(_QWORD *)(v2 + 88);
  v57 = *(_QWORD *)(v2 + 96);
  v64 = (1 << *(_DWORD *)(v2 + 108)) - 1;
  v16 = (1 << *(_DWORD *)(v2 + 104)) - 1;
  for ( i = (1 << *(_DWORD *)(v2 + 104)) - 1; ; v16 = i )
  {
    if ( v11 < 0xF )
    {
      v17 = v13[1];
      v13 += 2;
      v10 += (*v13 << (v11 + 8)) + (v17 << v11);
      v11 += 16;
    }
    v18 = *(_DWORD *)(v7 + 4i64 * (v16 & v10));
    v19 = *(_DWORD *)(v7 + 4i64 * (v16 & v10));
    v10 >>= SBYTE1(v18);
    v11 -= BYTE1(v18);
    if ( (_BYTE)v18 )
      break;
LABEL_8:
    *++v12 = BYTE2(v18);
LABEL_55:
    if ( v13 >= v14 || v12 >= v15 )
    {
      v51 = v62;
      goto LABEL_65;
    }
  }
  while ( 1 )
  {
    if ( v19 & 0x10 )
    {
      v20 = v18 >> 16;
      v21 = v19 & 0xF;
      if ( v21 )
      {
        if ( v11 < v21 )
        {
          v22 = (v13++)[1];
          v10 += v22 << v11;
          v11 += 8;
        }
        v23 = v10 & ((1 << v21) - 1);
        v10 >>= v21;
        v20 += v23;
        v11 -= v21;
      }
      if ( v11 < 0xF )
      {
        v24 = v13[1];
        v13 += 2;
        v10 += (*v13 << (v11 + 8)) + (v24 << v11);
        v11 += 16;
      }
      v25 = *(_DWORD *)(v8 + 4i64 * (v10 & v64));
      v26 = v25;
      v10 >>= SBYTE1(v25);
      v11 -= BYTE1(v25);
      if ( !(v25 & 0x10) )
      {
        while ( !(v26 & 0x40) )
        {
          v25 = *(_DWORD *)(v57 + 4i64 * ((v25 >> 16) + (v10 & ((1 << v26) - 1))));
          v26 = v25;
          v10 >>= SBYTE1(v25);
          v11 -= BYTE1(v25);
          if ( v25 & 0x10 )
            goto LABEL_18;
        }
        v52 = "invalid distance code";
        goto LABEL_62;
      }
LABEL_18:
      v27 = v26 & 0xF;
      v28 = v25 >> 16;
      if ( v11 < v27 )
      {
        v29 = (v13++)[1];
        v30 = v29 << v11;
        v11 += 8;
        v10 += v30;
        if ( v11 < v27 )
        {
          v31 = (v13++)[1];
          v10 += v31 << v11;
          v11 += 8;
        }
      }
      v11 -= v27;
      v32 = v10 & ((1 << v27) - 1);
      v10 >>= v27;
      v33 = v32 + v28;
      v34 = (_DWORD)v12 - v59;
      if ( v33 <= (signed int)v12 - v59 )
      {
        v48 = &v12[-v33];
        do
        {
          v49 = v48[1];
          v12 += 3;
          v48 += 3;
          *(v12 - 2) = v49;
          v20 -= 3;
          *(v12 - 1) = *(v48 - 1);
          *v12 = *v48;
        }
        while ( v20 > 2 );
        if ( !v20 )
          goto LABEL_54;
        v8 = v57;
        *++v12 = v48[1];
        if ( v20 > 1 )
          *++v12 = v48[2];
        goto LABEL_55;
      }
      v35 = v33 - v34;
      if ( v33 - v34 > v65 && *(_DWORD *)(v2 + 7128) )
      {
        v52 = "invalid distance too far back";
LABEL_62:
        v51 = v62;
        v62[4] = (__int64)v52;
        *(_DWORD *)v2 = 29;
        goto LABEL_65;
      }
      v36 = v60 - 1;
      if ( v9 )
      {
        v39 = v9 - v35;
        if ( v9 < v35 )
        {
          v40 = v35 - v9;
          v37 = (_BYTE *)((unsigned int)(v63 + v39) + v36);
          if ( v40 >= v20 )
            goto LABEL_41;
          v20 -= v40;
          v41 = v37 - v12;
          do
          {
            v42 = (v12++)[v41 + 1];
            *v12 = v42;
            --v40;
          }
          while ( v40 );
          v37 = (_BYTE *)(v60 - 1);
          if ( v9 >= v20 )
            goto LABEL_41;
          v43 = v9;
          v20 -= v9;
          do
          {
            v44 = v37[1];
            ++v12;
            ++v37;
            *v12 = v44;
            --v43;
          }
          while ( v43 );
          goto LABEL_40;
        }
        v37 = (_BYTE *)(v39 + v36);
        if ( v35 < v20 )
        {
          v20 -= v35;
          do
          {
            v45 = v37[1];
            ++v12;
            ++v37;
            *v12 = v45;
            --v35;
          }
          while ( v35 );
          goto LABEL_40;
        }
      }
      else
      {
        v37 = (_BYTE *)(v63 - v35 + v36);
        if ( v35 < v20 )
        {
          v20 -= v35;
          do
          {
            v38 = v37[1];
            ++v12;
            ++v37;
            *v12 = v38;
            --v35;
          }
          while ( v35 );
LABEL_40:
          v37 = &v12[-v33];
          goto LABEL_41;
        }
      }
LABEL_41:
      if ( v20 > 2 )
      {
        v46 = (v20 - 3) / 3 + 1;
        do
        {
          v47 = v37[1];
          v37 += 3;
          v12 += 3;
          *(v12 - 2) = v47;
          v20 -= 3;
          *(v12 - 1) = *(v37 - 1);
          *v12 = *v37;
          --v46;
        }
        while ( v46 );
      }
      if ( !v20 )
      {
        v7 = v58;
LABEL_54:
        v8 = v57;
        goto LABEL_55;
      }
      v8 = v57;
      *++v12 = v37[1];
      if ( v20 > 1 )
        *++v12 = v37[2];
      v7 = v58;
      goto LABEL_55;
    }
    if ( v19 & 0x40 )
      break;
    v18 = *(_DWORD *)(v7 + 4i64 * ((v18 >> 16) + (v10 & ((1 << v19) - 1))));
    v19 = v18;
    v10 >>= SBYTE1(v18);
    v11 -= BYTE1(v18);
    if ( !(_BYTE)v18 )
      goto LABEL_8;
  }
  v50 = (v19 & 0x20) == 0;
  v51 = v62;
  if ( v50 )
  {
    v62[4] = (__int64)"invalid literal/length code";
    *(_DWORD *)v2 = 29;
  }
  else
  {
    *(_DWORD *)v2 = 11;
  }
LABEL_65:
  v53 = &v13[-(v11 >> 3)];
  v54 = v11 - 8 * (v11 >> 3);
  *v51 = (__int64)(v53 + 1);
  v51[2] = (__int64)(v12 + 1);
  *((_DWORD *)v51 + 2) = (_DWORD)v14 - (_DWORD)v53 + 5;
  v55 = v15 - v12;
  result = v55 + 257;
  *((_DWORD *)v51 + 6) = v55 + 257;
  *(_DWORD *)(v2 + 64) = ((1 << v54) - 1) & v10;
  *(_DWORD *)(v2 + 68) = v54;
  return result;
}

//----- (0000000140016B80) ----------------------------------------------------
void *__fastcall sub_140016B80(__int64 a1, int a2, int a3)
{
  return malloc((unsigned int)(a3 * a2));
}

//----- (0000000140016B9C) ----------------------------------------------------
_WORD *__fastcall sub_140016B9C(_WORD *a1, signed __int64 a2)
{
  _WORD *v2; // rbx

  v2 = a1;
  if ( a2 < 0 )
  {
    *a1 = 45;
    ++a1;
    a2 = -a2;
  }
  sub_140016BCC(a1, a2);
  return v2;
}

//----- (0000000140016BCC) ----------------------------------------------------
_WORD *__fastcall sub_140016BCC(_WORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r10
  _WORD *v3; // r8
  char *v4; // r9
  unsigned __int64 v5; // rdx
  char v7; // [rsp+0h] [rbp-48h]

  v2 = a2;
  v3 = a1;
  v4 = &v7;
  do
  {
    v5 = (unsigned __int64)(v2 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 3;
    *(_WORD *)v4 = v2 - 10 * v5 + 48;
    v4 += 2;
    v2 = (unsigned __int64)(v2 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 3;
  }
  while ( v5 );
  do
  {
    v4 -= 2;
    *v3 = *(_WORD *)v4;
    ++v3;
  }
  while ( v4 != &v7 );
  *v3 = 0;
  return a1;
}

//----- (0000000140016C40) ----------------------------------------------------
__int64 __fastcall sub_140016C40(signed __int64 *a1)
{
  signed __int64 *v1; // rbx
  __int64 v2; // rcx
  signed __int64 v3; // rcx
  signed __int64 v4; // rax

  v1 = a1;
  v2 = 0i64;
  if ( v1 )
  {
    while ( 1 )
    {
      do
      {
        v4 = *v1;
        if ( *v1 == -1 )
          return v2;
        ++v1;
      }
      while ( v4 < -7 );
      if ( v4 <= -4 )
      {
        v2 = 1i64;
        goto LABEL_11;
      }
      if ( v4 == -3 )
        break;
      if ( v4 == -2 )
      {
        v3 = v1[3];
        v1 += 4;
LABEL_9:
        v2 = sub_140016C40(v3);
LABEL_11:
        if ( v2 )
          return v2;
      }
    }
    v3 = v1[2];
    v1 += 3;
    goto LABEL_9;
  }
  return v2;
}

//----- (0000000140016CA8) ----------------------------------------------------
void __fastcall sub_140016CA8(char *a1, signed __int64 a2, int *a3, char *a4)
{
  int *v4; // rbx
  signed __int64 v5; // rax
  char *v6; // rbp
  signed __int64 v7; // r8
  char *v8; // r10
  signed __int64 v9; // rdi
  const wchar_t *v10; // rax
  LPVOID *v11; // rsi
  void *v12; // rcx
  __int64 v13; // rsi
  size_t v14; // rax
  __int64 v15; // rdx
  signed __int64 v16; // rcx
  __int64 v17; // rbx
  char *v18; // rbp
  __int64 v19; // rsi
  signed __int64 v20; // rsi
  __int64 v21; // r8
  char *v22; // r9
  char *v23; // rcx
  __int64 v24; // rdx
  __int64 v25; // rsi
  char *v26; // rax
  __int64 v27; // rcx
  __int64 v28; // rax
  __int64 v29; // rsi
  char *v30; // rax
  __int64 v31; // rcx
  __int64 v32; // rsi
  char *v33; // rdx
  __int64 v34; // rcx
  int *v35; // rbx
  __int64 v36; // rsi
  char *v37; // rax
  __int64 v38; // rcx
  __int64 v39; // rax
  char *v40; // rdx
  __int64 v41; // [rsp+20h] [rbp-78h]
  size_t Size; // [rsp+30h] [rbp-68h]
  size_t Sizea; // [rsp+30h] [rbp-68h]
  char *Sizeb; // [rsp+30h] [rbp-68h]
  char *Sizec; // [rsp+30h] [rbp-68h]
  int Sized; // [rsp+30h] [rbp-68h]
  signed __int64 v47; // [rsp+38h] [rbp-60h]
  __int64 v48; // [rsp+50h] [rbp-48h]
  __int64 v49; // [rsp+60h] [rbp-38h]
  char *v50; // [rsp+60h] [rbp-38h]
  char *v51; // [rsp+60h] [rbp-38h]
  char *v52; // [rsp+A0h] [rbp+8h]
  signed __int64 v53; // [rsp+A8h] [rbp+10h]
  int *v54; // [rsp+B0h] [rbp+18h]
  char *v55; // [rsp+B8h] [rbp+20h]

  if ( a4 == a1 )
    return;
  v55 = a4;
  v53 = a2;
  v52 = a1;
  v4 = a3;
  v5 = 0i64;
  v6 = a4;
  v7 = a2;
  v8 = a1;
  v47 = 0i64;
  if ( v4 )
  {
    v9 = *(_QWORD *)v4;
    if ( *(_QWORD *)v4 == -1i64 )
      goto LABEL_43;
    while ( 1 )
    {
      v4 += 2;
      if ( v9 == -7 )
      {
        v9 = *(_QWORD *)v4;
        v35 = v4 + 2;
        v36 = *(_QWORD *)&v6[v9];
        Sized = *v35;
        v37 = &v8[v9];
        v38 = *(_QWORD *)&v8[v9];
        v51 = &v8[v9];
        v4 = &v35[2 * (*v35 + 3) + 2];
        if ( v38 )
        {
          qword_140021190(v38);
          v37 = v51;
        }
        if ( v36 )
        {
          v39 = qword_140021160(
                  *(_QWORD *)(v36 - 40),
                  *(_QWORD *)(v36 - 16),
                  *(unsigned int *)(v36 - 8),
                  *(_QWORD *)(v36 - 32),
                  v37);
          *(_DWORD *)(v39 - 48) = *(_DWORD *)(v36 - 48);
          qword_140021178(v36, v39, 0i64);
        }
        v20 = 8i64 * Sized + 8;
        goto LABEL_39;
      }
      if ( v9 == -6 )
        break;
      if ( v9 == -5 )
      {
        v9 = *(_QWORD *)v4;
        v4 += 8;
        v29 = *(_QWORD *)&v6[v9];
        v30 = &v8[v9];
        v31 = *(_QWORD *)&v8[v9];
        Sizeb = &v8[v9];
        if ( v31 )
        {
          qword_140021198(v31);
          v30 = Sizeb;
        }
        if ( v29 )
        {
          qword_140021168(*(_QWORD *)(v29 + 80) - 16i64, v30, *(_QWORD *)(v29 + 48), *(unsigned int *)(v29 + 88));
          qword_140021180(*(_QWORD *)&v6[v9], *(_QWORD *)Sizeb, 0i64);
        }
        v20 = 16i64;
        goto LABEL_39;
      }
      if ( v9 == -4 )
      {
        v9 = *(_QWORD *)v4;
        v4 += 10;
        v25 = *(_QWORD *)&v6[v9];
        v26 = &v8[v9];
        v27 = *(_QWORD *)&v8[v9];
        v50 = &v8[v9];
        if ( v27 )
        {
          qword_140021190(v27);
          v26 = v50;
        }
        if ( v25 )
        {
          v28 = qword_140021160(
                  *(_QWORD *)(v25 - 40),
                  *(_QWORD *)(v25 - 16),
                  *(unsigned int *)(v25 - 8),
                  *(_QWORD *)(v25 - 32),
                  v26);
          qword_140021178(v25, v28, 0i64);
        }
LABEL_24:
        v20 = 8i64;
        goto LABEL_39;
      }
      if ( v9 != -3 )
      {
        if ( v9 == -2 )
        {
          v13 = *(_QWORD *)v4;
          v9 = *((_QWORD *)v4 + 1);
          v14 = *((_QWORD *)v4 + 2);
          v15 = *((_QWORD *)v4 + 3);
          v4 += 8;
          v49 = v13;
          Sizea = v14;
          v54 = v4;
          v48 = v15;
          if ( v13 > 0 )
          {
            v16 = v6 - v8;
            v17 = v13;
            v18 = &v8[v9];
            v19 = v16;
            do
            {
              sub_140016CA8(v18, Sizea, v15, &v18[v19]);
              v15 = v48;
              v18 += Sizea;
              --v17;
            }
            while ( v17 );
            v4 = v54;
            v13 = v49;
            v6 = v55;
            v14 = Sizea;
          }
          v20 = v14 * v13;
          goto LABEL_39;
        }
        v10 = *(const wchar_t **)&v6[v9];
        v11 = (LPVOID *)&v8[v9];
        v12 = *(void **)&v8[v9];
        Size = *(_QWORD *)&v6[v9];
        if ( v12 )
        {
          sub_140012AD0(v12);
          *v11 = 0i64;
          v10 = (const wchar_t *)Size;
        }
        if ( v10 )
          sub_140012A60(v11, v10);
        goto LABEL_24;
      }
      v9 = *(_QWORD *)v4;
      v20 = *((_QWORD *)v4 + 1);
      v21 = *((_QWORD *)v4 + 2);
      v22 = &v6[*(_QWORD *)v4];
      v23 = &v8[*(_QWORD *)v4];
      v24 = *((_QWORD *)v4 + 1);
      v4 += 6;
      sub_140016CA8(v23, v24, v21, v22);
LABEL_39:
      if ( v47 < v9 )
        memcpy(&v52[v47], &v6[v47], v9 - v47);
      v8 = v52;
      v5 = v20 + v9;
      v9 = *(_QWORD *)v4;
      v47 = v5;
      if ( *(_QWORD *)v4 == -1i64 )
      {
        v7 = v53;
LABEL_43:
        if ( v5 < v7 )
        {
          v7 -= v5;
          v40 = &v6[v5];
          a1 = &v8[v5];
          goto LABEL_46;
        }
        return;
      }
    }
    v9 = *(_QWORD *)v4;
    v4 += 10;
    v32 = *(_QWORD *)&v6[v9];
    v33 = &v8[v9];
    v34 = *(_QWORD *)&v8[v9];
    Sizec = &v8[v9];
    if ( v34 )
    {
      qword_1400211A0(v34);
      v33 = Sizec;
    }
    if ( v32 )
    {
      LODWORD(v41) = *(_DWORD *)(v32 + 60);
      qword_140021170(*(_QWORD *)(v32 + 48), *(unsigned int *)(v32 + 56), *(_QWORD *)(v32 + 32), v33, v41);
      qword_140021188(*(_QWORD *)&v6[v9], *(_QWORD *)Sizec, 0i64);
    }
    goto LABEL_24;
  }
  v40 = a4;
LABEL_46:
  memcpy(a1, v40, v7);
}
// 140021160: using guessed type __int64 (__fastcall *qword_140021160)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140021168: using guessed type __int64 (__fastcall *qword_140021168)(_QWORD, _QWORD, _QWORD, _QWORD);
// 140021170: using guessed type __int64 (__fastcall *qword_140021170)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140021178: using guessed type __int64 (__fastcall *qword_140021178)(_QWORD, _QWORD, _QWORD);
// 140021180: using guessed type __int64 (__fastcall *qword_140021180)(_QWORD, _QWORD, _QWORD);
// 140021188: using guessed type __int64 (__fastcall *qword_140021188)(_QWORD, _QWORD, _QWORD);
// 140021190: using guessed type __int64 (__fastcall *qword_140021190)(_QWORD);
// 140021198: using guessed type __int64 (__fastcall *qword_140021198)(_QWORD);
// 1400211A0: using guessed type __int64 (__fastcall *qword_1400211A0)(_QWORD);

//----- (0000000140017030) ----------------------------------------------------
signed __int64 __fastcall sub_140017030(__int64 a1, signed __int64 *a2)
{
  signed __int64 result; // rax
  signed __int64 *v3; // rbx
  __int64 v4; // rdi
  void *v5; // rcx
  signed __int64 v6; // rsi
  signed __int64 v7; // rax
  signed __int64 v8; // rcx
  signed __int64 v9; // rdx
  int v10; // ebp
  __int64 v11; // rax
  signed __int64 v12; // rcx
  signed __int64 v13; // rdx
  signed __int64 v14; // rcx
  signed __int64 v15; // rcx
  signed __int64 v16; // rcx
  signed __int64 v17; // [rsp+20h] [rbp-28h]
  signed __int64 v18; // [rsp+60h] [rbp+18h]
  signed __int64 v19; // [rsp+68h] [rbp+20h]

  result = *a2;
  v3 = a2;
  v4 = a1;
  while ( result != -1 )
  {
    ++v3;
    switch ( result )
    {
      case -7i64:
        v14 = *v3;
        v3 += v3[1] + 5;
        goto LABEL_19;
      case -6i64:
        v16 = *v3;
        v3 += 5;
        qword_1400211A0(*(_QWORD *)(v16 + v4));
        break;
      case -5i64:
        v15 = *v3;
        v3 += 4;
        qword_140021198(*(_QWORD *)(v15 + v4));
        break;
      case -4i64:
        v14 = *v3;
        v3 += 5;
LABEL_19:
        qword_140021190(*(_QWORD *)(v14 + v4));
        break;
      case -3i64:
        v12 = *v3;
        v13 = v3[2];
        v3 += 3;
        sub_140017030(v4 + v12, v13);
        break;
      case -2i64:
        v6 = *v3;
        v7 = v3[1];
        v8 = v3[2];
        v9 = v3[3];
        v3 += 4;
        v10 = 0;
        v18 = v7;
        v19 = v8;
        v17 = v9;
        if ( v6 > 0 )
        {
          v11 = 0i64;
          do
          {
            sub_140017030(v4 + v18 + v11 * v8, v9);
            v8 = v19;
            v9 = v17;
            v11 = ++v10;
          }
          while ( v10 < v6 );
        }
        break;
      default:
        v5 = *(void **)(result + v4);
        if ( v5 )
          sub_140012AD0(v5);
        break;
    }
    result = *v3;
  }
  return result;
}
// 140021190: using guessed type __int64 (__fastcall *qword_140021190)(_QWORD);
// 140021198: using guessed type __int64 (__fastcall *qword_140021198)(_QWORD);
// 1400211A0: using guessed type __int64 (__fastcall *qword_1400211A0)(_QWORD);

//----- (000000014001717C) ----------------------------------------------------
__int64 __fastcall sub_14001717C(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax
  _QWORD *v3; // rbx
  __int64 i; // rdi
  __int64 v5; // rsi
  __int64 *v6; // rbx
  __int64 v7; // rax
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 v10; // rbp
  __int64 v11; // rbx
  __int64 v12; // rcx
  __int64 *v13; // rbx
  __int64 v14; // rdx
  __int64 v15; // rax
  __int64 *v16; // rbx
  __int64 v17; // rcx
  __int64 v18; // rdx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rdx
  __int64 *v22; // rbx
  __int64 v23; // rcx
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 v26; // r9
  __int64 *v27; // rbx
  __int64 v28; // rcx
  __int64 v29; // rdx
  __int64 v30; // r8
  __int64 v31; // rax
  __int64 v32; // rsi
  __int64 *v33; // rbx
  __int64 v34; // rcx
  __int64 v35; // rdx
  __int64 v36; // r8
  __int64 v37; // r9
  __int64 v38; // r11
  _QWORD *v39; // r10
  __int64 v40; // rax
  __int64 v41; // [rsp+20h] [rbp-38h]
  __int64 v42; // [rsp+60h] [rbp+8h]
  _QWORD *v43; // [rsp+68h] [rbp+10h]
  __int64 v44; // [rsp+70h] [rbp+18h]

  v42 = a1;
  result = *a2;
  v3 = a2;
  for ( i = a1; *v3 != -1i64; result = *v3 )
  {
    ++v3;
    switch ( result )
    {
      case -7i64:
        v32 = *v3;
        v33 = v3 + 1;
        v34 = *v33;
        ++v33;
        v35 = *v33;
        ++v33;
        v36 = *v33;
        ++v33;
        v37 = *v33;
        v3 = v33 + 1;
        if ( v34 > 0 )
        {
          v38 = v34;
          v39 = (_QWORD *)(v32 + i + 8);
          do
          {
            v40 = *v3;
            ++v3;
            *v39 = v40;
            ++v39;
            --v38;
          }
          while ( v38 );
        }
        qword_140021158(v34, v35, v36, v37, v32 + i);
        break;
      case -6i64:
        v26 = *v3;
        v27 = v3 + 1;
        v28 = *v27;
        ++v27;
        v29 = *v27;
        ++v27;
        v30 = *v27;
        ++v27;
        v31 = *v27;
        v3 = v27 + 1;
        LODWORD(v41) = v31;
        qword_140021170(v28, v29, v30, i + v26, v41);
        break;
      case -5i64:
        v21 = *v3;
        v22 = v3 + 1;
        v23 = *v22;
        ++v22;
        v24 = *v22;
        ++v22;
        v25 = *v22;
        v3 = v22 + 1;
        qword_140021168(v23, i + v21, v24, v25);
        break;
      case -4i64:
        v15 = *v3;
        v16 = v3 + 1;
        v17 = *v16;
        ++v16;
        v18 = *v16;
        ++v16;
        v19 = *v16;
        ++v16;
        v20 = *v16;
        v3 = v16 + 1;
        qword_140021160(v17, v18, v19, v20, i + v15);
        break;
      case -3i64:
        v12 = *v3;
        v13 = v3 + 2;
        v14 = *v13;
        v3 = v13 + 1;
        sub_14001717C(i + v12, v14);
        break;
      case -2i64:
        v5 = *v3;
        v6 = v3 + 1;
        v7 = *v6;
        ++v6;
        v8 = *v6;
        ++v6;
        v44 = v8;
        v9 = *v6;
        v3 = v6 + 1;
        v43 = v3;
        if ( v5 > 0 )
        {
          v10 = v7 + i;
          v11 = v9;
          do
          {
            sub_14001717C(v10, v11);
            v10 += v44;
            --v5;
          }
          while ( v5 );
          v3 = v43;
          i = v42;
        }
        break;
    }
  }
  return result;
}
// 140021158: using guessed type __int64 (__fastcall *qword_140021158)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140021160: using guessed type __int64 (__fastcall *qword_140021160)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140021168: using guessed type __int64 (__fastcall *qword_140021168)(_QWORD, _QWORD, _QWORD, _QWORD);
// 140021170: using guessed type __int64 (__fastcall *qword_140021170)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140017338) ----------------------------------------------------
BOOL __fastcall sub_140017338(HANDLE *a1)
{
  HANDLE *v1; // rdi
  HANDLE *v2; // rdx
  _QWORD *v3; // rsi
  _QWORD *v4; // rbx

  v1 = a1;
  UnregisterWait(a1[3]);
  CloseHandle(v1[4]);
  EnterCriticalSection(&stru_1400211B8);
  if ( *v1 )
    *((_QWORD *)*v1 + 1) = v1[1];
  else
    qword_1400211B0 = (__int64)v1[1];
  v2 = (HANDLE *)v1[1];
  if ( v2 )
    *v2 = *v1;
  LeaveCriticalSection(&stru_1400211B8);
  v3 = v1[2];
  while ( v3 )
  {
    v4 = v3;
    v3 = (_QWORD *)*v3;
    ((void (__fastcall *)(_QWORD))v4[1])(v4[2]);
    HeapFree(hHeap, 0, v4);
  }
  return HeapFree(hHeap, 0, v1);
}
// 1400211B0: using guessed type __int64 qword_1400211B0;

//----- (00000001400173EC) ----------------------------------------------------
void sub_1400173EC()
{
  if ( dword_1400211A8 )
  {
    TlsFree(dword_1400211E0);
    while ( qword_1400211B0 )
      sub_140017338((HANDLE *)qword_1400211B0);
    DeleteCriticalSection(&stru_1400211B8);
    dword_1400211A8 = 0;
  }
}
// 1400211A8: using guessed type int dword_1400211A8;
// 1400211B0: using guessed type __int64 qword_1400211B0;

//----- (0000000140017434) ----------------------------------------------------
_QWORD *__fastcall sub_140017434(__int64 a1, __int64 a2)
{
  __int64 v2; // r14
  __int64 v3; // r15
  LPVOID v4; // rbp
  _QWORD *result; // rax
  __int64 v6; // rax
  HANDLE v7; // rdi
  HANDLE v8; // rbx
  HANDLE v9; // rax

  v2 = a2;
  v3 = a1;
  if ( !dword_1400211A8 )
  {
    dword_1400211E0 = TlsAlloc();
    InitializeCriticalSection(&stru_1400211B8);
    dword_1400211A8 = 1;
  }
  v4 = TlsGetValue(dword_1400211E0);
  if ( !v4 )
  {
    result = HeapAlloc(hHeap, 8u, 0x28ui64);
    v4 = result;
    if ( !result )
      return result;
    EnterCriticalSection(&stru_1400211B8);
    v6 = qword_1400211B0;
    if ( qword_1400211B0 )
      *(_QWORD *)qword_1400211B0 = v4;
    *((_QWORD *)v4 + 1) = v6;
    qword_1400211B0 = (__int64)v4;
    LeaveCriticalSection(&stru_1400211B8);
    v7 = GetCurrentProcess();
    v8 = GetCurrentThread();
    v9 = GetCurrentProcess();
    DuplicateHandle(v9, v8, v7, (LPHANDLE)v4 + 4, 0x100000u, 0, 0);
    RegisterWaitForSingleObject((PHANDLE)v4 + 3, *((HANDLE *)v4 + 4), (WAITORTIMERCALLBACK)Callback, v4, 0xFFFFFFFF, 8u);
    TlsSetValue(dword_1400211E0, v4);
  }
  result = HeapAlloc(hHeap, 0, 0x18ui64);
  if ( result )
  {
    result[1] = v3;
    result[2] = v2;
    *result = *((_QWORD *)v4 + 2);
    *((_QWORD *)v4 + 2) = result;
  }
  return result;
}
// 1400211A8: using guessed type int dword_1400211A8;
// 1400211B0: using guessed type __int64 qword_1400211B0;

//----- (000000014001759C) ----------------------------------------------------
void __fastcall Callback(PVOID a1, char a2)
{
  if ( !a2 )
    sub_140017338((HANDLE *)a1);
}

//----- (00000001400175C0) ----------------------------------------------------
_BYTE *__fastcall sub_1400175C0(LPCWSTR lpWideCharStr)
{
  const WCHAR *v1; // rdi
  signed __int64 v2; // rbx
  int v4; // eax
  int cbMultiByte; // ebp
  CHAR *lpMultiByteStr; // rax
  CHAR *v7; // rsi
  __int64 v8; // rcx
  _BYTE *result; // rax

  v1 = lpWideCharStr;
  if ( !lpWideCharStr )
    goto LABEL_10;
  v2 = -1i64;
  while ( lpWideCharStr[v2++ + 1] != 0 )
    ;
  v4 = WideCharToMultiByte(0xFDE9u, 0, lpWideCharStr, v2 + 1, 0i64, 0, 0i64, 0i64);
  cbMultiByte = v4;
  if ( v4 && (lpMultiByteStr = (CHAR *)malloc(v4 + 1i64), (v7 = lpMultiByteStr) != 0i64) )
  {
    v8 = WideCharToMultiByte(0xFDE9u, 0, v1, v2 + 1, lpMultiByteStr, cbMultiByte, 0i64, 0i64);
    result = v7;
    v7[v8] = 0;
  }
  else
  {
LABEL_10:
    result = malloc(1ui64);
    *result = 0;
  }
  return result;
}

//----- (00000001400176A0) ----------------------------------------------------
int __fastcall sub_1400176A0(LPCSTR lpMultiByteStr, int a2)
{
  const CHAR *v2; // rsi
  int v3; // ebp
  signed __int64 v4; // rbx
  int v6; // eax
  int cchWideChar; // edi
  WCHAR *lpWideCharStr; // rax

  v2 = (const CHAR *)&unk_14001CB1B;
  v3 = a2;
  if ( lpMultiByteStr )
    v2 = lpMultiByteStr;
  v4 = -1i64;
  while ( v2[v4++ + 1] != 0 )
    ;
  v6 = MultiByteToWideChar(0xFDE9u, 0, v2, v4 + 1, 0i64, 0);
  cchWideChar = v6;
  lpWideCharStr = (WCHAR *)sub_140012E40(v6 - 1, v3);
  return MultiByteToWideChar(0xFDE9u, 0, v2, v4 + 1, lpWideCharStr, cchWideChar);
}

//----- (0000000140017740) ----------------------------------------------------
WCHAR *__fastcall sub_140017740(LPCSTR lpMultiByteStr)
{
  const CHAR *v1; // rbp
  signed __int64 v2; // rbx
  int cchWideChar; // edi
  WCHAR *lpWideCharStr; // rsi

  v1 = (const CHAR *)&unk_14001CB1B;
  if ( lpMultiByteStr )
    v1 = lpMultiByteStr;
  v2 = -1i64;
  while ( v1[v2++ + 1] != 0 )
    ;
  cchWideChar = MultiByteToWideChar(0xFDE9u, 0, v1, v2 + 1, 0i64, 0);
  lpWideCharStr = (WCHAR *)malloc(2i64 * cchWideChar);
  MultiByteToWideChar(0xFDE9u, 0, v1, v2 + 1, lpWideCharStr, cchWideChar);
  return lpWideCharStr;
}

//----- (00000001400177E0) ----------------------------------------------------
int __fastcall sub_1400177E0(LPCSTR lpMultiByteStr, int a2)
{
  int v2; // edi
  const CHAR *v3; // rsi
  signed __int64 v4; // rbx
  int v5; // eax
  int cchWideChar; // ebp
  WCHAR *lpWideCharStr; // rax
  WCHAR *v8; // rdi
  __int64 v9; // rax

  v2 = a2;
  v3 = lpMultiByteStr;
  if ( !lpMultiByteStr )
    goto LABEL_10;
  v4 = -1i64;
  do
    ++v4;
  while ( lpMultiByteStr[v4] );
  v5 = MultiByteToWideChar(0, 0, lpMultiByteStr, v4, 0i64, 0);
  cchWideChar = v5;
  if ( v5 )
  {
    lpWideCharStr = (WCHAR *)sub_140012E40(v5, v2);
    v8 = lpWideCharStr;
    LODWORD(v9) = MultiByteToWideChar(0, 0, v3, v4, lpWideCharStr, cchWideChar);
    v8[(signed int)v9] = 0;
  }
  else
  {
LABEL_10:
    v9 = sub_140012E40(0, v2);
    *(_WORD *)v9 = 0;
  }
  return v9;
}

//----- (0000000140017890) ----------------------------------------------------
_WORD *__fastcall sub_140017890(LPCSTR lpMultiByteStr)
{
  signed __int64 v1; // rbx
  _WORD *result; // rax

  if ( lpMultiByteStr )
  {
    v1 = -1i64;
    do
      ++v1;
    while ( lpMultiByteStr[v1] );
    if ( MultiByteToWideChar(0, 0, lpMultiByteStr, v1, 0i64, 0) )
      JUMPOUT(loc_1400178E0);
  }
  result = malloc(2ui64);
  *result = 0;
  return result;
}

//----- (0000000140017960) ----------------------------------------------------
_BYTE *__fastcall sub_140017960(LPCWSTR lpWideCharStr)
{
  const WCHAR *v1; // rdi
  signed __int64 v2; // rbx
  int v4; // eax
  int cbMultiByte; // ebp
  CHAR *lpMultiByteStr; // rax
  CHAR *v7; // rsi
  __int64 v8; // rcx
  _BYTE *result; // rax

  v1 = lpWideCharStr;
  if ( !lpWideCharStr )
    goto LABEL_10;
  v2 = -1i64;
  while ( lpWideCharStr[v2++ + 1] != 0 )
    ;
  v4 = WideCharToMultiByte(0, 0, lpWideCharStr, v2 + 1, 0i64, 0, 0i64, 0i64);
  cbMultiByte = v4;
  if ( v4 && (lpMultiByteStr = (CHAR *)malloc(v4 + 1), (v7 = lpMultiByteStr) != 0i64) )
  {
    v8 = WideCharToMultiByte(0, 0, v1, v2 + 1, lpMultiByteStr, cbMultiByte, 0i64, 0i64);
    result = v7;
    v7[v8] = 0;
  }
  else
  {
LABEL_10:
    result = malloc(1ui64);
    *result = 0;
  }
  return result;
}

#error "There were 11 decompilation failure(s) on 318 function(s)"
